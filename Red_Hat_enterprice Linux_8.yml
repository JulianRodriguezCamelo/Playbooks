---
###############################################################################
#
# Ansible Playbook for CIS Red Hat Enterprise Linux 8 Benchmark for Level 1 - Server
#
# Profile Description:
# This profile defines a baseline that aligns to the "Level 1 - Server"
# configuration from the Center for Internet Security® Red Hat Enterprise
# Linux 8 Benchmark™, v3.1.1.
# This profile includes Center for Internet Security®
# Red Hat Enterprise Linux 8 CIS Benchmarks™ content.
#
# Profile ID:  xccdf_org.ssgproject.content_profile_cis_server_l1
# Benchmark ID:  xccdf_org.ssgproject.content_benchmark_RHEL-8
# Benchmark Version:  0.1.67
# XCCDF Version:  1.2
#
###############################################################################

- name: "CIS Red Hat Enterprise Linux 8 Benchmark for Level 1 - Server"
  hosts: all
  become: true
  gather_facts: true

  tasks:
    - name: "1.1.1.1 Ensure cramfs kernel module is not available (Automated)"
      block:
         - name: "Check if cramfs module exists"
           shell: |
             l_mod_name="cramfs"
             l_mod_type="fs"
             for l_mod_path in $(readlink -e /usr/lib/modules/**/kernel/$l_mod_type 2>/dev/null || readlink -e /lib/modules/**/kernel/$l_mod_type 2>/dev/null); do
               if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}" 2>/dev/null)" ]; then
                 echo "exists"
               fi
             done
           register: cramfs_module_check
           changed_when: false
           failed_when: false

         - name: "Unload cramfs kernel module"
           community.general.modprobe:
             name: cramfs
             state: absent
           when: cramfs_module_check.stdout == "exists"
           failed_when: false

         - name: "Disable cramfs kernel module - install"
           lineinfile:
             path: /etc/modprobe.d/60-cramfs.conf
             line: "install cramfs /bin/false"
             create: yes
             owner: root
             group: root
             mode: '0644'
           when: cramfs_module_check.stdout == "exists"

         - name: "Disable cramfs kernel module - blacklist"
           lineinfile:
             path: /etc/modprobe.d/60-cramfs.conf
             line: "blacklist cramfs"
             create: yes
             owner: root
             group: root
             mode: '0644'
           when: cramfs_module_check.stdout == "exists"

         - name: "Verify cramfs is not loaded"
           command: lsmod | grep cramfs
           register: cramfs_loaded
           changed_when: false
           failed_when: false

         - name: "Display cramfs remediation status"
           debug:
             msg: "cramfs module has been disabled and unloaded"
           when: cramfs_module_check.stdout == "exists"
  

    - name: "1.1.1.2 Ensure fhs kernel module is not available (Automated)"
      block:
         - name: "Check if freevxfs module exists"
           shell: |
             l_mod_name="freevxfs"
             l_mod_type="fs"
             for l_mod_path in $(readlink -e /usr/lib/modules/**/kernel/$l_mod_type 2>/dev/null || readlink -e /lib/modules/**/kernel/$l_mod_type 2>/dev/null); do
               if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}" 2>/dev/null)" ]; then
                 echo "exists"
               fi
             done
           register: freevxfs_module_check
           changed_when: false
           failed_when: false

         - name: "Unload freevxfs kernel module"
           community.general.modprobe:
             name: freevxfs
             state: absent
           when: freevxfs_module_check.stdout == "exists"
           failed_when: false

         - name: "Disable freevxfs kernel module - install"
           lineinfile:
             path: /etc/modprobe.d/60-freevxfs.conf
             line: "install freevxfs /bin/false"
             create: yes
             owner: root
             group: root
             mode: '0644'
           when: freevxfs_module_check.stdout == "exists"

         - name: "Disable freevxfs kernel module - blacklist"
           lineinfile:
             path: /etc/modprobe.d/60-freevxfs.conf
             line: "blacklist freevxfs"
             create: yes
             owner: root
             group: root
             mode: '0644'
           when: freevxfs_module_check.stdout == "exists"

         - name: "Verify freevxfs is not loaded"
           command: lsmod | grep freevxfs
           register: freevxfs_loaded
           changed_when: false
           failed_when: false

         - name: "Display freevxfs remediation status"
           debug:
             msg: "freevxfs module has been disabled and unloaded"
           when: freevxfs_module_check.stdout == "exists"


    - name: "1.1.1.3 Ensure hfs kernel module is not available (Automated)"
      block:
         - name: "Check if hfs module exists"
           shell: |
             l_mod_name="hfs"
             l_mod_type="fs"
             for l_mod_path in $(readlink -e /usr/lib/modules/**/kernel/$l_mod_type 2>/dev/null || readlink -e /lib/modules/**/kernel/$l_mod_type 2>/dev/null); do
               if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}" 2>/dev/null)" ]; then
                 echo "exists"
               fi
             done
           register: hfs_module_check
           changed_when: false
           failed_when: false

         - name: "Unload hfs kernel module"
           community.general.modprobe:
             name: hfs
             state: absent
           when: hfs_module_check.stdout == "exists"
           failed_when: false

         - name: "Disable hfs kernel module - install"
           lineinfile:
             path: /etc/modprobe.d/60-hfs.conf
             line: "install hfs /bin/false"
             create: yes
             owner: root
             group: root
             mode: '0644'
           when: hfs_module_check.stdout == "exists"

         - name: "Disable hfs kernel module - blacklist"
           lineinfile:
             path: /etc/modprobe.d/60-hfs.conf
             line: "blacklist hfs"
             create: yes
             owner: root
             group: root
             mode: '0644'
           when: hfs_module_check.stdout == "exists"

         - name: "Verify hfs is not loaded"
           command: lsmod | grep hfs
           register: hfs_loaded
           changed_when: false
           failed_when: false

         - name: "Display hfs remediation status"
           debug:
             msg: "hfs module has been disabled and unloaded"
           when: hfs_module_check.stdout == "exists"

    - name: "1.1.1.4 Ensure hfsplus kernel module is not available (Automated)"
      block:
         - name: "Check if hfsplus module exists"
           shell: |
             l_mod_name="hfsplus"
             l_mod_type="fs"
             for l_mod_path in $(readlink -e /usr/lib/modules/**/kernel/$l_mod_type 2>/dev/null || readlink -e /lib/modules/**/kernel/$l_mod_type 2>/dev/null); do
               if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}" 2>/dev/null)" ]; then
                 echo "exists"
               fi
             done
           register: hfsplus_module_check
           changed_when: false
           failed_when: false

         - name: "Unload hfsplus kernel module"
           community.general.modprobe:
             name: hfsplus
             state: absent
           when: hfsplus_module_check.stdout == "exists"
           failed_when: false

         - name: "Disable hfsplus kernel module - install"
           lineinfile:
             path: /etc/modprobe.d/60-hfsplus.conf
             line: "install hfsplus /bin/false"
             create: yes
             owner: root
             group: root
             mode: '0644'
           when: hfsplus_module_check.stdout == "exists"

         - name: "Disable hfsplus kernel module - blacklist"
           lineinfile:
             path: /etc/modprobe.d/60-hfsplus.conf
             line: "blacklist hfsplus"
             create: yes
             owner: root
             group: root
             mode: '0644'
           when: hfsplus_module_check.stdout == "exists"

         - name: "Verify hfsplus is not loaded"
           command: lsmod | grep hfsplus
           register: hfsplus_loaded
           changed_when: false
           failed_when: false

         - name: "Display hfsplus remediation status"
           debug:
             msg: "hfsplus module has been disabled and unloaded"
           when: hfsplus_module_check.stdout == "exists"

    - name: "1.1.1.5 Ensure jffs2 kernel module is not available (Automated)"
      block:
         - name: "Check if jffs2 module exists"
           shell: |
             l_mod_name="jffs2"
             l_mod_type="fs"
             for l_mod_path in $(readlink -e /usr/lib/modules/**/kernel/$l_mod_type 2>/dev/null || readlink -e /lib/modules/**/kernel/$l_mod_type 2>/dev/null); do
               if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}" 2>/dev/null)" ]; then
                 echo "exists"
               fi
             done
           register: jffs2_module_check
           changed_when: false
           failed_when: false

         - name: "Unload jffs2 kernel module"
           community.general.modprobe:
             name: jffs2
             state: absent
           when: jffs2_module_check.stdout == "exists"
           failed_when: false

         - name: "Disable jffs2 kernel module - install"
           lineinfile:
             path: /etc/modprobe.d/60-jffs2.conf
             line: "install jffs2 /bin/false"
             create: yes
             owner: root
             group: root
             mode: '0644'
           when: jffs2_module_check.stdout == "exists"

         - name: "Disable jffs2 kernel module - blacklist"
           lineinfile:
             path: /etc/modprobe.d/60-jffs2.conf
             line: "blacklist jffs2"
             create: yes
             owner: root
             group: root
             mode: '0644'
           when: jffs2_module_check.stdout == "exists"

         - name: "Verify jffs2 is not loaded"
           command: lsmod | grep jffs2
           register: jffs2_loaded
           changed_when: false
           failed_when: false

         - name: "Display jffs2 remediation status"
           debug:
             msg: "jffs2 module has been disabled and unloaded"
           when: jffs2_module_check.stdout == "exists"



    - name: "1.1.1.6 - Ensure overlay kernel module is not available"
      block:  
        - name: "WARNING - Check for container runtime services"
          debug:
            msg: | 
              WARNING Disabling overlay module may severely disrupt containerization.
              this control is level 2 and should only be applied if
              podman, LXC or other container services are not in use 
          when: ansible_facts.services is defined

        - name: "Check if overlay module exists"
          shell: | 
            l_mod_name="overlayfs"
            l_mod_type="fs"
            for l_mod_path in $(readlink -e /usr/lib/modules/**/kernel/$l_mod_type 2>/dev/null || readlink -e /lib/modules/**/kernel/$l_mod_type 2>/dev/null); do
              if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}" 2>/dev/null)" ]; then
                echo "exists"
              fi
            done
          register: overlay_module_check
          changed_when: false
          failed_when: false

        - name: "Check for active container services"
          shell: |
            systemctl is-active docker 2>/dev/null || \
            systemctl is-active containerd 2>/dev/null || \
            systemctl is-active podman 2>/dev/null || \
            systemctl is-active lxc 2>/dev/null || \
              echo "none"
          register: container_services
          changed_when: false
          failed_when: false

        - name: "Display container warning if services detected"
          debug:
            msg: | 
              CRITICAL WARNING: Container services detected ({{ container_services.stdout }}).
              Disabling overlay module will break containerization.
              Skipping remediation for safety.
          when: 
            - container_services.stdout != "none"
            - overlay_module_check.stdout == "exists"

        - name: "Unload overlay kernel module"
          community.general.modprobe:
            name: overlay
            state: absent
          when: 
            - overlay_module_check.stdout == "exists"
            - container_services.stdout == "none"
          failed_when: false

        - name: "Disable overlay kernel module - install"
          lineinfile:
            path: /etc/modprobe.d/60-overlay.conf
            line: "install overlay /bin/false"
            create: yes
            owner: root
            group: root
            mode: '0644'
          when: 
            - overlay_module_check.stdout == "exists"
            - container_services.stdout == "none"

        - name: "Disable overlay kernel module - blacklist"
          lineinfile:
            path: /etc/modprobe.d/60-overlay.conf
            line: "blacklist overlay"
            create: yes
            owner: root
            group: root
            mode: '0644'
          when: 
            - overlay_module_check.stdout == "exists"
            - container_services.stdout == "none"

        - name: "Verify overlay is not loaded"
          command: lsmod | grep overlay
          register: overlay_loaded
          changed_when: false
          failed_when: false
          when: container_services.stdout == "none"

        - name: "Display overlay remediation status"
          debug:
            msg: "overlay module has been disabled and unloaded"
          when: 
            - overlay_module_check.stdout == "exists"
            - container_services.stdout == "none"

    - name: "1.1.1.7 - Ensure squashfs kernel module is not available (Automated)"
      block:
        - name: "WARNING - Check for snap packages"
          debug:
            msg: |
              WARNING: Disabling squashfs will cause Snap packages to fail.
               This control is Level 2 and should only be applied if Snap packages are NOT in use.
               Snap packages utilize squashfs as a compressed filesystem.

        - name: "Check if squashfs module exists"
          shell: |
            l_mod_name="squashfs"
            l_mod_type="fs"
            for l_mod_path in $(readlink -e /usr/lib/modules/**/kernel/$l_mod_type 2>/dev/null || readlink -e /lib/modules/**/kernel/$l_mod_type 2>/dev/null); do
              if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}" 2>/dev/null)" ]; then
                echo "exists"
              fi
            done
          register: squashfs_module_check
          changed_when: false
          failed_when: false

        - name: "Check for snap packages installed"
          shell: snap list 2>/dev/null | wc -l
          register: snap_packages
          changed_when: false
          failed_when: false

        - name: "Display snap warning if packages detected"
          debug: 
            msg: |
              WARNING: {{ snap_packages.stdout }} Snap packages detected.
              Disabling squashfs will break all Snap applications.
              Skipping remediation for safety.
          when:
            - snap_packages.stdout is defined
            - snap_packages.stdout | int > 1
            - squashfs_module_check.stdout == "exists"

        - name: "Unload squashfs kernel module"
          community.general.modprobe:
            name: squashfs
            state: absent
          when:
            - squashfs_module_check.stdout == "exists"
            - snap_packages.stdout | default('0') | int <= 1
          failed_when: false

        - name: "Disable squashfs kernel module - install"
          lineinfile:
            path: /etc/modprobe.d/60-squashfs.conf
            line: "install squashfs /bin/false"
            create: yes
            owner: root
            group: root
            mode: '0644'
          when:
            - squashfs_module_check.stdout == "exists"
            - snap_packages.stdout | default('0') | int <= 1

        - name: "Disable squashfs kernel module - blacklist"
          lineinfile:
            path: /etc/modprobe.d/60-squashfs.conf
            line: "blacklist squashfs"
            create: yes
            owner: root 
            group: root
            mode: '0644'
          when:
            - squashfs_module_check.stdout == "exists"
            - snap_packages.stdout | default('0') | int <= 1

        - name: "Verify squashfs is not loaded"
          command: lsmod | grep squashfs
          register: squashfs_loaded
          changed_when: false
          failed_when: false
          when: snap_packages.stdout | default('0') | int <= 1

        - name: "Display squashfs remediation status"
          debug: 
            msg: "squashfs module has been disabled and unloaded"
          when:
            - squashfs_module_check.stdout == "exists"
            - snap_packages.stdout | default('0') | int <= 1


    - name: "1.1.1.8 - Ensure udf kernel module is not available"
      block:
        - name: "WARNING - Check for Microsoft Azure"
          debug:
            msg: |
              WARNING: Microsoft Azure requires the usage of udf.
              udf should NOT be disabled on systems running on Microsoft Azure.
              This control is Level 2 - Server and Level 2 - Workstation.
              UDF filesystem is necessary to support writing DVDs and newer optical disc formats.

        - name: "Check if running on Azure"
          shell: |
            if [ -f /sys/class/dmi/id/sys_vendor ]; then
              grep -i "Microsoft Corporation" /sys/class/dmi/id/sys_vendor 2>/dev/null && echo "azure" || echo "not_azure"
            else
              echo "not_azure"
            fi
          register: azure_check
          changed_when: false 
          failed_when: false

        - name: "Check if udf module exists"
          shell:  |
            l_mod_name="udf"
            l_mod_type="fs"
            for l_mod_path in $(readlink -e /usr/lib/modules/**/kernel/$l_mod_type 2>/dev/null || readlink -e /lib/modules/**/kernel/$l_mod_type 2>/dev/null); do
              if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}" 2>/dev/null)" ]; then
                echo "exists"
              fi
            done
          register: udf_module_check
          changed_when: false
          failed_when: false

        - name: "Display Azure warning if detected"
          debug:
            msg: |
              CRITICAL WARNING: Microsoft Azure environment detected.
              Disabling udf module will break Azure functionality.
              Skipping remediation for safety.
          when: 
            - azure_check.stdout == "azure"
            - udf_module_check.stdout == "exists"

        - name: "Unload udf kernel module"
          community.general.modprobe:
            name: udf
            state: absent
          when: 
            - udf_module_check.stdout == "exists"
            - azure_check.stdout != "azure"
          failed_when: false

        - name: "Disable udf kernel module - install"
          lineinfile:
            path: /etc/modprobe.d/60-udf.conf
            line: "install udf /bin/false"
            create: yes
            owner: root
            group: root
            mode: '0644'
          when: 
            - udf_module_check.stdout == "exists"
            - azure_check.stdout != "azure"

        - name: "Disable udf kernel module - blacklist"
          lineinfile:
            path: /etc/modprobe.d/60-udf.conf
            line: "blacklist udf"
            create: yes
            owner: root
            group: root
            mode: '0644'
          when: 
            - udf_module_check.stdout == "exists"
            - azure_check.stdout != "azure"

        - name: "Verify udf is not loaded"
          command: lsmod | grep udf
          register: udf_loaded
          changed_when: false
          failed_when: false
          when: azure_check.stdout != "azure"

        - name: "Display udf remediation status"
          debug:
            msg: "udf module has been disabled and unloaded"
          when: 
            - udf_module_check.stdout == "exists"
            - azure_check.stdout != "azure"
        
       
    - name: "1.1.1.11 Ensure unused filesystems kernel modules are not available (Manual)"
      block:
         - name: "CRITICAL WARNING - Manual review required"
           debug:
             msg: |
               CRITICAL WARNING: This is a MANUAL control requiring careful review.
               Disabling or denylisting filesystem modules IN USE may be FATAL.
               
               Known CVE-affected filesystem modules:
               - ceph: CVE-2022-0670
               - cifs: CVE-2022-29869
               - exfat: CVE-2022-29973
               - ext: CVE-2022-1184
               - fat: CVE-2022-22043
               - fscache: CVE-2022-3630
               - fuse: CVE-2023-0386
               - gfs2: CVE-2023-3212
               - nfs_common: CVE-2023-6660
               - nfsd: CVE-2022-43945
               - smbfs_common: CVE-2022-2585
               
               Review is MANDATORY before applying any changes.

         - name: "Get currently mounted filesystem types"
           shell: findmnt -Dkerno fstype | sort -u
           register: mounted_filesystems
           changed_when: false
           failed_when: false

         - name: "Get currently loaded kernel modules"
           shell: lsmod | awk '{print $1}'
           register: loaded_modules
           changed_when: false
           failed_when: false

         - name: "Get available filesystem kernel modules"
           shell: |
             #!/usr/bin/env bash
             {
               l_search="$(readlink -e /usr/lib/modules/ || readlink -e /lib/modules/)"
               a_module=() 
               while IFS= read -r -d $'\0' l_module_dir; do
                 if [ ! "$(basename "$l_module_dir")" = "nls" ]; then
                   while IFS= read -r -d $'\0' l_module_file; do
                     l_mname="$(basename "$l_module_file" | cut -d'.' -f1)"
                     if [ -f "$l_module_file" ] && ! grep -Psiq -- '\b'"$l_mname"'\b' <<< "${a_module[*]}"; then
                       a_module+=("$l_mname")
                     fi
                   done < <(find -L "$l_module_dir" -mindepth 1 -maxdepth 1 -type f -print0)
                 fi
               done < <(find "$l_search"/**/kernel/fs/ -mindepth 1 -maxdepth 1 -type d ! -empty -print0)
               printf '%s\n' "${a_module[@]}"
             }
           register: available_fs_modules
           changed_when: false
           failed_when: false

         - name: "Get current modprobe configuration"
           shell: modprobe --showconfig | grep -Pi -- '^\h*(blacklist|install)\h+'
           register: modprobe_config
           changed_when: false
           failed_when: false

         - name: "Run comprehensive filesystem modules audit"
           shell: |
             #!/usr/bin/env bash
             {
               a_check=() a_output=() a_module=() a_output2=() a_output3=()
               l_search="$(readlink -e /usr/lib/modules/ || readlink -e /lib/modules/)"
               IFS=$'\n' read -r -d '' -a a_mounted < <(findmnt -Dkerno fstype | sort -u && printf '\0' )
               IFS=$'\n' read -r -d '' -a a_lsmod < <(lsmod | awk '{print $1}' && printf '\0' )
               IFS=$'\n' read -r -d '' -a a_showconfig < <(modprobe --showconfig | grep -Pi -- '^\h*(blacklist|install)\h+' && printf '\0')
               
               while IFS= read -r -d $'\0' l_module_dir; do
                 if [ ! "$(basename "$l_module_dir")" = "nls" ]; then
                   while IFS= read -r -d $'\0' l_module_file; do
                     l_mname="$(basename "$l_module_file" | cut -d'.' -f1)"
                     if [ -f "$l_module_file" ] && ! grep -Psiq -- '\b'"$l_mname"'\b' <<< "${a_module[*]}"; then
                       a_module+=("$l_mname")
                     fi
                   done < <(find -L "$l_module_dir" -mindepth 1 -maxdepth 1 -type f -print0)
                 fi
               done < <(find "$l_search"/**/kernel/fs/ -mindepth 1 -maxdepth 1 -type d ! -empty -print0)
               
               for l_module in "${a_module[@]}"; do
                 if grep -Psoiq -- '\b'"$l_module"'\b' <<< "${a_mounted[*]}"; then
                   a_output+=("MOUNTED:$l_module")
                 elif grep -Psoiq -- '\b'"$l_module"'\b' <<< "${a_lsmod[*]}"; then
                   a_output2+=("LOADED:$l_module")
                 elif ! grep -Psioq -- '\binstall\h+'"${l_module//-/_}"'\h+\H+\b' <<< "${a_showconfig[*]}" || \
                      ! grep -Psioq -- '\bblacklist\h+'"${l_module//-/_}"'\b' <<< "${a_showconfig[*]}"; then
                   a_output3+=("LOADABLE:$l_module")
                 fi
               done
               
               printf '%s\n' "${a_output[@]}" "${a_output2[@]}" "${a_output3[@]}"
             }
           register: fs_audit_result
           changed_when: false
           failed_when: false

         - name: "Display filesystem modules audit results"
           debug:
             msg: |
               ========== FILESYSTEM MODULES AUDIT ==========
               
               Currently Mounted Filesystems:
               {{ mounted_filesystems.stdout_lines | join('\n') }}
               
               Filesystem Modules Status:
               {{ fs_audit_result.stdout_lines | join('\n') }}
               
               ========== MANUAL ACTION REQUIRED ==========
               1. Review the above list carefully
               2. Identify modules that are NOT needed
               3. Ensure modules are NOT currently in use
               4. Apply remediation only to unused modules
               
               WARNING: Do NOT disable modules that are mounted or in use!

         - name: "Create manual remediation documentation"
           copy:
             dest: /root/CIS_1.1.1.11_filesystem_modules_review.txt
             content: |
               CIS Control 1.1.1.11 - Unused Filesystem Kernel Modules Review
               Generated: {{ ansible_date_time.iso8601 }}
               
               ========================================
               MANUAL REVIEW REQUIRED
               ========================================
               
               Currently Mounted Filesystems:
               {{ mounted_filesystems.stdout }}
               
               Filesystem Modules Audit:
               {{ fs_audit_result.stdout }}
               
               ========================================
               KNOWN CVE-AFFECTED FILESYSTEMS
               ========================================
               - ceph: CVE-2022-0670
               - cifs: CVE-2022-29869
               - exfat: CVE-2022-29973
               - ext: CVE-2022-1184
               - fat: CVE-2022-22043
               - fscache: CVE-2022-3630
               - fuse: CVE-2023-0386
               - gfs2: CVE-2023-3212
               - nfs_common: CVE-2023-6660
               - nfsd: CVE-2022-43945
               - smbfs_common: CVE-2022-2585
               
               ========================================
               REMEDIATION PROCEDURE (EXAMPLE: gfs2)
               ========================================
               
               1. Verify module is NOT in use:
                  # lsmod | grep gfs2
                  # findmnt -t gfs2
               
               2. Unload the module:
                  # modprobe -r gfs2 2>/dev/null
                  # rmmod gfs2 2>/dev/null
               
               3. Disable the module:
                  # printf '%s\n' "" "install gfs2 /bin/false" >> /etc/modprobe.d/60-gfs2.conf
                  # printf '%s\n' "" "blacklist gfs2" >> /etc/modprobe.d/60-gfs2.conf
               
               4. Verify configuration:
                  # modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+gfs2\b'
               
               ========================================
               AUTOMATED REMEDIATION SCRIPT TEMPLATE
               ========================================
               
               #!/usr/bin/env bash
               {
                 l_mod_name="<MODULE_NAME>"  # Replace with actual module name
                 l_mod_type="fs"
                 l_mod_path="$(readlink -f /usr/lib/modules/**/kernel/$l_mod_type || readlink -f /lib/modules/**/kernel/$l_mod_type)"
                 
                 # Unload module if loaded
                 if lsmod | grep "$l_mod_name" &> /dev/null; then
                   echo "Unloading $l_mod_name..."
                   modprobe -r "$l_mod_name" 2>/dev/null
                   rmmod "$l_mod_name" 2>/dev/null
                 fi
                 
                 # Create configuration file
                 printf '%s\n' "install $l_mod_name /bin/false" >> /etc/modprobe.d/60-"$l_mod_name".conf
                 printf '%s\n' "blacklist $l_mod_name" >> /etc/modprobe.d/60-"$l_mod_name".conf
                 
                 echo "Module $l_mod_name has been disabled"
               }
               
               ========================================
               IMPORTANT WARNINGS
               ========================================
               - NEVER disable modules that are currently mounted
               - NEVER disable modules that are currently loaded and in use
               - Review local site policy before disabling any module
               - Test changes in non-production environment first
               - Document all changes made
               - Keep backups of modprobe.d configurations
               
               Reference: https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=filesystem
             owner: root
             group: root
             mode: '0600'

    - name: "1.1.2.1.1 Ensure /tmp is tmpfs or a separate partition (Automated)"
      block:
         - name: "Check if /tmp is mounted"
           shell: findmnt -kn /tmp
           register: tmp_mount_check
           changed_when: false
           failed_when: false

         - name: "Check tmp.mount systemd unit status"
           systemd:
             name: tmp.mount
           register: tmp_mount_status
           failed_when: false

         - name: "Display /tmp mount information"
           debug:
             msg: |
               Current /tmp mount status:
               {{ tmp_mount_check.stdout if tmp_mount_check.stdout else 'Not mounted as separate partition' }}
               
               tmp.mount systemd status: {{ tmp_mount_status.status.ActiveState | default('unknown') }}

         - name: "Unmask tmp.mount systemd unit"
           systemd:
             name: tmp.mount
             masked: no
           when: tmp_mount_status.status.UnitFileState | default('') == 'masked'

         - name: "Check if /tmp entry exists in /etc/fstab"
           shell: grep -E '^\s*[^#].*\s+/tmp\s+' /etc/fstab
           register: tmp_fstab_check
           changed_when: false
           failed_when: false

         - name: "Configure /tmp in /etc/fstab if not present"
           lineinfile:
             path: /etc/fstab
             line: "tmpfs /tmp tmpfs defaults,rw,nosuid,nodev,noexec,relatime,size=2G 0 0"
             regexp: '^\s*tmpfs\s+/tmp\s+'
             create: yes
             state: present
           when: 
             - tmp_fstab_check.rc != 0
             - tmp_mount_check.stdout == ''

         - name: "Enable and start tmp.mount"
           systemd:
             name: tmp.mount
             enabled: yes
             state: started
           when: tmp_mount_check.stdout == ''

         - name: "Verify /tmp is mounted"
           shell: findmnt -kn /tmp
           register: tmp_mount_verify
           changed_when: false
           failed_when: tmp_mount_verify.rc != 0

         - name: "Display /tmp configuration status"
           debug:
            msg: |
              Control 1.1.2.1.1 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /tmp mount status: {{ tmp_mount_verify.stdout }}
              - systemd tmp.mount: {{ 'enabled' if tmp_mount_status.status.UnitFileState | default('') == 'enabled' or tmp_mount_status.status.UnitFileState | default('') == 'generated' else 'configured' }}
              - Configuration: {{ 'tmpfs' if 'tmpfs' in tmp_mount_verify.stdout else 'separate partition' }}
              - STIG IDs: RHEL-08-010543, RHEL-09-231015, ALMA-09-025540
              
              Impact Note: Files in /tmp will not survive reboot when using tmpfs.
              Use /var/tmp for persistent temporary files.

    - name: "1.1.2.1.2 Ensure nodev option set on /tmp partition (Automated)"
      block:
         - name: "Check if /tmp partition exists"
           shell: findmnt -kn /tmp
           register: tmp_partition_check
           changed_when: false
           failed_when: false

         - name: "Verify nodev option on /tmp"
           shell: findmnt -kn /tmp | grep -v nodev
           register: tmp_nodev_check
           changed_when: false
           failed_when: false

         - name: "Update /etc/fstab with nodev option for /tmp"
           replace:
             path: /etc/fstab
             regexp: '^(\s*\S+\s+/tmp\s+\S+\s+)(?!.*nodev)(.*)$'
             replace: '\1nodev,\2'
           when: 
             - tmp_partition_check.rc == 0
             - tmp_nodev_check.stdout != ''
           notify: remount_tmp

         - name: "Verify nodev is set on /tmp"
           shell: findmnt -kn /tmp | grep nodev
           register: tmp_nodev_verify
           changed_when: false
           failed_when: false
           when: tmp_partition_check.rc == 0

         - name: "Display nodev status for /tmp"
           debug:
             msg: |
               Control 1.1.2.1.2 Status:
               - Profile Level: Level 1 (Server/Workstation)
               - /tmp partition exists: {{ 'Yes' if tmp_partition_check.rc == 0 else 'No' }}
               - nodev option set: {{ 'Yes' if tmp_nodev_verify.rc == 0 else 'Needs configuration' }}
               - Purpose: Prevent creation of block/character special devices in /tmp
               - STIG IDs: RHEL-08-040123, RHEL-09-231125, ALMA-09-026860
           when: tmp_partition_check.rc == 0

    - name: "1.1.2.1.3 Ensure nosuid option set on /tmp partition (Automated)"
      block:
         - name: "Check if /tmp partition exists"
           shell: findmnt -kn /tmp
           register: tmp_partition_check_suid
           changed_when: false
           failed_when: false

         - name: "Verify nosuid option on /tmp"
           shell: findmnt -kn /tmp | grep -v nosuid
           register: tmp_nosuid_check
           changed_when: false
           failed_when: false

         - name: "Update /etc/fstab with nosuid option for /tmp"
           replace:
             path: /etc/fstab
             regexp: '^(\s*\S+\s+/tmp\s+\S+\s+)(?!.*nosuid)(.*)$'
             replace: '\1nosuid,\2'
           when: 
             - tmp_partition_check_suid.rc == 0
             - tmp_nosuid_check.stdout != ''
           notify: remount_tmp

         - name: "Verify nosuid is set on /tmp"
           shell: findmnt -kn /tmp | grep nosuid
           register: tmp_nosuid_verify
           changed_when: false
           failed_when: false
           when: tmp_partition_check_suid.rc == 0

         - name: "Display nosuid status for /tmp"
           debug:
             msg: |
               Control 1.1.2.1.3 Status:
               - Profile Level: Level 1 (Server/Workstation)
               - /tmp partition exists: {{ 'Yes' if tmp_partition_check_suid.rc == 0 else 'No' }}
               - nosuid option set: {{ 'Yes' if tmp_nosuid_verify.rc == 0 else 'Needs configuration' }}
               - Purpose: Prevent users from creating setuid files in /tmp
               - STIG IDs: RHEL-08-040124, RHEL-09-231135, ALMA-09-027080
           when: tmp_partition_check_suid.rc == 0

    - name: "1.1.2.1.4 Ensure noexec option set on /tmp partition (Automated)"
      block:
         - name: "WARNING - noexec impact notice"
           debug:
             msg: |
               WARNING: Setting noexec on /tmp may prevent installation/updating of some 3rd party software.
               This control prevents execution of binaries from /tmp for security.

         - name: "Check if /tmp partition exists"
           shell: findmnt -kn /tmp
           register: tmp_partition_check_exec
           changed_when: false
           failed_when: false

         - name: "Verify noexec option on /tmp"
           shell: findmnt -kn /tmp | grep -v noexec
           register: tmp_noexec_check
           changed_when: false
           failed_when: false

         - name: "Update /etc/fstab with noexec option for /tmp"
           replace:
             path: /etc/fstab
             regexp: '^(\s*\S+\s+/tmp\s+\S+\s+)(?!.*noexec)(.*)$'
             replace: '\1noexec,\2'
           when: 
             - tmp_partition_check_exec.rc == 0
             - tmp_noexec_check.stdout != ''
           notify: remount_tmp

         - name: "Verify noexec is set on /tmp"
           shell: findmnt -kn /tmp | grep noexec
           register: tmp_noexec_verify
           changed_when: false
           failed_when: false
           when: tmp_partition_check_exec.rc == 0

         - name: "Display noexec status for /tmp"
           debug:
             msg: |
               Control 1.1.2.1.4 Status:
               - Profile Level: Level 1 (Server/Workstation)
               - /tmp partition exists: {{ 'Yes' if tmp_partition_check_exec.rc == 0 else 'No' }}
               - noexec option set: {{ 'Yes' if tmp_noexec_verify.rc == 0 else 'Needs configuration' }}
               - Purpose: Prevent execution of binaries from /tmp
               - Impact: May affect some 3rd party software installations
               - STIG IDs: RHEL-08-040125, RHEL-09-231130, ALMA-09-026970
           when: tmp_partition_check_exec.rc == 0

         - name: "Document /tmp configuration"
           copy:
             dest: /root/CIS_1.1.2.1_tmp_configuration.txt
             content: |
               CIS Controls 1.1.2.1.1-4 - /tmp Partition Configuration
               Generated: {{ ansible_date_time.iso8601 }}
               
               ========================================
               /tmp PARTITION STATUS
               ========================================
               
               Current Mount: {{ tmp_partition_check_exec.stdout }}
               
               Mount Options Status:
               - nodev:  {{ 'PASS' if tmp_nodev_verify.rc == 0 else 'FAIL' }}
               - nosuid: {{ 'PASS' if tmp_nosuid_verify.rc == 0 else 'FAIL' }}
               - noexec: {{ 'PASS' if tmp_noexec_verify.rc == 0 else 'FAIL' }}
               
               ========================================
               CONFIGURATION DETAILS
               ========================================
               
               Recommended /etc/fstab entry:
               tmpfs /tmp tmpfs defaults,rw,nosuid,nodev,noexec,relatime,size=2G 0 0
               
               OR for separate partition:
               <device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
               
               ========================================
               IMPORTANT NOTES
               ========================================
               
               tmpfs Configuration:
               - Files in /tmp will NOT survive reboot
               - Use /var/tmp for persistent temporary files
               - Default size is 50% of RAM if not specified
               - Can be resized with: mount -o remount,size=4G /tmp
               
               Mount Options Explained:
               - nodev:  Prevents creation of device files
               - nosuid: Prevents setuid bit from taking effect
               - noexec: Prevents execution of binaries
               
               Impact:
               - noexec may affect some 3rd party software installations
               - Test in non-production before deploying
               
               ========================================
               REFERENCES
               ========================================
               - CCI-001764, CCI-000366
               - NIST SP 800-53: CM-7(2), CM-6b
               - STIG IDs: RHEL-08-010543, RHEL-09-231015, ALMA-09-025540
               - https://www.freedesktop.org/wiki/Software/systemd/APIFileSystems/
               - https://www.kernel.org/doc/Documentation/filesystems/tmpfs.txt
             owner: root
             group: root
             mode: '0600'
           when: tmp_partition_check_exec.rc == 0


    - name: "1.1.2.2.1 Ensure /dev/shm is tmpfs (Automated)"
      block:
        - name: "Check if /dev/shm is mounted"
          shell: findmnt -kn /dev/shm
          register: shm_mount_check
          changed_when: false
          failed_when: false

        - name: "Check shm.mount systemd unit status"
          systemd:
            name: shm.mount
          register: shm_mount_status
          failed_when: false

        - name: "Display /dev/shm mount information"
          debug:
            msg: |
              Current /dev/shm mount status:
              {{ shm_mount_check.stdout if shm_mount_check.stdout else 'Not mounted as separate partition' }}
              
              shm.mount systemd status: {{ shm_mount_status.status.ActiveState | default('unknown') }}

        - name: "Unmask shm.mount systemd unit"
          systemd:
            name: shm.mount
            masked: no
          when: shm_mount_status.status.UnitFileState | default('') == 'masked'

        - name: "Check if /dev/shm entry exists in /etc/fstab"
          shell: grep -E '^\s*[^#].*\s+/dev/shm\s+' /etc/fstab
          register: shm_fstab_check
          changed_when: false
          failed_when: false

        - name: "Configure /dev/shm in /etc/fstab if not present"
          lineinfile:
            path: /etc/fstab
            line: tmpfs /dev/shm tmpfs defaults,rw,nosuid,nodev,noexec,relatime 0 0
            regexp: '^\s*tmpfs\s+/dev/shm\s+'
            create: yes
          when:
            - shm_fstab_check.rc != 0
            - shm_mount_check.stdout == ''


        - name: "Verify /dev/shm is mounted as tmpfs"
          shell: findmnt -kn /dev/shm
          register: shm_mount_verify
          changed_when: false
          failed_when: false


        - name: "Verify tmpfs filesystem type"
          shell: findmnt -kn /dev/shm -o FSTYPE
          register: shm_fstype_check
          changed_when: false
          failed_when: false

      
        - name: "Display /dev/shm configuration status"
          debug:
            msg: |
              Control 1.1.2.2.1 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Mount point: /dev/shm
              - Filesystem: {{ shm_fstype_check.stdout }}
              - Full mount info: {{ shm_mount_verify.stdout }}
              - Status: {{ 'PASS - Configured as tmpfs' if shm_fstype_check.stdout == 'tmpfs' else 'FAIL - Not configured correctly' }}
               Purpose: Shared memory IPC with security restrictions
               Impact: Prevents resource exhaustion and code execution attacks
               
               Configuration includes:
               - tmpfs: RAM-based filesystem
               - nosuid: Prevents setuid files
               - nodev: Prevents device files
               - noexec: Prevents executable binaries
               - size=2G: Limits maximum size (adjustable)

        - name: "Document /dev/shm configuration"
          copy:
            dest: /root/CIS_1.1.2.2.1_devshm_configuration.txt
            content: |
               CIS Control 1.1.2.2.1 - /dev/shm tmpfs Configuration
               Generated: {{ ansible_date_time.iso8601 }}
               
               ========================================
               /dev/shm MOUNT STATUS
               ========================================
               
               Current Mount: {{ shm_mount_verify.stdout }}
               Filesystem Type: {{ shm_fstype_check.stdout }}
               
               ========================================
               CONFIGURATION DETAILS
               ========================================
               
               Purpose of /dev/shm:
               - World-writable directory for shared memory
               - Facilitates Inter-Process Communication (IPC)
               - Used by applications for memory-mapped files
               
               Recommended /etc/fstab entry:
               tmpfs /dev/shm tmpfs defaults,rw,nosuid,nodev,noexec,relatime,size=2G 0 0
               
               ========================================
               SECURITY RATIONALE
               ========================================
               
               Why tmpfs for /dev/shm:
               1. Allows additional mount options (noexec, nosuid, nodev)
               2. Prevents attackers from installing executable code
               3. Prevents hard links to setuid programs
               4. Limits resource exhaustion with size parameter
               5. Memory-based - faster than disk
               
               Mount Options Explained:
               - tmpfs:    RAM-based temporary filesystem
               - nosuid:   Prevents setuid bit from taking effect
               - nodev:    Prevents creation of device files
               - noexec:   Prevents execution of binaries
               - relatime: Updates access time efficiently
               - size=2G:  Maximum size limit (adjustable based on needs)
               
               ========================================
               SIZING CONSIDERATIONS
               ========================================
               
               Default size: 50% of physical RAM if not specified
               
               Adjust size based on application requirements:
               - Small systems: size=1G
               - Medium systems: size=2G
               - Large systems: size=4G or more
               - Database servers: May need larger (size=8G+)
               
               To resize dynamically (temporary):
               # mount -o remount,size=4G /dev/shm
               
               To resize permanently:
               Edit /etc/fstab and change size parameter, then:
               # mount -o remount /dev/shm
               
               ========================================
               IMPACT AND CONSIDERATIONS
               ========================================
               
               Risk Prevention:
               - Resource exhaustion from unbounded growth
               - Code execution from /dev/shm
               - Privilege escalation via setuid files
               
               Application Compatibility:
               - Most applications work fine with these restrictions
               - Some database systems use /dev/shm heavily
               - Monitor usage: df -h /dev/shm
               
               ========================================
               MONITORING
               ========================================
               
               Check current usage:
               # df -h /dev/shm
               # du -sh /dev/shm/*
               
               Check what's using it:
               # lsof /dev/shm
               # fuser -v /dev/shm
               
               Monitor over time:
               # watch -n 5 'df -h /dev/shm'
               
               ========================================
               VERIFICATION COMMANDS
               ========================================
               
               Verify mount and options:
               # findmnt -kn /dev/shm
               
               Expected output:
               /dev/shm tmpfs tmpfs rw,nosuid,nodev,noexec,relatime,seclabel
               
               Verify in /etc/fstab:
               # grep /dev/shm /etc/fstab
               
               Check current size and usage:
               # df -h /dev/shm
               
               ========================================
               REFERENCES
               ========================================
               - NIST SP 800-53 Rev. 5: CM-7
               - CIS Controls v8: 3.3 Configure Data Access Control Lists
               - CIS Controls v7: 14.6 Protect Information through Access Control Lists
               ========================================
               TROUBLESHOOTING
               ========================================
               
               If applications fail after applying noexec:
               1. Check application logs
               2. Verify application doesn't execute from /dev/shm
               3. Consider alternative application configuration
               4. Contact application vendor for guidance
               
               If size is insufficient:
               1. Monitor actual usage over time
               2. Increase size parameter incrementally
               3. Balance between security and functionality
               4. Document size requirements
               
               Common issues:
               - PostgreSQL may need larger /dev/shm
               - Oracle databases often use /dev/shm extensively
               - Some Java applications use it for memory mapping
            owner: root
            group: root
            mode: '0600'

        - name: "Check /dev/shm mount options compliance"
          shell: |
            findmnt -kn /dev/shm | grep -q 'nosuid' && \
            findmnt -kn /dev/shm | grep -q 'nodev' && \
            findmnt -kn /dev/shm | grep -q 'noexec' && \
            echo "COMPLIANT" || echo "NON-COMPLIANT"
          register: shm_options_check
          changed_when: false
          failed_when: false

        - name: "Final compliance status"
          debug:
            msg: |
              ==========================================
              CIS 1.1.2.2.1 COMPLIANCE STATUS
              ==========================================
              
              Filesystem Type: {{ 'PASS' if shm_fstype_check.stdout == 'tmpfs' else 'FAIL' }}
              Mount Options: {{ shm_options_check.stdout }}
              
              Full Configuration: {{ shm_mount_verify.stdout }}
               
               Documentation: /root/CIS_1.1.2.2.1_devshm_configuration.txt
               
               Next Steps:
               - Review mount options in ensuing sections (1.1.2.2.2-4)
               - Monitor /dev/shm usage regularly
               - Adjust size parameter if needed based on application requirements

    - name: "1.1.2.2.2 Ensure nodev option set on /dev/shm partition (Automated)"
      block:
        - name: "Check if /dev/shm partition exists"
          shell: findmnt -kn /dev/shm
          register: shm_partition_check
          changed_when: false
          failed_when: false

        - name: "Verify nodev option on /dev/shm"
          shell: findmnt -kn /dev/shm | grep -v nodev
          register: shm_nodev_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with nodev option for /dev/shm"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/dev/shm\s+\S+\s+)(?!.*nodev)(.*)$'
            replace: '\1nodev,\2'
          when:
            - shm_partition_check.rc == 0
            - shm_nodev_check.stdout != ''
          notify: remount_shm

        - name: "Verify nodev is set on /dev/shm"
          shell: findmnt -kn /dev/shm | grep nodev
          register: shm_nodev_verify
          changed_when: false
          failed_when: false
          when: shm_partition_check.rc == 0

        - name: "Display nodev status for /dev/shm"
          debug:
            msg: |
              Control 1.1.2.2.2 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /dev/shm partition exists: {{ 'Yes' if shm_partition_check.rc == 0 else 'No' }}
              - nodev option set: {{ 'Yes' if shm_nodev_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent creation of special devices in /dev/shm
              - STIG IDs: RHEL-08-040120, RHEL-09-231110, ALMA-09-026530
          when: shm_partition_check.rc == 0

    - name: "1.1.2.2.3 Ensure nosuid option set on /dev/shm partition (Automated)"
      block:
        - name: "Check if /dev/shm partition exists"
          shell: findmnt -kn /dev/shm
          register: shm_partition_check_suid
          changed_when: false
          failed_when: false

        - name: "Verify nosuid option on /dev/shm"
          shell: findmnt -kn /dev/shm | grep -v nosuid
          register: shm_nosuid_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with nosuid option for /dev/shm"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/dev/shm\s+\S+\s+)(?!.*nosuid)(.*)$'
            replace: '\1nosuid,\2'
          when:
            - shm_partition_check_suid.rc == 0
            - shm_nosuid_check.stdout != ''
          notify: remount_shm

        - name: "Verify nosuid is set on /dev/shm"
          shell: findmnt -kn /dev/shm | grep nosuid
          register: shm_nosuid_verify
          changed_when: false
          failed_when: false
          when: shm_partition_check_suid.rc == 0

        - name: "Display nosuid status for /dev/shm"
          debug:
            msg: |
              Control 1.1.2.2.3 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /dev/shm partition exists: {{ 'Yes' if shm_partition_check_suid.rc == 0 else 'No' }}
              - nosuid option set: {{ 'Yes' if shm_nosuid_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent setuid files in /dev/shm
              - STIG IDs: RHEL-08-040121, RHEL-09-231120, ALMA-09-026750
          when: shm_partition_check_suid.rc == 0

    - name: "1.1.2.2.4 Ensure noexec option set on /dev/shm partition (Automated)"
      block:
        - name: "Check if /dev/shm partition exists"
          shell: findmnt -kn /dev/shm
          register: shm_partition_check_exec
          changed_when: false
          failed_when: false

        - name: "Verify noexec option on /dev/shm"
          shell: findmnt -kn /dev/shm | grep -v noexec
          register: shm_noexec_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with noexec option for /dev/shm"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/dev/shm\s+\S+\s+)(?!.*noexec)(.*)$'
            replace: '\1noexec,\2'
          when:
            - shm_partition_check_exec.rc == 0
            - shm_noexec_check.stdout != ''
          notify: remount_shm

        - name: "Verify noexec is set on /dev/shm"
          shell: findmnt -kn /dev/shm | grep noexec
          register: shm_noexec_verify
          changed_when: false
          failed_when: false
          when: shm_partition_check_exec.rc == 0

        - name: "Display noexec status for /dev/shm"
          debug:
            msg: |
              Control 1.1.2.2.4 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /dev/shm partition exists: {{ 'Yes' if shm_partition_check_exec.rc == 0 else 'No' }}
              - noexec option set: {{ 'Yes' if shm_noexec_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent execution of binaries from /dev/shm
              - STIG IDs: RHEL-08-040122, RHEL-09-231115, ALMA-09-026640
          when: shm_partition_check_exec.rc == 0

        - name: "Create /dev/shm comprehensive security documentation"
          copy:
            dest: /root/CIS_1.1.2.2_devshm_comprehensive.txt
            content: |
              CIS Controls 1.1.2.2.2-4 - /dev/shm Mount Options Configuration
              Generated: {{ ansible_date_time.iso8601 }}
              
              ========================================
              /dev/shm COMPREHENSIVE SECURITY STATUS
              ========================================
              
              Current Mount Configuration:
              {{ shm_mount_verify.stdout }}
              
              Mount Options Compliance:
              - nodev:  {{ 'PASS' if shm_nodev_verify.rc == 0 else 'FAIL' }}
              - nosuid: {{ 'PASS' if shm_nosuid_verify.rc == 0 else 'FAIL' }}
              - noexec: {{ 'PASS' if shm_noexec_verify.rc == 0 else 'FAIL' }}
              
              ========================================
              MOUNT OPTIONS EXPLANATION
              ========================================
              
              1. nodev (CIS 1.1.2.2.2)
                 - Prevents creation of special device files
                 - Blocks character and block device nodes in /dev/shm
                 - STIG IDs: RHEL-08-040120, RHEL-09-231110, ALMA-09-026530
              
              2. nosuid (CIS 1.1.2.2.3)
                 - Prevents setuid/setgid bits from taking effect
                 - Blocks privilege escalation via setuid programs
                 - STIG IDs: RHEL-08-040121, RHEL-09-231120, ALMA-09-026750
              
              3. noexec (CIS 1.1.2.2.4)
                 - Prevents execution of binary files
                 - Blocks malicious code execution from /dev/shm
                 - STIG IDs: RHEL-08-040122, RHEL-09-231115, ALMA-09-026640
              
              ========================================
              RECOMMENDED fstab ENTRY
              ========================================
              
              tmpfs /dev/shm tmpfs defaults,rw,nosuid,nodev,noexec,relatime,size=2G 0 0
              
              ========================================
              SECURITY RATIONALE
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              /dev/shm is a shared memory filesystem used for IPC (Inter-Process Communication).
              Restricting access prevents:
              
              1. Device File Injection:
                 Attackers cannot create device files that could interact with hardware
              
              2. Privilege Escalation:
                 Setuid programs cannot be placed or executed from /dev/shm
              
              3. Code Execution Attacks:
                 Binary files cannot be executed directly from shared memory
              
              Combined Benefits:
              - Prevents multiple attack vectors
              - Minimal performance impact
              - Standard best practice for secure systems
              
              ========================================
              VERIFICATION COMMANDS
              ========================================
              
              # Verify all options are set correctly:
              findmnt -kn /dev/shm
              
              # Expected output should contain:
              # /dev/shm tmpfs tmpfs rw,nosuid,nodev,noexec,relatime,size=2G
              
              # Check individual options:
              findmnt -kn /dev/shm | grep -q 'nosuid' && echo "nosuid: OK"
              findmnt -kn /dev/shm | grep -q 'nodev' && echo "nodev: OK"
              findmnt -kn /dev/shm | grep -q 'noexec' && echo "noexec: OK"
              
              # Verify /etc/fstab configuration:
              grep /dev/shm /etc/fstab
              
              ========================================
              REMEDIATION SUMMARY
              ========================================
              
              If any options are missing, follow these steps:
              
              1. Edit /etc/fstab:
                 # vi /etc/fstab
                 
              2. Locate the /dev/shm entry and add missing options
                 Example:
                 tmpfs /dev/shm tmpfs defaults,rw,nosuid,nodev,noexec,relatime 0 0
              
              3. Remount /dev/shm with new options:
                 # mount -o remount /dev/shm
              
              4. Verify changes took effect:
                 # findmnt -kn /dev/shm
              
              ========================================
              IMPORTANT NOTES
              ========================================
              
              Distribution-Specific Considerations:
              - Some distributions mount /dev/shm through other means
              - /dev/shm may need to be explicitly added to /etc/fstab
              - Some distributions override /etc/fstab configuration
              - Consult distribution documentation for specifics
              
              Performance Impact:
              - Minimal performance impact from these restrictions
              - IPC operations continue normally
              - Application compatibility is high
              
              Rollback Procedure (if needed):
              1. Edit /etc/fstab and remove restrictive options
              2. Run: mount -o remount /dev/shm
              3. Verify with: findmnt -kn /dev/shm
              
              ========================================
              REFERENCES
              ========================================
              
              CIS Benchmarks:
              - CCI-001764
              - NIST SP 800-53 :: CM-7 (2)
              
              STIG References:
              - RHEL-08-040120, RHEL-08-040121, RHEL-08-040122
              - RHEL-09-231110, RHEL-09-231120, RHEL-09-231115
              - ALMA-09-026530, ALMA-09-026750, ALMA-09-026640
              
              CIS Controls:
              - v8: 3.3 Configure Data Access Control Lists
              - v7: 14.6 Protect Information through Access Control Lists
            owner: root
            group: root
            mode: '0600'

    - name: "1.1.2.3.1 Ensure separate partition exists for /home (Automated)"
      block:
        - name: "Check if /home partition exists"
          shell: findmnt -kn /home
          register: home_partition_check
          changed_when: false
          failed_when: false

        - name: "Display /home partition status"
          debug:
            msg: |
              Control 1.1.2.3.1 Status:
              - Profile Level: Level 2 (Server/Workstation)
              - /home partition exists: {{ 'Yes - Compliant' if home_partition_check.rc == 0 else 'No - Requires remediation' }}
              - Current mount information: {{ home_partition_check.stdout if home_partition_check.stdout else 'Not separately mounted' }}
              - Purpose: Isolate user data and prevent resource exhaustion
              - Impact: Allows security options (noexec/nosuid/nodev) and quota management

        - name: "Important Note - /home Partition Configuration"
          debug:
            msg: |
              NOTE: This control (1.1.2.3.1) requires manual intervention during system setup.
              
              For new installations:
              - Create a custom partition setup during installation
              - Designate a separate partition for /home
              
              For existing systems:
              - Create a new partition using LVM or fdisk
              - Add entries to /etc/fstab
              - Migrate user data using proper backup/restore procedures
              
              Recommended /etc/fstab entry:
              <device> /home <fstype> defaults,rw,nosuid,nodev,relatime 0 0
              
              Procedure (in emergency mode):
              1. systemctl isolate rescue.target
              2. mv /home /home.backup
              3. mkdir /home
              4. mount /home
              5. cp -r /home.backup/* /home/
              6. systemctl default

    - name: "1.1.2.3.2 Ensure nodev option set on /home partition (Automated)"
      block:
        - name: "Check if /home partition exists"
          shell: findmnt -kn /home
          register: home_partition_check_dev
          changed_when: false
          failed_when: false

        - name: "Verify nodev option on /home"
          shell: findmnt -kn /home | grep -v nodev
          register: home_nodev_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with nodev option for /home"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/home\s+\S+\s+)(?!.*nodev)(.*)$'
            replace: '\1nodev,\2'
          when:
            - home_partition_check_dev.rc == 0
            - home_nodev_check.stdout != ''
          notify: remount_home

        - name: "Verify nodev is set on /home"
          shell: findmnt -kn /home | grep nodev
          register: home_nodev_verify
          changed_when: false
          failed_when: false
          when: home_partition_check_dev.rc == 0

        - name: "Display nodev status for /home"
          debug:
            msg: |
              Control 1.1.2.3.2 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /home partition exists: {{ 'Yes' if home_partition_check_dev.rc == 0 else 'No' }}
              - nodev option set: {{ 'Yes' if home_nodev_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent creation of block/character special devices in /home
              - Security Rationale: Users cannot create devices that could interact with hardware
          when: home_partition_check_dev.rc == 0

    - name: "1.1.2.3.3 Ensure nosuid option set on /home partition (Automated)"
      block:
        - name: "Check if /home partition exists"
          shell: findmnt -kn /home
          register: home_partition_check_suid
          changed_when: false
          failed_when: false

        - name: "Verify nosuid option on /home"
          shell: findmnt -kn /home | grep -v nosuid
          register: home_nosuid_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with nosuid option for /home"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/home\s+\S+\s+)(?!.*nosuid)(.*)$'
            replace: '\1nosuid,\2'
          when:
            - home_partition_check_suid.rc == 0
            - home_nosuid_check.stdout != ''
          notify: remount_home

        - name: "Verify nosuid is set on /home"
          shell: findmnt -kn /home | grep nosuid
          register: home_nosuid_verify
          changed_when: false
          failed_when: false
          when: home_partition_check_suid.rc == 0

        - name: "Display nosuid status for /home"
          debug:
            msg: |
              Control 1.1.2.3.3 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /home partition exists: {{ 'Yes' if home_partition_check_suid.rc == 0 else 'No' }}
              - nosuid option set: {{ 'Yes' if home_nosuid_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent setuid files in /home
              - Security Rationale: Prevents privilege escalation via setuid programs

        - name: "Create /home comprehensive security documentation"
          copy:
            dest: /root/CIS_1.1.2.3_home_configuration.txt
            content: |
              CIS Controls 1.1.2.3.1-3 - /home Partition Configuration
              Generated: {{ ansible_date_time.iso8601 }}
              
              ========================================
              /home PARTITION SECURITY CONFIGURATION
              ========================================
              
              Current Mount Status:
              {{ home_partition_check_suid.stdout if home_partition_check_suid.stdout else 'Not separately mounted' }}
              
              Configuration Status:
              - Separate partition: {{ 'Yes' if home_partition_check_suid.rc == 0 else 'No - Level 2 requirement' }}
              - nodev option: {{ 'PASS' if home_nodev_verify.rc == 0 else 'FAIL' }}
              - nosuid option: {{ 'PASS' if home_nosuid_verify.rc == 0 else 'FAIL' }}
              
              ========================================
              CONTROL DESCRIPTIONS
              ========================================
              
              1.1.2.3.1 - Separate Partition for /home
              Profile Applicability: Level 2 (Server/Workstation)
              
              Description:
              The /home directory stores user-generated data and requires separate 
              filesystem configuration to prevent resource exhaustion.
              
              Rationale:
              - Single partition systems risk disk exhaustion impacting all users
              - Separate /home allows dedicated mount options and quota management
              - Supports options like noexec/nosuid/nodev for additional security
              - Allows usrquota/grpquota to limit per-user disk impact
              
              Risks of Single Partition:
              - One user filling disk impacts entire system
              - Unrelated system operations affect user data availability
              - No ability to apply user-specific security options
              
              1.1.2.3.2 - nodev Option on /home
              Profile Applicability: Level 1 (Server/Workstation)
              
              Purpose: Prevents creation of block/character special devices
              Security Impact: Attackers cannot create device files in /home
              
              1.1.2.3.3 - nosuid Option on /home
              Profile Applicability: Level 1 (Server/Workstation)
              
              Purpose: Prevents setuid files from taking effect
              Security Impact: Blocks privilege escalation via setuid programs
              
              ========================================
              RECOMMENDED FSTAB CONFIGURATION
              ========================================
              
              Basic Configuration (with security options):
              <device> /home <fstype> defaults,rw,nosuid,nodev,relatime 0 0
              
              Example with ext4:
              /dev/sdb1 /home ext4 defaults,rw,nosuid,nodev,relatime 0 0
              
              Example with LVM:
              /dev/mapper/vg0-home /home ext4 defaults,rw,nosuid,nodev,relatime 0 0
              
              With Quota Support (optional):
              <device> /home <fstype> defaults,rw,nosuid,nodev,relatime,usrquota,grpquota 0 0
              
              ========================================
              REMEDIATION PROCEDURE - NEW SYSTEMS
              ========================================
              
              During Installation:
              1. Proceed with system installation normally
              2. When partitioning, select "Custom" partition layout
              3. Create a separate partition for /home (recommended: 50% of total space)
              4. Set mount point to /home
              5. Configure mount options in partitioner (if available)
              6. Complete installation
              
              Post-Installation Configuration:
              1. Edit /etc/fstab and ensure proper mount options:
                 <device> /home ext4 defaults,rw,nosuid,nodev,relatime 0 0
              
              2. Apply options:
                 # mount -o remount /home
              
              3. Verify configuration:
                 # findmnt -kn /home
              
              ========================================
              REMEDIATION PROCEDURE - EXISTING SYSTEMS
              ========================================
              
              WARNING: This procedure requires system downtime and careful planning.
              Backup all user data before proceeding.
              
              Step 1: Prepare
              1. Create full system and user data backups
              2. Boot into single-user or emergency mode:
                 # systemctl isolate rescue.target
              3. Verify auditd is not running:
                 # systemctl status auditd
              
              Step 2: Create New Partition
              1. Create new partition using available space (LVM recommended)
              2. Format with appropriate filesystem:
                 # mkfs.ext4 /dev/new_device
              3. Create temporary mount point:
                 # mkdir /mnt/home_new
                 # mount /dev/new_device /mnt/home_new
              
              Step 3: Migrate Data
              1. Copy all user data:
                 # cp -a /home/* /mnt/home_new/
              
              2. Verify data integrity:
                 # du -s /home
                 # du -s /mnt/home_new
              
              3. Rename old home directory:
                 # mv /home /home.backup
              
              Step 4: Configure New Mount
              1. Create /home mount point:
                 # mkdir /home
              
              2. Add to /etc/fstab with proper options:
                 /dev/new_device /home ext4 defaults,rw,nosuid,nodev,relatime 0 0
              
              3. Mount the new /home:
                 # mount /home
              
              Step 5: Verification
              1. Verify mount and options:
                 # findmnt -kn /home
              
              2. Check mount options:
                 # findmnt -kn /home | grep -E 'nosuid|nodev'
              
              3. Verify ownership and permissions:
                 # ls -la /home
              
              4. Test user access:
                 # su - username
              
              Step 6: Cleanup
              1. Once verified, remove backup (after extended validation period):
                 # rm -rf /home.backup
              
              2. Return to normal mode:
                 # systemctl default
              
              ========================================
              IMPORTANT CONSIDERATIONS
              ========================================
              
              Impact on Cloud Systems:
              - Resizing filesystems is common in cloud environments
              - Separate partitions may complicate resizing
              - May require additional tools for partition management
              - Consider using LVM for flexibility
              
              Impact on Performance:
              - Minimal performance impact from mount options
              - Some filesystems may have slight overhead (quotas)
              - Overall benefit outweighs performance cost
              
              User Access During Migration:
              - Users cannot access /home during migration
              - Plan migration during maintenance window
              - Notify users of downtime in advance
              - Verify SSH access works after completion
              
              Quota Management (Optional):
              - Additional security through per-user/group limits
              - Configure quotacheck and quotaon
              - Set quotas per user as needed
              - Monitor quota usage regularly
              
              ========================================
              VERIFICATION COMMANDS
              ========================================
              
              # Check if /home is separately mounted:
              findmnt -kn /home
              
              # Verify mount options:
              findmnt -kn /home | grep -E 'nosuid|nodev'
              
              # Check fstab entry:
              grep '/home' /etc/fstab
              
              # Test mounting:
              mount -o remount /home
              
              # Check disk usage:
              df -h /home
              du -sh /home/*
              
              # Verify user data integrity:
              ls -la /home
              
              ========================================
              REFERENCES
              ========================================
              
              CIS Benchmarks:
              - NIST SP 800-53 Rev. 5: CM-7, AC-3, MP-2
              
              Documentation:
              - LVM HOWTO: http://tldp.org/HOWTO/LVM-HOWTO/
              - fstab(5) manual page
              - fstab configuration details
              
              CIS Controls:
              - v8: 3.3 Configure Data Access Control Lists
              - v7: 14.6 Protect Information through Access Control Lists
              
              Related SELinux:
              - semanage fcontext may be needed for relabeling
              - restorecon -Rv /home after migration
            owner: root
            group: root
            mode: '0600'

    - name: "1.1.2.4.2 Ensure nodev option set on /var partition (Automated)"
      block:
        - name: "Check if /var partition exists"
          shell: findmnt -kn /var
          register: var_partition_check_dev
          changed_when: false
          failed_when: false

        - name: "Verify nodev option on /var"
          shell: findmnt -kn /var | grep -v nodev
          register: var_nodev_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with nodev option for /var"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/var\s+\S+\s+)(?!.*nodev)(.*)$'
            replace: '\1nodev,\2'
          when:
            - var_partition_check_dev.rc == 0
            - var_nodev_check.stdout != ''
          notify: remount_var

        - name: "Verify nodev is set on /var"
          shell: findmnt -kn /var | grep nodev
          register: var_nodev_verify
          changed_when: false
          failed_when: false
          when: var_partition_check_dev.rc == 0

        - name: "Display nodev status for /var"
          debug:
            msg: |
              Control 1.1.2.4.2 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /var partition exists: {{ 'Yes' if var_partition_check_dev.rc == 0 else 'No' }}
              - nodev option set: {{ 'Yes' if var_nodev_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent creation of block/character special devices in /var
              - Security Rationale: /var is intended for variable files, not device nodes
          when: var_partition_check_dev.rc == 0

    - name: "1.1.2.4.3 Ensure nosuid option set on /var partition (Automated)"
      block:
        - name: "Check if /var partition exists"
          shell: findmnt -kn /var
          register: var_partition_check_suid
          changed_when: false
          failed_when: false

        - name: "Verify nosuid option on /var"
          shell: findmnt -kn /var | grep -v nosuid
          register: var_nosuid_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with nosuid option for /var"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/var\s+\S+\s+)(?!.*nosuid)(.*)$'
            replace: '\1nosuid,\2'
          when:
            - var_partition_check_suid.rc == 0
            - var_nosuid_check.stdout != ''
          notify: remount_var

        - name: "Verify nosuid is set on /var"
          shell: findmnt -kn /var | grep nosuid
          register: var_nosuid_verify
          changed_when: false
          failed_when: false
          when: var_partition_check_suid.rc == 0

        - name: "Display nosuid status for /var"
          debug:
            msg: |
              Control 1.1.2.4.3 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /var partition exists: {{ 'Yes' if var_partition_check_suid.rc == 0 else 'No' }}
              - nosuid option set: {{ 'Yes' if var_nosuid_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent setuid files in /var
              - Security Rationale: Prevents privilege escalation via setuid programs in /var

        - name: "Create /var comprehensive security documentation"
          copy:
            dest: /root/CIS_1.1.2.4_var_configuration.txt
            content: |
              CIS Controls 1.1.2.4.2-3 - /var Partition Configuration
              Generated: {{ ansible_date_time.iso8601 }}
              
              ========================================
              /var PARTITION SECURITY CONFIGURATION
              ========================================
              
              Current Mount Status:
              {{ var_partition_check_suid.stdout if var_partition_check_suid.stdout else 'Not separately mounted' }}
              
              Configuration Status:
              - Separate partition: {{ 'Yes' if var_partition_check_suid.rc == 0 else 'No' }}
              - nodev option: {{ 'PASS' if var_nodev_verify.rc == 0 else 'FAIL' }}
              - nosuid option: {{ 'PASS' if var_nosuid_verify.rc == 0 else 'FAIL' }}
              
              ========================================
              CONTROL DESCRIPTIONS
              ========================================
              
              1.1.2.4.2 - nodev Option on /var
              Profile Applicability: Level 1 (Server/Workstation)
              
              Purpose: Prevents creation of block/character special devices
              Security Impact: Users cannot create device files in /var
              Rationale: /var contains variable data (logs, temporary files, package data)
                         and is not intended to support devices
              
              1.1.2.4.3 - nosuid Option on /var
              Profile Applicability: Level 1 (Server/Workstation)
              
              Purpose: Prevents setuid files from taking effect
              Security Impact: Blocks privilege escalation via setuid programs
              Rationale: /var contains logs and temporary files, not executables
                         Setting nosuid prevents attackers from using /var for exploits
              
              ========================================
              RECOMMENDED FSTAB CONFIGURATION
              ========================================
              
              Basic Configuration (with security options):
              <device> /var <fstype> defaults,rw,nosuid,nodev,relatime 0 0
              
              Example with ext4:
              /dev/sdb2 /var ext4 defaults,rw,nosuid,nodev,relatime 0 0
              
              Example with LVM:
              /dev/mapper/vg0-var /var ext4 defaults,rw,nosuid,nodev,relatime 0 0
              
              ========================================
              WHAT IS /var?
              ========================================
              
              The /var directory contains variable data that changes frequently:
              - System logs (/var/log)
              - Package cache (/var/cache)
              - Temporary files (/var/tmp)
              - Spool files (/var/spool)
              - Mail (/var/mail)
              - Lock files (/var/lock)
              - Run files (/var/run)
              
              These files should NOT contain:
              - Device nodes
              - Setuid executables
              - User home directories
              - Source code
              
              ========================================
              MOUNT OPTIONS EXPLANATION
              ========================================
              
              nodev (1.1.2.4.2):
              - Prevents creation of block and character device files
              - /var should never need device nodes
              - Prevents mknod system calls from creating devices in /var
              - Attack prevention: Attackers cannot create /dev/something in /var
              
              nosuid (1.1.2.4.3):
              - Prevents setuid and setgid bits from having effect
              - /var contains logs, not executable programs
              - Prevents privilege escalation via setuid exploits
              - Attack prevention: Even if attacker places setuid binary in /var, it cannot elevate privileges
              
              ========================================
              REMEDIATION PROCEDURE
              ========================================
              
              If /var is on a separate partition (recommended):
              
              1. Edit /etc/fstab:
                 # vi /etc/fstab
              
              2. Locate the /var entry and add missing options:
                 <device> /var ext4 defaults,rw,nosuid,nodev,relatime 0 0
              
              3. Apply the changes:
                 # mount -o remount /var
              
              4. Verify configuration:
                 # findmnt -kn /var
                 
              Expected output should contain: nosuid nodev
              
              If /var is NOT on a separate partition:
              
              - The root filesystem must support these options
              - Consider creating a separate /var partition for better security
              - This is a Level 2 best practice
              
              ========================================
              VERIFICATION COMMANDS
              ========================================
              
              # Check if /var is separately mounted:
              findmnt -kn /var
              
              # Verify mount options:
              findmnt -kn /var | grep -E 'nosuid|nodev'
              
              # Check fstab entry:
              grep '/var' /etc/fstab
              
              # Test mounting:
              mount -o remount /var
              
              # Check disk usage:
              df -h /var
              du -sh /var/*
              
              # Verify logs are accessible:
              ls -la /var/log
              
              ========================================
              IMPORTANT CONSIDERATIONS
              ========================================
              
              Impact on System:
              - Minimal performance impact
              - Logs continue to be written normally
              - Packages still install to /var/cache
              - No application compatibility issues expected
              
              Security Benefits:
              - Prevents device file creation attacks
              - Prevents setuid privilege escalation in /var
              - Industry standard security practice
              - Aligns with security benchmarks
              
              System Administration:
              - Regular log rotation still works
              - Package management unchanged
              - Temporary files still function normally
              - Security monitoring unaffected
              
              ========================================
              ROLLBACK PROCEDURE (if needed)
              ========================================
              
              1. Edit /etc/fstab and remove restrictive options:
                 <device> /var ext4 defaults,rw,relatime 0 0
              
              2. Remount with new options:
                 # mount -o remount /var
              
              3. Verify change:
                 # findmnt -kn /var
              
              ========================================
              REFERENCES
              ========================================
              
              CIS Benchmarks:
              - NIST SP 800-53 Rev. 5: AC-3, MP-2
              
              Documentation:
              - fstab(5) manual page
              - mount(8) manual page
              - CIS Red Hat Enterprise Linux 8 Benchmark
              
              CIS Controls:
              - v8: 3.3 Configure Data Access Control Lists
              - v7: 14.6 Protect Information through Access Control Lists
              
              Related Controls:
              - 1.1.2.4.1: Ensure separate partition exists for /var (Level 2)
              - 1.1.2.4.4: Ensure bind apparmor option set on /var/log/audit
              - 1.1.2.4.5: Ensure bind apparmor option set on /var/tmp
            owner: root
            group: root
            mode: '0600'

    - name: "1.1.2.5.1 Ensure separate partition exists for /var/tmp (Automated)"
      block:
        - name: "Check if /var/tmp partition exists"
          shell: findmnt -kn /var/tmp
          register: var_tmp_partition_check
          changed_when: false
          failed_when: false

        - name: "Display /var/tmp partition status"
          debug:
            msg: |
              Control 1.1.2.5.1 Status:
              - Profile Level: Level 2 (Server/Workstation)
              - /var/tmp partition exists: {{ 'Yes - Compliant' if var_tmp_partition_check.rc == 0 else 'No - Requires remediation' }}
              - Current mount information: {{ var_tmp_partition_check.stdout if var_tmp_partition_check.stdout else 'Not separately mounted' }}
              - Purpose: Isolate temporary files and support mount options (noexec/nosuid/nodev)
              - Impact: Allows administrators to prevent execution and device creation in /var/tmp

        - name: "Important Note - /var/tmp Partition Configuration"
          debug:
            msg: |
              NOTE: This control (1.1.2.5.1) requires manual intervention during system setup.
              
              For new installations:
              - Create a custom partition setup during installation
              - Designate a separate partition for /var/tmp
              
              For existing systems:
              - Create a new partition using LVM or fdisk
              - Add entries to /etc/fstab
              - Migrate temporary files using proper backup/restore procedures
              - Bring system to emergency mode for the migration
              
              Recommended /etc/fstab entry:
              <device> /var/tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
              
              Procedure (in emergency mode):
              1. systemctl isolate rescue.target
              2. mv /var/tmp /var/tmp.backup
              3. mkdir /var/tmp
              4. mount /var/tmp
              5. cp -r /var/tmp.backup/* /var/tmp/
              6. systemctl default

    - name: "1.1.2.5.2 Ensure nodev option set on /var/tmp partition (Automated)"
      block:
        - name: "Check if /var/tmp partition exists"
          shell: findmnt -kn /var/tmp
          register: var_tmp_partition_check_dev
          changed_when: false
          failed_when: false

        - name: "Verify nodev option on /var/tmp"
          shell: findmnt -kn /var/tmp | grep -v nodev
          register: var_tmp_nodev_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with nodev option for /var/tmp"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/var/tmp\s+\S+\s+)(?!.*nodev)(.*)$'
            replace: '\1nodev,\2'
          when:
            - var_tmp_partition_check_dev.rc == 0
            - var_tmp_nodev_check.stdout != ''
          notify: remount_var_tmp

        - name: "Verify nodev is set on /var/tmp"
          shell: findmnt -kn /var/tmp | grep nodev
          register: var_tmp_nodev_verify
          changed_when: false
          failed_when: false
          when: var_tmp_partition_check_dev.rc == 0

        - name: "Display nodev status for /var/tmp"
          debug:
            msg: |
              Control 1.1.2.5.2 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /var/tmp partition exists: {{ 'Yes' if var_tmp_partition_check_dev.rc == 0 else 'No' }}
              - nodev option set: {{ 'Yes' if var_tmp_nodev_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent creation of block/character special devices in /var/tmp
              - Security Rationale: Users cannot create devices that could interact with hardware
              - STIG IDs: RHEL-08-010544, RHEL-09-231025, ALMA-09-025550
          when: var_tmp_partition_check_dev.rc == 0

    - name: "1.1.2.5.3 Ensure nosuid option set on /var/tmp partition (Automated)"
      block:
        - name: "Check if /var/tmp partition exists"
          shell: findmnt -kn /var/tmp
          register: var_tmp_partition_check_suid
          changed_when: false
          failed_when: false

        - name: "Verify nosuid option on /var/tmp"
          shell: findmnt -kn /var/tmp | grep -v nosuid
          register: var_tmp_nosuid_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with nosuid option for /var/tmp"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/var/tmp\s+\S+\s+)(?!.*nosuid)(.*)$'
            replace: '\1nosuid,\2'
          when:
            - var_tmp_partition_check_suid.rc == 0
            - var_tmp_nosuid_check.stdout != ''
          notify: remount_var_tmp

        - name: "Verify nosuid is set on /var/tmp"
          shell: findmnt -kn /var/tmp | grep nosuid
          register: var_tmp_nosuid_verify
          changed_when: false
          failed_when: false
          when: var_tmp_partition_check_suid.rc == 0

        - name: "Display nosuid status for /var/tmp"
          debug:
            msg: |
              Control 1.1.2.5.3 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /var/tmp partition exists: {{ 'Yes' if var_tmp_partition_check_suid.rc == 0 else 'No' }}
              - nosuid option set: {{ 'Yes' if var_tmp_nosuid_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent setuid files in /var/tmp
              - Security Rationale: Prevents privilege escalation via setuid programs
              - STIG IDs: RHEL-08-010545, RHEL-09-231035, ALMA-09-025570
          when: var_tmp_partition_check_suid.rc == 0

    - name: "1.1.2.5.4 Ensure noexec option set on /var/tmp partition (Automated)"
      block:
        - name: "Check if /var/tmp partition exists"
          shell: findmnt -kn /var/tmp
          register: var_tmp_partition_check_exec
          changed_when: false
          failed_when: false

        - name: "Verify noexec option on /var/tmp"
          shell: findmnt -kn /var/tmp | grep -v noexec
          register: var_tmp_noexec_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with noexec option for /var/tmp"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/var/tmp\s+\S+\s+)(?!.*noexec)(.*)$'
            replace: '\1noexec,\2'
          when:
            - var_tmp_partition_check_exec.rc == 0
            - var_tmp_noexec_check.stdout != ''
          notify: remount_var_tmp

        - name: "Verify noexec is set on /var/tmp"
          shell: findmnt -kn /var/tmp | grep noexec
          register: var_tmp_noexec_verify
          changed_when: false
          failed_when: false
          when: var_tmp_partition_check_exec.rc == 0

        - name: "Display noexec status for /var/tmp"
          debug:
            msg: |
              Control 1.1.2.5.4 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /var/tmp partition exists: {{ 'Yes' if var_tmp_partition_check_exec.rc == 0 else 'No' }}
              - noexec option set: {{ 'Yes' if var_tmp_noexec_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent execution of binaries from /var/tmp
              - Security Rationale: Prevents running malicious scripts or binaries from /var/tmp
              - STIG IDs: RHEL-08-010546, RHEL-09-231040, ALMA-09-025580

        - name: "Create /var/tmp comprehensive security documentation"
          copy:
            dest: /root/CIS_1.1.2.5_var_tmp_configuration.txt
            content: |
              CIS Controls 1.1.2.5.1-4 - /var/tmp Partition Configuration
              Generated: {{ ansible_date_time.iso8601 }}
              
              ========================================
              /var/tmp PARTITION SECURITY CONFIGURATION
              ========================================
              
              Current Mount Status:
              {{ var_tmp_partition_check_exec.stdout if var_tmp_partition_check_exec.stdout else 'Not separately mounted' }}
              
              Configuration Status:
              - Separate partition: {{ 'Yes' if var_tmp_partition_check_exec.rc == 0 else 'No - Level 2 requirement' }}
              - nodev option: {{ 'PASS' if var_tmp_nodev_verify.rc == 0 else 'FAIL' }}
              - nosuid option: {{ 'PASS' if var_tmp_nosuid_verify.rc == 0 else 'FAIL' }}
              - noexec option: {{ 'PASS' if var_tmp_noexec_verify.rc == 0 else 'FAIL' }}
              
              ========================================
              CONTROL DESCRIPTIONS
              ========================================
              
              1.1.2.5.1 - Separate Partition for /var/tmp
              Profile Applicability: Level 2 (Server/Workstation)
              
              Description:
              The /var/tmp directory is a world-writable directory used for temporary 
              storage by all users and some applications. Temporary files in /var/tmp 
              are preserved between reboots.
              
              Rationale:
              - Single partition systems risk disk exhaustion affecting all users
              - /var/tmp can consume significant space due to temporary files
              - Separate partition allows dedicated mount options (noexec/nosuid/nodev)
              - Prevents /var/tmp from filling root filesystem
              - Allows quota management for temporary file storage
              
              1.1.2.5.2 - nodev Option on /var/tmp
              Profile Applicability: Level 1 (Server/Workstation)
              
              Purpose: Prevents creation of block/character special devices
              Security Impact: Attackers cannot create device files in /var/tmp
              
              1.1.2.5.3 - nosuid Option on /var/tmp
              Profile Applicability: Level 1 (Server/Workstation)
              
              Purpose: Prevents setuid files from taking effect
              Security Impact: Blocks privilege escalation via setuid programs
              
              1.1.2.5.4 - noexec Option on /var/tmp
              Profile Applicability: Level 1 (Server/Workstation)
              
              Purpose: Prevents execution of binaries
              Security Impact: Prevents running malicious scripts/binaries from /var/tmp
              
              ========================================
              WHAT IS /var/tmp?
              ========================================
              
              /var/tmp is a world-writable directory for temporary files:
              - Persistent across reboots (unlike /tmp)
              - Used by applications and system utilities
              - Contains temporary installation files
              - Used for long-running temporary data
              - Backed up in some systems (unlike /tmp)
              
              Key Differences from /tmp:
              /tmp:
              - Usually cleared on reboot (tmpfs)
              - Files do not survive reboot
              - Smaller allocated space
              
              /var/tmp:
              - Persistent across reboots
              - Used for longer-lived temporary files
              - Requires separate partition for proper security
              
              ========================================
              RECOMMENDED FSTAB CONFIGURATION
              ========================================
              
              Basic Configuration (with all security options):
              <device> /var/tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
              
              Example with ext4:
              /dev/sdb3 /var/tmp ext4 defaults,rw,nosuid,nodev,noexec,relatime 0 0
              
              Example with LVM:
              /dev/mapper/vg0-var_tmp /var/tmp ext4 defaults,rw,nosuid,nodev,noexec,relatime 0 0
              
              With quota support (optional):
              <device> /var/tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime,usrquota,grpquota 0 0
              
              ========================================
              MOUNT OPTIONS EXPLANATION
              ========================================
              
              defaults:
              - Shorthand for: rw,suid,dev,exec,auto,nouser,async
              - Provides standard mount behavior
              
              rw:
              - Read/Write access
              - Allows writing temporary files
              
              nosuid (1.1.2.5.3):
              - Prevents setuid and setgid bits from having effect
              - /var/tmp is temporary storage, not for executables
              - Prevents privilege escalation via setuid exploits
              - Attack prevention: Setuid programs cannot run from /var/tmp
              
              nodev (1.1.2.5.2):
              - Prevents creation of block and character device files
              - /var/tmp is not intended to support devices
              - Prevents mknod system calls from creating devices
              - Attack prevention: Attackers cannot create /dev/something in /var/tmp
              
              noexec (1.1.2.5.4):
              - Prevents execution of binaries
              - /var/tmp is for temporary files, not executables
              - Prevents running malicious scripts/binaries
              - Attack prevention: Even if malware is written to /var/tmp, it cannot execute
              
              relatime:
              - Reduces filesystem write overhead
              - Updates access time only when modified time is newer
              - Minimal security impact
              - Improves performance
              
              ========================================
              REMEDIATION PROCEDURE - NEW SYSTEMS
              ========================================
              
              During Installation:
              1. Proceed with system installation normally
              2. When partitioning, select "Custom" partition layout
              3. Create a separate partition for /var/tmp
              4. Set mount point to /var/tmp
              5. Configure mount options in partitioner
              6. Complete installation
              
              Post-Installation Configuration:
              1. Edit /etc/fstab and ensure proper mount options:
                 # vi /etc/fstab
                 
              2. Locate /var/tmp entry and verify:
                 <device> /var/tmp ext4 defaults,rw,nosuid,nodev,noexec,relatime 0 0
                 
              3. Apply options:
                 # mount -o remount /var/tmp
                 
              4. Verify configuration:
                 # findmnt -kn /var/tmp
                 
              5. Confirm all mount options are present:
                 # findmnt -kn /var/tmp | grep -E 'nosuid|nodev|noexec'
              
              ========================================
              REMEDIATION PROCEDURE - EXISTING SYSTEMS
              ========================================
              
              WARNING: This procedure MUST be done in emergency mode to avoid issues
              with running processes accessing /var/tmp
              
              1. Boot into rescue/emergency mode:
                 # systemctl isolate rescue.target
              
              2. Backup existing /var/tmp:
                 # mv /var/tmp /var/tmp.backup
              
              3. Create mount point:
                 # mkdir -p /var/tmp
                 # chmod 1777 /var/tmp
              
              4. Mount new partition:
                 # mount /var/tmp
              
              5. Migrate data:
                 # cp -r /var/tmp.backup/* /var/tmp/
                 # chown -R root:root /var/tmp
                 # chmod 1777 /var/tmp
              
              6. Verify mount options:
                 # findmnt -kn /var/tmp
              
              7. Return to multi-user mode:
                 # systemctl default
              
              8. Verify system is functioning:
                 # systemctl status
                 # df -h /var/tmp
              
              ========================================
              VERIFICATION COMMANDS
              ========================================
              
              # Check if /var/tmp is separately mounted:
              findmnt -kn /var/tmp
              
              # Verify all mount options are set:
              findmnt -kn /var/tmp | grep -E 'nosuid.*nodev.*noexec'
              
              # Check each option individually:
              findmnt -kn /var/tmp | grep -q 'nosuid' && echo "nosuid: OK"
              findmnt -kn /var/tmp | grep -q 'nodev' && echo "nodev: OK"
              findmnt -kn /var/tmp | grep -q 'noexec' && echo "noexec: OK"
              
              # Verify /etc/fstab configuration:
              grep /var/tmp /etc/fstab
              
              # Check filesystem type:
              findmnt -kn /var/tmp -o FSTYPE
              
              # Check disk usage:
              df -h /var/tmp
              du -sh /var/tmp
              
              # List temporary files:
              ls -la /var/tmp
              
              # Check mount options in detail:
              mount | grep /var/tmp
              
              ========================================
              IMPORTANT NOTES
              ========================================
              
              Partition Sizing:
              - Default size dependent on workload
              - Monitor usage with: du -sh /var/tmp
              - Consider 5-10% of total disk space
              - Can be resized with LVM if needed
              
              Distribution-Specific Considerations:
              - Some distributions override /etc/fstab
              - /var/tmp may be included in /var partition
              - Consult distribution documentation
              
              Performance Impact:
              - Minimal performance impact from these restrictions
              - noexec prevents most significant overhead
              - Applications continue to function normally
              
              Application Impact:
              - Most applications work unchanged
              - Some installers may require /var/tmp
              - Testing scripts may need modification
              - Container images should not rely on /var/tmp execution
              
              Rollback Procedure (if needed):
              1. Boot into emergency mode:
                 # systemctl isolate rescue.target
              
              2. Backup new partition data:
                 # mv /var/tmp /var/tmp.new
              
              3. Restore original data:
                 # mv /var/tmp.backup /var/tmp
              
              4. Edit /etc/fstab and remove separate partition:
                 # vi /etc/fstab
              
              5. Return to normal mode:
                 # systemctl default
              
              ========================================
              COMPLIANCE VERIFICATION
              ========================================
              
              For compliance checks, verify:
              1. /var/tmp is on separate partition (Level 2)
              2. nodev option is set (Level 1)
              3. nosuid option is set (Level 1)
              4. noexec option is set (Level 1)
              
              All four options should appear in mount output:
              # findmnt -kn /var/tmp
              Should show: nodev,nosuid,noexec
              
              ========================================
              REFERENCES
              ========================================
              
              CIS Benchmarks:
              - Control 1.1.2.5.1-4: /var/tmp partition configuration
              - Profile Level: 1 & 2 (Server/Workstation)
              - CCI-001764, CCI-000366
              
              NIST References:
              - NIST SP 800-53 Rev. 5: CM-7, AC-3, MP-2
              - NIST SP 800-53A :: CM-6.1 (iv)
              
              STIG References:
              - RHEL 8 STIG:
                - V-244529 (Separate partition)
                - V-230520 (nodev option)
                - V-230521 (nosuid option)
                - V-230522 (noexec option)
              
              - RHEL 9 STIG:
                - RHEL-09-231025 (nodev)
                - RHEL-09-231035 (nosuid)
                - RHEL-09-231040 (noexec)
              
              - ALMA 9:
                - ALMA-09-025550 (nodev)
                - ALMA-09-025570 (nosuid)
                - ALMA-09-025580 (noexec)
              
              Documentation:
              - http://tldp.org/HOWTO/LVM-HOWTO/
              - fstab(5) manual page
              - mount(8) manual page
              - CIS Red Hat Enterprise Linux 8 Benchmark
              
              CIS Controls:
              - v8: 3.3 Configure Data Access Control Lists
              - v7: 14.6 Protect Information through Access Control Lists
            owner: root
            group: root
            mode: '0600'
          when: var_tmp_partition_check_exec.rc == 0

    - name: "1.1.2.6.1 Ensure separate partition exists for /var/log (Automated)"
      block:
        - name: "Check if /var/log partition exists"
          shell: findmnt -kn /var/log
          register: var_log_partition_check
          changed_when: false
          failed_when: false

        - name: "Display /var/log partition status"
          debug:
            msg: |
              Control 1.1.2.6.1 Status:
              - Profile Level: Level 2 (Server/Workstation)
              - /var/log partition exists: {{ 'Yes - Compliant' if var_log_partition_check.rc == 0 else 'No - Requires remediation' }}
              - Current mount information: {{ var_log_partition_check.stdout if var_log_partition_check.stdout else 'Not separately mounted' }}
              - Purpose: Isolate log files and support mount options (noexec/nosuid/nodev)
              - Impact: Allows administrators to manage disk usage for logs separately

        - name: "Important Note - /var/log Partition Configuration"
          debug:
            msg: |
              NOTE: This control (1.1.2.6.1) requires manual intervention during system setup.
              
              For new installations:
              - Create a custom partition setup during installation
              - Designate a separate partition for /var/log
              
              For existing systems:
              - Create a new partition using LVM or fdisk
              - Add entries to /etc/fstab
              - Migrate log files using proper backup/restore procedures
              - Bring system to emergency mode for the migration
              
              Recommended /etc/fstab entry:
              <device> /var/log <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
              
              Procedure (in emergency mode):
              1. systemctl isolate rescue.target
              2. mv /var/log /var/log.backup
              3. mkdir /var/log
              4. mount /var/log
              5. cp -r /var/log.backup/* /var/log/
              6. systemctl default

    - name: "1.1.2.6.2 Ensure nodev option set on /var/log partition (Automated)"
      block:
        - name: "Check if /var/log partition exists"
          shell: findmnt -kn /var/log
          register: var_log_partition_check_dev
          changed_when: false
          failed_when: false

        - name: "Verify nodev option on /var/log"
          shell: findmnt -kn /var/log | grep -v nodev
          register: var_log_nodev_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with nodev option for /var/log"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/var/log\s+\S+\s+)(?!.*nodev)(.*)$'
            replace: '\1nodev,\2'
          when:
            - var_log_partition_check_dev.rc == 0
            - var_log_nodev_check.stdout != ''
          notify: remount_var_log

        - name: "Verify nodev is set on /var/log"
          shell: findmnt -kn /var/log | grep nodev
          register: var_log_nodev_verify
          changed_when: false
          failed_when: false
          when: var_log_partition_check_dev.rc == 0

        - name: "Display nodev status for /var/log"
          debug:
            msg: |
              Control 1.1.2.6.2 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /var/log partition exists: {{ 'Yes' if var_log_partition_check_dev.rc == 0 else 'No' }}
              - nodev option set: {{ 'Yes' if var_log_nodev_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent creation of block/character special devices in /var/log
              - Security Rationale: Users cannot create devices that could interact with hardware
              - STIG IDs: RHEL-08-040131, RHEL-09-231050, ALMA-09-025600
          when: var_log_partition_check_dev.rc == 0

    - name: "1.1.2.6.3 Ensure nosuid option set on /var/log partition (Automated)"
      block:
        - name: "Check if /var/log partition exists"
          shell: findmnt -kn /var/log
          register: var_log_partition_check_suid
          changed_when: false
          failed_when: false

        - name: "Verify nosuid option on /var/log"
          shell: findmnt -kn /var/log | grep -v nosuid
          register: var_log_nosuid_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with nosuid option for /var/log"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/var/log\s+\S+\s+)(?!.*nosuid)(.*)$'
            replace: '\1nosuid,\2'
          when:
            - var_log_partition_check_suid.rc == 0
            - var_log_nosuid_check.stdout != ''
          notify: remount_var_log

        - name: "Verify nosuid is set on /var/log"
          shell: findmnt -kn /var/log | grep nosuid
          register: var_log_nosuid_verify
          changed_when: false
          failed_when: false
          when: var_log_partition_check_suid.rc == 0

        - name: "Display nosuid status for /var/log"
          debug:
            msg: |
              Control 1.1.2.6.3 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /var/log partition exists: {{ 'Yes' if var_log_partition_check_suid.rc == 0 else 'No' }}
              - nosuid option set: {{ 'Yes' if var_log_nosuid_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent setuid files in /var/log
              - Security Rationale: Prevents privilege escalation via setuid programs
              - STIG IDs: RHEL-08-040132, RHEL-09-231060, ALMA-09-025620
          when: var_log_partition_check_suid.rc == 0

    - name: "1.1.2.6.4 Ensure noexec option set on /var/log partition (Automated)"
      block:
        - name: "Check if /var/log partition exists"
          shell: findmnt -kn /var/log
          register: var_log_partition_check_exec
          changed_when: false
          failed_when: false

        - name: "Verify noexec option on /var/log"
          shell: findmnt -kn /var/log | grep -v noexec
          register: var_log_noexec_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with noexec option for /var/log"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/var/log\s+\S+\s+)(?!.*noexec)(.*)$'
            replace: '\1noexec,\2'
          when:
            - var_log_partition_check_exec.rc == 0
            - var_log_noexec_check.stdout != ''
          notify: remount_var_log

        - name: "Verify noexec is set on /var/log"
          shell: findmnt -kn /var/log | grep noexec
          register: var_log_noexec_verify
          changed_when: false
          failed_when: false
          when: var_log_partition_check_exec.rc == 0

        - name: "Display noexec status for /var/log"
          debug:
            msg: |
              Control 1.1.2.6.4 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /var/log partition exists: {{ 'Yes' if var_log_partition_check_exec.rc == 0 else 'No' }}
              - noexec option set: {{ 'Yes' if var_log_noexec_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent execution of binaries from /var/log
              - Security Rationale: Prevents running malicious scripts or binaries from /var/log
              - STIG IDs: RHEL-08-040133, RHEL-09-231065, ALMA-09-025630


        - name: "1.1.2.7.1 Ensure separate partition exists for /var/log/audit (Automated)"
          block:
        - name: "Check if /var/log/audit partition exists"
          shell: findmnt -kn /var/log/audit
          register: var_log_audit_partition_check
          changed_when: false
          failed_when: false

        - name: "Display /var/log/audit partition status"
          debug:
            msg: |
              Control 1.1.2.7.1 Status:
              - Profile Level: Level 2 (Server/Workstation)
              - /var/log/audit separate partition exists: {{ 'Yes' if var_log_audit_partition_check.rc == 0 else 'No - Level 2 requirement not met' }}
              - Current mount info: {{ var_log_audit_partition_check.stdout if var_log_audit_partition_check.stdout else 'Not separately mounted' }}
              - Purpose: Prevent audit log growth from exhausting disk space
              - Security Rationale: Isolates audit logs, allows dedicated mount options (noexec/nosuid/nodev)
              - NIST: CM-7, CM-6 b
              - STIG ID: RHEL-08-040128 | RULE ID: SV-230294r627750

        - name: "Create /var/log/audit comprehensive security documentation"
          copy:
            dest: /root/CIS_1.1.2.7_var_log_audit_configuration.txt
            content: |
              CIS Controls 1.1.2.7.1-4 - /var/log/audit Partition Configuration
              Generated: {{ ansible_date_time.iso8601 }}

              ========================================
              /var/log/audit PARTITION SECURITY CONFIGURATION
              ========================================

              Current Mount Status:
              {{ var_log_audit_partition_check.stdout if var_log_audit_partition_check.stdout else 'Not separately mounted' }}

              Configuration Status:
              - Separate partition: {{ 'Yes' if var_log_audit_partition_check.rc == 0 else 'No - Level 2 requirement' }}

              RECOMMENDED FSTAB CONFIGURATION:
              <device> /var/log/audit <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0

              Example (ext4):
              /dev/sdb /var/log/audit ext4 rw,nosuid,nodev,noexec,relatime,seclabel 0 0

              REMEDIATION (Existing systems):
              1. systemctl isolate emergency.target
              2. systemctl stop auditd
              3. mv /var/log/audit /var/log/audit.backup
              4. Create new filesystem and add to /etc/fstab
              5. mount /var/log/audit
              6. cp -r /var/log/audit.backup/* /var/log/audit/
              7. systemctl default

              References:
              - NIST SP 800-53 Rev. 5: CM-7, CM-6 b
              - NIST SP 800-53A :: CM-6.1 (iv)
              - RHEL 8 STIG Vul ID: V-230294 | Rule ID: SV-230294r627750
              - CIS v8: 8.3 Ensure Adequate Audit Log Storage
              - CIS v7: 6.4 Ensure adequate storage for logs
            owner: root
            group: root
            mode: '0600'
          when: var_log_audit_partition_check.rc == 0

    - name: "1.1.2.7.2 Ensure nodev option set on /var/log/audit partition (Automated)"
      block:
        - name: "Check if /var/log/audit partition exists"
          shell: findmnt -kn /var/log/audit
          register: var_log_audit_partition_check_dev
          changed_when: false
          failed_when: false

        - name: "Verify nodev option on /var/log/audit"
          shell: findmnt -kn /var/log/audit | grep -v nodev
          register: var_log_audit_nodev_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with nodev option for /var/log/audit"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/var/log/audit\s+\S+\s+)(?!.*nodev)(.*)$'
            replace: '\1nodev,\2'
          when:
            - var_log_audit_partition_check_dev.rc == 0
            - var_log_audit_nodev_check.stdout != ''
          notify: remount_var_log_audit

        - name: "Verify nodev is set on /var/log/audit"
          shell: findmnt -kn /var/log/audit | grep nodev
          register: var_log_audit_nodev_verify
          changed_when: false
          failed_when: false
          when: var_log_audit_partition_check_dev.rc == 0

        - name: "Display nodev status for /var/log/audit"
          debug:
            msg: |
              Control 1.1.2.7.2 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /var/log/audit partition exists: {{ 'Yes' if var_log_audit_partition_check_dev.rc == 0 else 'No' }}
              - nodev option set: {{ 'Yes' if var_log_audit_nodev_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent creation of block/character special devices in /var/log/audit
              - Security Rationale: Users cannot create devices that could interact with hardware
              - NIST: CM-7 (2)
              - STIG IDs: RHEL-08-040129 | SV-230517r958804, RHEL-09-231175 | SV-257876r958804, ALMA-09-027190 | SV-269320r1050202
          when: var_log_audit_partition_check_dev.rc == 0

    - name: "1.1.2.7.3 Ensure nosuid option set on /var/log/audit partition (Automated)"
      block:
        - name: "Check if /var/log/audit partition exists"
          shell: findmnt -kn /var/log/audit
          register: var_log_audit_partition_check_suid
          changed_when: false
          failed_when: false

        - name: "Verify nosuid option on /var/log/audit"
          shell: findmnt -kn /var/log/audit | grep -v nosuid
          register: var_log_audit_nosuid_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with nosuid option for /var/log/audit"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/var/log/audit\s+\S+\s+)(?!.*nosuid)(.*)$'
            replace: '\1nosuid,\2'
          when:
            - var_log_audit_partition_check_suid.rc == 0
            - var_log_audit_nosuid_check.stdout != ''
          notify: remount_var_log_audit

        - name: "Verify nosuid is set on /var/log/audit"
          shell: findmnt -kn /var/log/audit | grep nosuid
          register: var_log_audit_nosuid_verify
          changed_when: false
          failed_when: false
          when: var_log_audit_partition_check_suid.rc == 0

        - name: "Display nosuid status for /var/log/audit"
          debug:
            msg: |
              Control 1.1.2.7.3 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /var/log/audit partition exists: {{ 'Yes' if var_log_audit_partition_check_suid.rc == 0 else 'No' }}
              - nosuid option set: {{ 'Yes' if var_log_audit_nosuid_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent setuid files in /var/log/audit
              - Security Rationale: Prevents privilege escalation via setuid programs
              - NIST: AC-3, MP-2, CM-7 (2)
              - STIG IDs: RHEL-08-040130 | SV-230518r958804, RHEL-09-231170 | SV-257875r958804
          when: var_log_audit_partition_check_suid.rc == 0

    - name: "1.1.2.7.4 Ensure noexec option set on /var/log/audit partition (Automated)"
      block:
        - name: "Check if /var/log/audit partition exists"
          shell: findmnt -kn /var/log/audit
          register: var_log_audit_partition_check_exec
          changed_when: false
          failed_when: false

        - name: "Verify noexec option on /var/log/audit"
          shell: findmnt -kn /var/log/audit | grep -v noexec
          register: var_log_audit_noexec_check
          changed_when: false
          failed_when: false

        - name: "Update /etc/fstab with noexec option for /var/log/audit"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/var/log/audit\s+\S+\s+)(?!.*noexec)(.*)$'
            replace: '\1noexec,\2'
          when:
            - var_log_audit_partition_check_exec.rc == 0
            - var_log_audit_noexec_check.stdout != ''
          notify: remount_var_log_audit

        - name: "Verify noexec is set on /var/log/audit"
          shell: findmnt -kn /var/log/audit | grep noexec
          register: var_log_audit_noexec_verify
          changed_when: false
          failed_when: false
          when: var_log_audit_partition_check_exec.rc == 0

        - name: "Display noexec status for /var/log/audit"
          debug:
            msg: |
              Control 1.1.2.7.4 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - /var/log/audit partition exists: {{ 'Yes' if var_log_audit_partition_check_exec.rc == 0 else 'No' }}
              - noexec option set: {{ 'Yes' if var_log_audit_noexec_verify.rc == 0 else 'Needs configuration' }}
              - Purpose: Prevent execution of binaries from /var/log/audit
              - Security Rationale: Prevents running malicious scripts or binaries from /var/log/audit
              - NIST: AC-3, MP-2, CM-7 (2)
              - STIG IDs: RHEL-08-040131 | SV-230519r958804, RHEL-09-231165 | SV-257874r958804
          when: var_log_audit_partition_check_exec.rc == 0



        - name: "Create /var/log comprehensive security documentation"
          copy:
            dest: /root/CIS_1.1.2.6_var_log_configuration.txt
            content: |
              CIS Controls 1.1.2.6.1-4 - /var/log Partition Configuration
              Generated: {{ ansible_date_time.iso8601 }}
              
              ========================================
              /var/log PARTITION SECURITY CONFIGURATION
              ========================================
              
              Current Mount Status:
              {{ var_log_partition_check_exec.stdout if var_log_partition_check_exec.stdout else 'Not separately mounted' }}
              
              Configuration Status:
              - Separate partition: {{ 'Yes' if var_log_partition_check_exec.rc == 0 else 'No - Level 2 requirement' }}
              - nodev option: {{ 'PASS' if var_log_nodev_verify.rc == 0 else 'FAIL' }}
              - nosuid option: {{ 'PASS' if var_log_nosuid_verify.rc == 0 else 'FAIL' }}
              - noexec option: {{ 'PASS' if var_log_noexec_verify.rc == 0 else 'FAIL' }}
              
              ========================================
              CONTROL DESCRIPTIONS
              ========================================
              
              1.1.2.6.1 - Separate Partition for /var/log
              Profile Applicability: Level 2 (Server/Workstation)
              
              Description:
              The /var/log directory is used by system services to store log data.
              
              Rationale:
              - Log files can grow quite large and impact system availability
              - Single partition systems risk disk exhaustion affecting entire system
              - Separate /var/log prevents log growth from filling root filesystem
              - Allows dedicated mount options (noexec/nosuid/nodev) for additional security
              - Provides control over log retention and disk space management
              
              1.1.2.6.2 - nodev Option on /var/log
              Profile Applicability: Level 1 (Server/Workstation)
              
              Purpose: Prevents creation of block/character special devices
              Security Impact: Users cannot create device files in /var/log
              
              1.1.2.6.3 - nosuid Option on /var/log
              Profile Applicability: Level 1 (Server/Workstation)
              
              Purpose: Prevents setuid files from taking effect
              Security Impact: Blocks privilege escalation via setuid programs
              
              1.1.2.6.4 - noexec Option on /var/log
              Profile Applicability: Level 1 (Server/Workstation)
              
              Purpose: Prevents execution of binaries
              Security Impact: Prevents running malicious scripts/binaries from /var/log
              
              ========================================
              WHAT IS /var/log?
              ========================================
              
              /var/log is used for system logging:
              - System messages and kernel logs
              - Service/application logs
              - Audit logs (/var/log/audit)
              - Authentication logs
              - Secure logs (sensitive information)
              - Other service-specific logs
              
              Log files contain:
              - System events and warnings
              - User login/logout records
              - Service startup/shutdown events
              - Security-related events
              - Performance and error messages
              
              Why separate partition is important:
              - Logs can grow unexpectedly
              - Runaway logging can fill disk
              - Prevents log growth from affecting system services
              - Allows quota management per filesystem
              - Improves system stability and availability
              
              ========================================
              RECOMMENDED FSTAB CONFIGURATION
              ========================================
              
              Basic Configuration (with all security options):
              <device> /var/log <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0
              
              Example with ext4:
              /dev/sdb4 /var/log ext4 defaults,rw,nosuid,nodev,noexec,relatime 0 0
              
              Example with LVM:
              /dev/mapper/vg0-var_log /var/log ext4 defaults,rw,nosuid,nodev,noexec,relatime 0 0
              
              ========================================
              MOUNT OPTIONS EXPLANATION
              ========================================
              
              nodev (1.1.2.6.2):
              - Prevents creation of block and character device files
              - /var/log is for text log files, not device nodes
              - Prevents mknod system calls from creating devices
              - Attack prevention: Attackers cannot create /dev/something in /var/log
              
              nosuid (1.1.2.6.3):
              - Prevents setuid and setgid bits from having effect
              - /var/log contains log files, not executables
              - Prevents privilege escalation via setuid exploits
              - Attack prevention: Even if setuid binary placed in /var/log, cannot escalate
              
              noexec (1.1.2.6.4):
              - Prevents execution of binaries
              - Log files are text, not executables
              - Prevents running malicious scripts/binaries
              - Attack prevention: Even if malware written to /var/log, cannot execute
              
              relatime:
              - Reduces filesystem write overhead
              - Updates access time only when modified time newer
              - Minimal security impact, improves performance
              
              ========================================
              REMEDIATION PROCEDURE - NEW SYSTEMS
              ========================================
              
              During Installation:
              1. Proceed with system installation normally
              2. When partitioning, select "Custom" partition layout
              3. Create a separate partition for /var/log
              4. Set mount point to /var/log
              5. Configure mount options in partitioner
              6. Complete installation
              
              Post-Installation Configuration:
              1. Edit /etc/fstab and ensure proper mount options:
                 # vi /etc/fstab
                 
              2. Locate /var/log entry and verify:
                 <device> /var/log ext4 defaults,rw,nosuid,nodev,noexec,relatime 0 0
                 
              3. Apply options:
                 # mount -o remount /var/log
                 
              4. Verify configuration:
                 # findmnt -kn /var/log
                 
              5. Confirm all mount options are present:
                 # findmnt -kn /var/log | grep -E 'nosuid|nodev|noexec'
              
              ========================================
              REMEDIATION PROCEDURE - EXISTING SYSTEMS
              ========================================
              
              WARNING: This procedure affects system logging. Do it carefully
              with logging and monitoring in mind.
              
              1. Boot into rescue/emergency mode:
                 # systemctl isolate rescue.target
              
              2. Ensure auditd is not running:
                 # systemctl stop auditd
              
              3. Backup existing /var/log:
                 # mv /var/log /var/log.backup
              
              4. Create mount point:
                 # mkdir -p /var/log
                 # chmod 755 /var/log
              
              5. Mount new partition:
                 # mount /var/log
              
              6. Migrate data:
                 # cp -r /var/log.backup/* /var/log/
                 # chown -R root:root /var/log
                 # chmod 755 /var/log
              
              7. Verify mount options:
                 # findmnt -kn /var/log
              
              8. Return to multi-user mode:
                 # systemctl default
              
              9. Verify logging is functional:
                 # systemctl status syslog
                 # tail -f /var/log/messages
              
              ========================================
              VERIFICATION COMMANDS
              ========================================
              
              # Check if /var/log is separately mounted:
              findmnt -kn /var/log
              
              # Verify all mount options are set:
              findmnt -kn /var/log | grep -E 'nosuid.*nodev.*noexec'
              
              # Check each option individually:
              findmnt -kn /var/log | grep -q 'nosuid' && echo "nosuid: OK"
              findmnt -kn /var/log | grep -q 'nodev' && echo "nodev: OK"
              findmnt -kn /var/log | grep -q 'noexec' && echo "noexec: OK"
              
              # Verify /etc/fstab configuration:
              grep /var/log /etc/fstab
              
              # Check filesystem type:
              findmnt -kn /var/log -o FSTYPE
              
              # Check disk usage:
              df -h /var/log
              du -sh /var/log
              du -sh /var/log/*
              
              # List log files:
              ls -lah /var/log/
              
              # Check mount options in detail:
              mount | grep /var/log
              
              # Test log file writing:
              logger "Test message for verification"
              tail /var/log/messages
              
              ========================================
              IMPORTANT NOTES
              ========================================
              
              Partition Sizing:
              - Size depends on logging volume and retention
              - Monitor usage with: du -sh /var/log
              - Consider 5-20% of total disk space
              - Can be resized with LVM if needed
              
              Log Rotation:
              - Logrotate will continue to function normally
              - Rotated logs stay on the /var/log partition
              - No changes to logrotate configuration needed
              
              Audit Logging:
              - /var/log/audit is typically a subdirectory of /var/log
              - Audit logs are subject to same mount options
              - auditd should be stopped before migration
              - auditd needs separate considerations (1.1.2.6.4.1 usually)
              
              Performance Impact:
              - Minimal performance impact from these restrictions
              - Applications continue to log normally
              - No noticeable overhead from noexec on a log filesystem
              
              System Administration:
              - Log rotation continues to work automatically
              - Alert systems can still monitor logs
              - Remote logging (syslog) unaffected
              - Disk quota management becomes easier
              
              Rollback Procedure (if needed):
              1. Boot into emergency mode:
                 # systemctl isolate rescue.target
              
              2. Backup new partition data:
                 # mv /var/log /var/log.new
              
              3. Restore original data:
                 # mv /var/log.backup /var/log
              
              4. Edit /etc/fstab and remove separate partition:
                 # vi /etc/fstab
              
              5. Return to normal mode:
                 # systemctl default
              
              ========================================
              COMPLIANCE VERIFICATION
              ========================================
              
              For compliance checks, verify:
              1. /var/log is on separate partition (Level 2)
              2. nodev option is set (Level 1)
              3. nosuid option is set (Level 1)
              4. noexec option is set (Level 1)
              
              All four should appear in mount output:
              # findmnt -kn /var/log
              Should show: nodev,nosuid,noexec
              
              ========================================
              REFERENCES
              ========================================
              
              CIS Benchmarks:
              - Control 1.1.2.6.1-4: /var/log partition configuration
              - Profile Level: 1 & 2 (Server/Workstation)
              - CCI-001164, CCI-001464
              
              NIST References:
              - NIST SP 800-53 Rev. 5: CM-6, CM-7, AC-3, MP-2
              - NIST SP 800-53A :: CM-6.1 (iv)
              
              STIG References:
              - RHEL 8 STIG:
                - V-230293 (Separate partition)
                - V-230514 (nodev option)
                - V-230515 (nosuid option)
                - V-230516 (noexec option)
              
              - RHEL 9 STIG:
                - RHEL-09-231050 (nodev)
                - RHEL-09-231060 (nosuid)
                - RHEL-09-231065 (noexec)
              
              - ALMA 9:
                - ALMA-09-025600 (nodev)
                - ALMA-09-025620 (nosuid)
                - ALMA-09-025630 (noexec)
              
              Documentation:
              - http://tldp.org/HOWTO/LVM-HOWTO/
              - fstab(5) manual page
              - mount(8) manual page
              - rsyslog documentation
              - auditd documentation
              - CIS Red Hat Enterprise Linux 8 Benchmark
              
              CIS Controls:
              - v8: 8.3 Ensure Adequate Audit Log Storage
              - v8: 3.3 Configure Data Access Control Lists
              - v7: 6.4 Ensure adequate storage for logs
              - v7: 14.6 Protect Information through Access Control Lists
            owner: root
            group: root
            mode: '0600'
          when: var_log_partition_check_exec.rc == 0

    - name: "1.2.1.1 Ensure GPG keys are configured (Manual)"
      block:
        - name: "Check GPG key URLs configuration"
          shell: grep -r gpgkey /etc/yum.repos.d/* /etc/dnf/dnf.conf 2>/dev/null
          register: gpg_keys_config
          changed_when: false
          failed_when: false

        - name: "List installed GPG keys"
          shell: |
            for RPM_PACKAGE in $(rpm -q gpg-pubkey 2>/dev/null); do
              echo "RPM: ${RPM_PACKAGE}"
              RPM_SUMMARY=$(rpm -q --queryformat "%{SUMMARY}" "${RPM_PACKAGE}")
              RPM_PACKAGER=$(rpm -q --queryformat "%{PACKAGER}" "${RPM_PACKAGE}")
              RPM_KEY_ID=$(rpm -q --queryformat "%{VERSION}" "${RPM_PACKAGE}")
              echo "Packager: ${RPM_PACKAGER}"
              echo "Summary: ${RPM_SUMMARY}"
              echo "Key ID: ${RPM_KEY_ID}"
              echo ""
            done
          register: installed_gpg_keys
          changed_when: false
          failed_when: false

        - name: "List locally available GPG keys"
          shell: |
            for PACKAGE in $(find /etc/pki/rpm-gpg/ -type f -exec rpm -qf {} \; 2>/dev/null | sort -u); do
              rpm -q --queryformat "%{NAME}-%{VERSION} %{PACKAGER} %{SUMMARY}\n" "${PACKAGE}" 2>/dev/null
            done
          register: local_gpg_keys
          changed_when: false
          failed_when: false

        - name: "Display GPG keys configuration status"
          debug:
            msg: |
              Control 1.2.1.1 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Manual verification required
              
              GPG Key URLs Configuration:
              {{ gpg_keys_config.stdout if gpg_keys_config.stdout else 'No GPG keys found' }}
              
              Installed GPG Keys:
              {{ installed_gpg_keys.stdout if installed_gpg_keys.stdout else 'No installed GPG keys' }}
              
              Locally Available GPG Keys:
              {{ local_gpg_keys.stdout if local_gpg_keys.stdout else 'No local GPG keys found' }}
              
              ACTION REQUIRED:
              - Verify all GPG keys match your organization's policy
              - Check repository configurations in /etc/yum.repos.d/
              - Verify key sources are from trusted repositories
              - Confirm key IDs match official Red Hat/distribution sources

        - name: "Create GPG keys verification report"
          copy:
            dest: /root/CIS_1.2.1.1_gpg_keys_audit.txt
            content: |
              CIS Control 1.2.1.1 - Ensure GPG keys are configured
              Generated: {{ ansible_date_time.iso8601 }}
              
              ========================================
              GPG KEYS AUDIT REPORT
              ========================================
              
              This is a MANUAL control requiring verification that:
              1. All GPG keys are from trusted sources
              2. Key configurations are correct
              3. No unauthorized keys are installed
              
              Repository GPG Key Configuration:
              {{ gpg_keys_config.stdout }}
              
              Installed GPG Keys:
              {{ installed_gpg_keys.stdout }}
              
              Locally Available GPG Keys:
              {{ local_gpg_keys.stdout }}
              
              ========================================
              VERIFICATION CHECKLIST
              ========================================
              
              [ ] All GPG keys have URLs pointing to valid locations
              [ ] Keys are from official distribution sources
              [ ] Key IDs match official documentation
              [ ] No unauthorized or suspicious keys installed
              [ ] Repository configurations match site policy
              
              ========================================
              REFERENCES
              ========================================
              
              - NIST SP 800-53 Rev. 5: SI-2
              - Fedora security page: https://getfedora.org/security/
              - Red Hat GPG Key information
            owner: root
            group: root
            mode: '0600'

    - name: "1.2.1.2 Ensure gpgcheck is configured (Automated)"
      block:
        - name: "Check global gpgcheck configuration"
          shell: grep -Pi -- '^\h*gpgcheck\h*=\h*(1|true|yes)\b' /etc/dnf/dnf.conf
          register: dnf_gpgcheck_global
          changed_when: false
          failed_when: false

        - name: "Check per-repository gpgcheck disabled"
          shell: grep -Pris -- '^\h*gpgcheck\h*=\h*(0|[2-9]|[1-9][0-9]+|false|no)\b' /etc/yum.repos.d/
          register: repo_gpgcheck_disabled
          changed_when: false
          failed_when: false

        - name: "Set global gpgcheck in /etc/dnf/dnf.conf"
          lineinfile:
            path: /etc/dnf/dnf.conf
            section: main
            option: gpgcheck
            value: '1'
            state: present
            create: no

        - name: "Fix gpgcheck in repository files"
          shell: find /etc/yum.repos.d/ -name "*.repo" -exec sed -i 's/^gpgcheck\s*=\s*.*/gpgcheck=1/' {} \;
          changed_when: false

        - name: "Verify global gpgcheck after remediation"
          shell: grep -Pi -- '^\h*gpgcheck\h*=\h*(1|true|yes)\b' /etc/dnf/dnf.conf
          register: dnf_gpgcheck_verify
          changed_when: false
          failed_when: false

        - name: "Verify repo gpgcheck after remediation"
          shell: grep -Pris -- '^\h*gpgcheck\h*=\h*(0|[2-9]|[1-9][0-9]+|false|no)\b' /etc/yum.repos.d/
          register: repo_gpgcheck_verify
          changed_when: false
          failed_when: false

        - name: "Display gpgcheck configuration status"
          debug:
            msg: |
              Control 1.2.1.2 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              
              Global Configuration Status:
              - Current setting: {{ 'CONFIGURED' if dnf_gpgcheck_verify.stdout else 'NOT CONFIGURED' }}
              - Expected: gpgcheck=1
              - Current: {{ dnf_gpgcheck_verify.stdout if dnf_gpgcheck_verify.stdout else 'Not found' }}
              
              Repository Configuration Status:
              - Disabled instances found: {{ repo_gpgcheck_disabled.stdout_lines | length }}
              - After remediation: {{ repo_gpgcheck_verify.stdout_lines | length }}
              
              PURPOSE:
              - Ensures RPM package signatures are verified before installation
              - Protects against installation of tampered or malicious packages
              - Required for system security and integrity

        - name: "Create gpgcheck configuration documentation"
          copy:
            dest: /root/CIS_1.2.1.2_gpgcheck_configuration.txt
            content: |
              CIS Control 1.2.1.2 - Ensure gpgcheck is configured
              Generated: {{ ansible_date_time.iso8601 }}
              
              ========================================
              GPGCHECK CONFIGURATION REPORT
              ========================================
              
              Global Configuration (/etc/dnf/dnf.conf):
              {{ dnf_gpgcheck_verify.stdout if dnf_gpgcheck_verify.stdout else 'NOT CONFIGURED' }}
              
              Repository Configuration Status:
              Disabled instances remaining: {{ repo_gpgcheck_verify.stdout_lines | length }}
              {% if repo_gpgcheck_verify.stdout %}
              {{ repo_gpgcheck_verify.stdout }}
              {% endif %}
              
              ========================================
              EXPECTED CONFIGURATION
              ========================================
              
              /etc/dnf/dnf.conf should contain:
              [main]
              gpgcheck=1
              
              Each /etc/yum.repos.d/*.repo should have:
              gpgcheck=1
              
              ========================================
              REMEDIATION APPLIED
              ========================================
              
              Global setting: Set to gpgcheck=1 in /etc/dnf/dnf.conf
              Repository files: Updated all gpgcheck entries to 1
              
              ========================================
              COMPLIANCE STATUS
              ========================================
              
              Global gpgcheck: {{ 'COMPLIANT' if dnf_gpgcheck_verify.stdout else 'NON-COMPLIANT' }}
              Repository gpgcheck: {{ 'COMPLIANT' if not repo_gpgcheck_verify.stdout else 'NON-COMPLIANT' }}
              
              ========================================
              REFERENCES
              ========================================
              
              - NIST SP 800-53 Revision 5: CM-14
              - STIG ID: RHEL-08-010370 | SV-230264r1017377 | CAT I
              - STIG ID: RHEL-09-214015 | SV-257820r1044878 | CAT I
              - STIG ID: RHEL-09-214025 | SV-257822r1044880 | CAT I
              
              CIS Controls:
              - v8: 7.3 Perform Automated Operating System Patch Management
              - v8: 7.4 Perform Automated Application Patch Management
              - v7: 3.4 Deploy Automated Operating System Patch Management Tools
            owner: root
            group: root
            mode: '0600'

    - name: "1.2.1.3 Ensure repo_gpgcheck is globally activated (Manual)"
      block:
        - name: "Check global repo_gpgcheck configuration"
          shell: grep ^repo_gpgcheck /etc/dnf/dnf.conf
          register: repo_gpgcheck_config
          changed_when: false
          failed_when: false

        - name: "Check per-repository repo_gpgcheck disabled"
          shell: grep -l "repo_gpgcheck=0" /etc/yum.repos.d/* 2>/dev/null
          register: repo_gpgcheck_disabled_files
          changed_when: false
          failed_when: false

        - name: "Display repo_gpgcheck configuration status"
          debug:
            msg: |
              Control 1.2.1.3 Status:
              - Profile Level: Level 2 (Server/Workstation)
              - Type: Manual configuration
              - Note: Not all repositories support repo_gpgcheck
              
              Global Configuration:
              {{ repo_gpgcheck_config.stdout if repo_gpgcheck_config.stdout else 'NOT CONFIGURED' }}
              
              Repositories with repo_gpgcheck=0:
              {{ repo_gpgcheck_disabled_files.stdout if repo_gpgcheck_disabled_files.stdout else 'None found (expected if repos do not support it)' }}
              
              ACTION REQUIRED:
              - Research which repositories support repo_gpgcheck
              - For supporting repos, set repo_gpgcheck=1
              - Be cautious: enabling on unsupporting repos will break package installation
              - Verify site policy before applying

        - name: "Create repo_gpgcheck configuration guidance"
          copy:
            dest: /root/CIS_1.2.1.3_repo_gpgcheck_guidance.txt
            content: |
              CIS Control 1.2.1.3 - Ensure repo_gpgcheck is globally activated
              Generated: {{ ansible_date_time.iso8601 }}
              
              ========================================
              REPO_GPGCHECK CONFIGURATION GUIDANCE
              ========================================
              
              This is a MANUAL control that requires careful research.
              
              Current Global Configuration:
              {{ repo_gpgcheck_config.stdout if repo_gpgcheck_config.stdout else 'NOT CONFIGURED' }}
              
              Repositories with repo_gpgcheck=0:
              {{ repo_gpgcheck_disabled_files.stdout if repo_gpgcheck_disabled_files.stdout else 'None found' }}
              
              ========================================
              IMPORTANT WARNINGS
              ========================================
              
              1. NOT ALL REPOSITORIES SUPPORT repo_gpgcheck
              2. ENABLING IT ON UNSUPPORTING REPOS WILL BREAK PACKAGE INSTALLATION
              3. RESEARCH IS REQUIRED BEFORE APPLYING
              
              ========================================
              REMEDIATION PROCEDURE
              ========================================
              
              Step 1: Research Repository Support
              - Check official documentation for each configured repository
              - Verify which repositories in your environment support repo_gpgcheck
              - Document findings in site policy
              
              Step 2: Global Configuration (if supported)
              Edit /etc/dnf/dnf.conf and add to [main] section:
              [main]
              repo_gpgcheck=1
              
              Step 3: Per-Repository Configuration
              For each repository that supports repo_gpgcheck:
              Edit /etc/yum.repos.d/repository.repo and set:
              repo_gpgcheck=1
              
              For repositories that do NOT support repo_gpgcheck:
              Explicitly set:
              repo_gpgcheck=0
              
              Step 4: Verification
              Test package installation:
              dnf install test-package
              
              Step 5: Monitoring
              Watch for any package installation failures
              Review system logs for gpgcheck errors
              
              ========================================
              CHECKING REPOSITORY SUPPORT
              ========================================
              
              To check if a repository supports repo_gpgcheck:
              
              1. Look at repository documentation online
              2. Try enabling it:
                 # dnf repolist
              
              3. If package installation fails:
                 Set repo_gpgcheck=0 for that repository
              
              4. If it works:
                 Keep repo_gpgcheck=1 for that repository
              
              ========================================
              KNOWN REPOSITORY COMPATIBILITY
              ========================================
              
              Repositories that MAY NOT support repo_gpgcheck:
              - Red Hat official repositories (per documentation)
              - Some third-party repositories
              - Custom/internal repositories
              
              Repositories that typically support it:
              - Fedora repositories
              - Community-maintained repositories
              
              ========================================
              REFERENCES
              ========================================
              
              - NIST SP 800-53 Rev. 5: SI-2
              - CIS Controls v8: 7.3, 7.4
              - Documentation: https://docs.fedoraproject.org/en-US/quick-docs/repositories/
            owner: root
            group: root
            mode: '0600'

    - name: "1.2.1.4 Ensure package manager repositories are configured (Manual)"
      block:
        - name: "List configured repositories"
          shell: dnf repolist
          register: dnf_repolist
          changed_when: false
          failed_when: false

        - name: "Check repository configuration files"
          shell: cat /etc/yum.repos.d/*.repo 2>/dev/null
          register: repo_configs
          changed_when: false
          failed_when: false

        - name: "Display repository configuration status"
          debug:
            msg: |
              Control 1.2.1.4 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Manual verification required
              
              Configured Repositories:
              {{ dnf_repolist.stdout if dnf_repolist.stdout else 'No repositories found' }}
              
              ACTION REQUIRED:
              - Verify repositories match site policy
              - Ensure no unauthorized repositories are configured
              - Check that all necessary repositories are present
              - Verify repository URLs and settings are correct
              - Ensure GPG keys are configured for each repository

        - name: "Create repository configuration documentation"
          copy:
            dest: /root/CIS_1.2.1.4_repository_configuration.txt
            content: |
              CIS Control 1.2.1.4 - Ensure package manager repositories are configured
              Generated: {{ ansible_date_time.iso8601 }}
              
              ========================================
              REPOSITORY CONFIGURATION REPORT
              ========================================
              
              Configured Repositories:
              {{ dnf_repolist.stdout }}
              
              Repository Configuration Files:
              {{ repo_configs.stdout if repo_configs.stdout else 'No configuration files found' }}
              
              ========================================
              VERIFICATION CHECKLIST
              ========================================
              
              [ ] All configured repositories are from trusted sources
              [ ] Repository URLs are correct and accessible
              [ ] GPG keys are configured for all repositories
              [ ] gpgcheck is enabled (see control 1.2.1.2)
              [ ] Repositories match organization policy
              [ ] No unauthorized repositories are configured
              [ ] Repository metadata is current
              
              ========================================
              REPOSITORY CONFIGURATION GUIDELINES
              ========================================
              
              Typical Red Hat Enterprise Linux repositories:
              - rhel-*-baseos-rpms (base operating system)
              - rhel-*-appstream-rpms (application streams)
              - rhel-*-highavailability-rpms (HA)
              - rhel-*-extras-rpms (extras)
              - rhel-*-supplementary-rpms (supplementary)
              
              Standard attributes in /etc/yum.repos.d/*.repo:
              [repository-id]
              name=Repository Name
              baseurl=http://repository.url/path
              enabled=1
              gpgcheck=1
              gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-RHEL-*
              
              ========================================
              REMEDIATION STEPS
              ========================================
              
              Step 1: Review current repositories
              # dnf repolist
              # cat /etc/yum.repos.d/*.repo
              
              Step 2: Add official repositories (if missing)
              For RHEL systems registered with Red Hat:
              # subscription-manager repos --enable=rhel-8-baseos-rpms
              # subscription-manager repos --enable=rhel-8-appstream-rpms
              
              Step 3: Disable unnecessary repositories
              # dnf config-manager --set-disabled <repository-id>
              
              Step 4: Enable required repositories
              # dnf config-manager --set-enabled <repository-id>
              
              Step 5: Verify configuration
              # dnf repolist all
              # dnf clean all
              # dnf repolist
              
              Step 6: Test package installation
              # dnf update --assumeno
              
              ========================================
              IMPORTANT CONSIDERATIONS
              ========================================
              
              Third-party repositories:
              - Use with caution and proper evaluation
              - Verify GPG keys from trusted sources
              - Ensure compatibility with system
              - Keep updated with vendor security notices
              - Consider security implications
              
              Repository management:
              - Regularly review configured repositories
              - Remove obsolete or unused repositories
              - Keep repository metadata current
              - Monitor for suspicious repositories
              - Align with change management process
              
              Network connectivity:
              - Ensure systems can reach repository URLs
              - Configure proxy if necessary
              - Test repository connectivity
              - Plan for repository maintenance windows
              
              ========================================
              TROUBLESHOOTING
              ========================================
              
              If repositories are unavailable:
              1. Test network connectivity to repository URL
              2. Check firewall rules
              3. Verify proxy configuration (if applicable)
              4. Review repository URL syntax
              5. Check for DNS resolution issues
              
              If package installation fails:
              1. Run: dnf clean all
              2. Update metadata: dnf makecache
              3. Verify repository configuration
              4. Check GPG keys: rpm -q gpg-pubkey
              5. Review dnf logs: /var/log/dnf.log
              
              ========================================
              REFERENCES
              ========================================
              
              - NIST SP 800-53 Rev. 5: SI-2
              - Documentation: https://docs.fedoraproject.org/en-US/quick-docs/repositories/
              - Red Hat Subscription Management documentation
              - DNF package manager documentation
              
              CIS Controls:
              - v8: 7.3 Perform Automated Operating System Patch Management
              - v8: 7.4 Perform Automated Application Patch Management
              - v7: 3.4 Deploy Automated Operating System Patch Management Tools
              - v7: 3.5 Deploy Automated Software Patch Management Tools
            owner: root
            group: root
            mode: '0600'

    - name: "1.2.1.5 Ensure weak dependencies are configured (Automated)"
      block:
        - name: "Check current install_weak_deps configuration"
          shell: grep -Pi -- '^\h*install_weak_deps\h*=\h*(0|false|no)\b' /etc/dnf/dnf.conf
          register: weak_deps_config_current
          changed_when: false
          failed_when: false

        - name: "Check if install_weak_deps exists in dnf.conf"
          shell: grep -Pq '^install_weak_deps' /etc/dnf/dnf.conf
          register: weak_deps_exists
          changed_when: false
          failed_when: false

        - name: "Set install_weak_deps to disabled (if exists)"
          shell: sed -i 's/^install_weak_deps\s*=\s*.*/install_weak_deps=0/' /etc/dnf/dnf.conf
          when: weak_deps_exists.rc == 0
          changed_when: false

        - name: "Add install_weak_deps if not present"
          shell: |
            if ! grep -Pq '^install_weak_deps' /etc/dnf/dnf.conf; then
              echo "" >> /etc/dnf/dnf.conf
              echo "install_weak_deps=0" >> /etc/dnf/dnf.conf
            fi
          changed_when: false

        - name: "Verify install_weak_deps after remediation"
          shell: grep -Pi -- '^\h*install_weak_deps\h*=\h*(0|false|no)\b' /etc/dnf/dnf.conf
          register: weak_deps_config_verify
          changed_when: false
          failed_when: false

        - name: "Display install_weak_deps configuration status"
          debug:
            msg: |
              Control 1.2.1.5 Status:
              - Profile Level: Level 2 (Server/Workstation)
              - Type: Automated remediation
              
              Configuration Status:
              - Current setting: {{ 'CONFIGURED' if weak_deps_config_verify.stdout else 'NOT CONFIGURED' }}
              - Expected: install_weak_deps=0, install_weak_deps=false, or install_weak_deps=no
              - Current: {{ weak_deps_config_verify.stdout if weak_deps_config_verify.stdout else 'Not found' }}
              
              PURPOSE:
              - Reduces potential attack surface by not installing unnecessary packages
              - Weak dependencies provide additional features not required for minimal functionality
              - Limits installation to hard dependencies only

        - name: "Create install_weak_deps configuration documentation"
          copy:
            dest: /root/CIS_1.2.1.5_weak_dependencies_configuration.txt
            content: |
              CIS Control 1.2.1.5 - Ensure weak dependencies are configured
              Generated: {{ ansible_date_time.iso8601 }}
              
              ========================================
              WEAK DEPENDENCIES CONFIGURATION REPORT
              ========================================
              
              Current Configuration Status:
              {{ weak_deps_config_verify.stdout if weak_deps_config_verify.stdout else 'NOT CONFIGURED - USING DEFAULT (TRUE)' }}
              
              ========================================
              RPM DEPENDENCY LEVELS
              ========================================
              
              1. HARD DEPENDENCIES (Requires / Provides)
                 - Packages which MUST be installed for minimal functionality
                 - Required for application to function
                 - Example: kernel, glibc, systemd
              
              2. WEAK DEPENDENCIES (Recommends / Supplements)
                 - Packages which PROVIDE ADDITIONAL FEATURES
                 - NOT required for minimal functionality
                 - Enhance user experience or add optional capabilities
                 - Example: documentation, localization files, optional plugins
              
              3. HINTS (Suggests / Enhances)
                 - Packages which offer add-ons that might be useful
                 - Completely optional
                 - Installation left to user preference
              
              ========================================
              CONTROL DESCRIPTION
              ========================================
              
              Profile Applicability: Level 2 (Server/Workstation)
              
              Rationale:
              Unless a system specifically requires the additional capabilities provided
              by weak dependencies, it is recommended that the packages are not installed
              to reduce the potential attack surface.
              
              Benefits:
              - Reduces system complexity
              - Decreases maintenance burden
              - Minimizes unnecessary network exposure
              - Reduces disk space usage
              - Improves system boot time
              - Limits potential vulnerability vectors
              
              Security Impact:
              - Every additional package is a potential vulnerability
              - Reduced package count = reduced attack surface
              - Minimal required packages = minimal risk
              - Level 2 control for systems requiring strict configuration
              
              ========================================
              EXPECTED CONFIGURATION
              ========================================
              
              /etc/dnf/dnf.conf should contain in [main] section:
              
              [main]
              install_weak_deps=0
              
              Valid values:
              - install_weak_deps=0 (disabled)
              - install_weak_deps=false (disabled)
              - install_weak_deps=no (disabled)
              
              Note: Default value is True (enabled), so explicit configuration is required.
              
              ========================================
              REMEDIATION APPLIED
              ========================================
              
              The following steps have been automatically applied:
              
              1. Check if install_weak_deps already exists in /etc/dnf/dnf.conf
              2. If it exists: Update to install_weak_deps=0
              3. If not exist: Add a new line with install_weak_deps=0
              
              Configuration file: /etc/dnf/dnf.conf
              Configuration option: install_weak_deps=0
              
              ========================================
              COMPLIANCE STATUS
              ========================================
              
              install_weak_deps: {{ 'COMPLIANT' if weak_deps_config_verify.stdout else 'CHECK MANUALLY' }}
              
              All related settings verified: {{ 'YES' if weak_deps_config_verify.stdout else 'NO - REQUIRES VERIFICATION' }}
              
              ========================================
              VERIFICATION COMMANDS
              ========================================
              
              # Check current configuration
              grep install_weak_deps /etc/dnf/dnf.conf
              
              # Verify it's set to disabled
              grep -Pi -- '^\h*install_weak_deps\h*=\h*(0|false|no)\b' /etc/dnf/dnf.conf
              
              # Test by checking what would be installed
              dnf install <package-name> --assumeno
              
              # View dnf configuration
              dnf config-manager --dump
              
              ========================================
              IMPACT ON SYSTEM OPERATIONS
              ========================================
              
              Positive Impacts:
              - Smaller base installation
              - Fewer potential security issues
              - Faster initial package installation
              - Reduced disk space requirements
              - Lower maintenance overhead
              
              Potential Considerations:
              - Some packages may not work optimally without weak dependencies
              - Documentation packages won't be automatically installed
              - Localization files won't be automatically included
              - Additional manual package installation may be needed for special use cases
              
              ========================================
              PACKAGE INSTALLATION BEHAVIOR
              ========================================
              
              With install_weak_deps=0 (RECOMMENDED):
              - Only hard dependencies are installed
              - Weak dependencies are NOT installed
              - Additional features may require manual installation
              - System is more minimal and focused
              
              With install_weak_deps=1 (DEFAULT):
              - Hard dependencies are installed
              - Weak dependencies are automatically installed
              - More complete but larger installation
              - May include unnecessary packages
              
              ========================================
              EXAMPLES OF WEAK DEPENDENCIES
              ========================================
              
              Documentation packages:
              - man-pages
              - info pages
              - documentation files
              
              Localization files:
              - locale files
              - language support
              - translation databases
              
              Optional features:
              - additional database drivers
              - optional protocol support
              - alternative implementations
              - supplementary tools
              
              ========================================
              MANAGEMENT AND CONFIGURATION
              ========================================
              
              Manual configuration steps:
              
              1. Edit /etc/dnf/dnf.conf:
                 # vi /etc/dnf/dnf.conf
              
              2. Locate the [main] section (usually at the top)
              
              3. Add or modify the line:
                 install_weak_deps=0
              
              4. Save and exit editor
              
              5. Verify the change:
                 # grep install_weak_deps /etc/dnf/dnf.conf
              
              Installing packages with weak dependencies:
              
              If a package requires weak dependencies:
              - Install manually: dnf install <package-name>
              - Explicitly request: dnf install <package-name> <dependency-name>
              - Review dependencies: dnf deplist <package-name>
              
              ========================================
              TROUBLESHOOTING ISSUES
              ========================================
              
              If a package installation fails after disabling weak dependencies:
              
              1. Check what dependencies are missing:
                 # dnf deplist <package-name>
              
              2. Install missing dependencies explicitly:
                 # dnf install <dependency-name>
              
              3. Or install the package with weak dependencies:
                 # dnf install --setopt=install_weak_deps=1 <package-name>
              
              4. Review package requirements:
                 # rpm -qR <package-name>
              
              ========================================
              AUDIT PROCEDURES
              ========================================
              
              Regular compliance verification:
              
              1. Check configuration exists and is correct:
                 # grep -Pi -- '^\h*install_weak_deps\h*=\h*(0|false|no)\b' /etc/dnf/dnf.conf
              
              2. If no output, configuration is NOT compliant
              
              3. Review installed packages for unnecessary items:
                 # rpm -qa | wc -l
              
              4. Compare against reference system:
                 # dnf repoquery --installed
              
              ========================================
              REFERENCES
              ========================================
              
              Documentation:
              - https://docs.fedoraproject.org/en-US/packaging-guidelines/WeakDependencies/
              - DNF configuration documentation
              - RPM packaging specification
              
              Related Controls:
              - 1.2.1.1: Ensure GPG keys are configured
              - 1.2.1.2: Ensure gpgcheck is configured
              - 1.2.1.3: Ensure repo_gpgcheck is globally activated
              - 1.2.1.4: Ensure package manager repositories are configured
              
              CIS Controls:
              - v8: 4.8 Uninstall or Disable Unnecessary Services on Enterprise Assets
              - v7: 9.2 Ensure Only Approved Ports, Protocols and Services Are Running
              
              ========================================
              COMPLIANCE NOTES
              ========================================
              
              This is a Level 2 control, meaning:
              - Should be applied to systems requiring strong security
              - May have operational implications in some environments
              - Requires planning and testing before implementation
              - Coordination with system users may be necessary
              
              Once configured:
              - Verify no system breakage occurs
              - Document any necessary manual installations
              - Update deployment procedures
              - Inform users about new package behavior
            owner: root
            group: root
            mode: '0600'

    - name: "1.3.1.1 Ensure SELinux is installed (Automated)"
      block:
        - name: "Check if libselinux is installed"
          shell: rpm -q libselinux
          register: libselinux_check
          changed_when: false
          failed_when: false

        - name: "Install libselinux if not present"
          dnf:
            name: libselinux
            state: present
          when: libselinux_check.rc != 0

        - name: "Verify libselinux installation"
          shell: rpm -q libselinux
          register: libselinux_verify
          changed_when: false
          failed_when: false

        - name: "Display SELinux installation status"
          debug:
            msg: |
              Control 1.3.1.1 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - SELinux installed: {{ 'YES' if libselinux_verify.rc == 0 else 'NO' }}
              - Package: {{ libselinux_verify.stdout if libselinux_verify.stdout else 'Not found' }}

    - name: "1.3.1.2 Ensure SELinux is not disabled in bootloader configuration (Automated)"
      block:
        - name: "Check for selinux=0 or enforcing=0 in grub config"
          shell: grubby --info=ALL | grep -Po '(selinux|enforcing)=0\b'
          register: grub_selinux_disabled
          changed_when: false
          failed_when: false

        - name: "Check for selinux=0 or enforcing=0 in boot/grub2"
          shell: grep -Prs -- '^\h*([^#\n\r]+\h+)?kernelopts=([^#\n\r]+\h+)?(selinux|enforcing)=0\b' /boot/grub2 /boot/efi 2>/dev/null
          register: grub2_selinux_disabled
          changed_when: false
          failed_when: false

        - name: "Remove selinux=0 and enforcing=0 from grub"
          shell: grubby --update-kernel ALL --remove-args "selinux=0 enforcing=0"
          when: grub_selinux_disabled.stdout or grub2_selinux_disabled.stdout
          changed_when: false

        - name: "Fix selinux=0 and enforcing=0 if created by grub2-mkconfig"
          shell: |
            if grep -Prsq -- '^\h*([^#\n\r]+\h+)?kernelopts=([^#\n\r]+\h+)?(selinux|enforcing)=0\b' /boot/grub2 /boot/efi; then
              grub2-mkconfig -o "$(grep -Prl -- '\h*([^#\n\r]+\h+)?kernelopts=([^#\n\r]+\h+)?(selinux|enforcing)=0\b' /boot/grub2 /boot/efi 2>/dev/null | head -1)"
            fi
          changed_when: false

        - name: "Verify selinux is not disabled in grub config"
          shell: grubby --info=ALL | grep -Po '(selinux|enforcing)=0\b'
          register: grub_selinux_verify
          changed_when: false
          failed_when: false

        - name: "Display bootloader SELinux status"
          debug:
            msg: |
              Control 1.3.1.2 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - SELinux disabled in bootloader: {{ 'YES' if grub_selinux_verify.stdout else 'NO' }}
              - Status: {{ 'COMPLIANT' if not grub_selinux_verify.stdout else 'NON-COMPLIANT' }}

    - name: "1.3.1.3 Ensure SELinux policy is configured (Automated)"
      block:
        - name: "Check current SELinux policy"
          shell: grep -Psi -- '^\h*SELINUXTYPE\h*=\h*(targeted|mls)\b' /etc/selinux/config
          register: selinux_policy_check
          changed_when: false
          failed_when: false

        - name: "Set SELinux policy to targeted if not configured"
          lineinfile:
            path: /etc/selinux/config
            regexp: '^\s*SELINUXTYPE\s*='
            line: 'SELINUXTYPE=targeted'
            state: present
            create: yes
          when: not selinux_policy_check.stdout

        - name: "Verify SELinux policy configuration"
          shell: grep -Psi -- '^\h*SELINUXTYPE\h*=\h*(targeted|mls)\b' /etc/selinux/config
          register: selinux_policy_verify
          changed_when: false
          failed_when: false

        - name: "Display SELinux policy status"
          debug:
            msg: |
              Control 1.3.1.3 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - SELinux policy configured: {{ 'YES' if selinux_policy_verify.stdout else 'NO' }}
              - Policy: {{ selinux_policy_verify.stdout if selinux_policy_verify.stdout else 'Not found' }}

    - name: "1.3.1.4 Ensure the SELinux mode is not disabled (Automated)"
      block:
        - name: "Check SELinux configured mode"
          shell: grep -Pi -- '^\h*SELINUX=(enforcing|permissive)\b' /etc/selinux/config
          register: selinux_config_mode
          changed_when: false
          failed_when: false

        - name: "Check SELinux current running mode"
          shell: getenforce
          register: selinux_running_mode
          changed_when: false
          failed_when: false

        - name: "Set SELinux to enforcing mode in config if disabled"
          lineinfile:
            path: /etc/selinux/config
            regexp: '^\s*SELINUX\s*='
            line: 'SELINUX=enforcing'
            state: present
          when: not selinux_config_mode.stdout

        - name: "Create autorelabel file if SELinux is disabled"
          file:
            path: /.autorelabel
            state: touch
          when: selinux_running_mode.stdout == "Disabled"

        - name: "Display SELinux mode status"
          debug:
            msg: |
              Control 1.3.1.4 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - SELinux configured mode: {{ selinux_config_mode.stdout if selinux_config_mode.stdout else 'Not found' }}
              - SELinux running mode: {{ selinux_running_mode.stdout }}
              - Status: {{ 'COMPLIANT' if selinux_running_mode.stdout != 'Disabled' else 'NON-COMPLIANT - REBOOT REQUIRED' }}

    - name: "1.3.1.5 Ensure the SELinux mode is enforcing (Automated)"
      block:
        - name: "Check SELinux configured mode is enforcing"
          shell: grep -Pi -- '^\h*SELINUX=enforcing\b' /etc/selinux/config
          register: selinux_enforcing_config
          changed_when: false
          failed_when: false

        - name: "Check SELinux running mode is enforcing"
          shell: getenforce
          register: selinux_enforcing_mode
          changed_when: false
          failed_when: false

        - name: "Set SELinux to enforcing in configuration"
          lineinfile:
            path: /etc/selinux/config
            regexp: '^\s*SELINUX\s*='
            line: 'SELINUX=enforcing'
            state: present
          when: not selinux_enforcing_config.stdout

        - name: "Set SELinux to enforcing mode (if not disabled)"
          shell: setenforce 1
          when: selinux_enforcing_mode.stdout != "Disabled" and selinux_enforcing_mode.stdout != "Enforcing"
          changed_when: false

        - name: "Create autorelabel file if SELinux is disabled"
          file:
            path: /.autorelabel
            state: touch
          when: selinux_enforcing_mode.stdout == "Disabled"

        - name: "Verify SELinux enforcing mode"
          shell: getenforce
          register: selinux_enforcing_verify
          changed_when: false
          failed_when: false

        - name: "Display SELinux enforcing mode status"
          debug:
            msg: |
              Control 1.3.1.5 Status:
              - Profile Level: Level 2 (Server/Workstation)
              - Type: Automated remediation
              - SELinux enforcing configured: {{ 'YES' if selinux_enforcing_config.stdout else 'NO' }}
              - SELinux running mode: {{ selinux_enforcing_verify.stdout }}
              - Status: {{ 'COMPLIANT' if selinux_enforcing_verify.stdout == 'Enforcing' else 'NON-COMPLIANT' }}

    - name: "1.3.1.6 Ensure no unconfined services exist (Manual)"
      block:
        - name: "Check for unconfined services"
          shell: ps -eZ | grep unconfined_service_t
          register: unconfined_services
          changed_when: false
          failed_when: false

        - name: "Display unconfined services audit results"
          debug:
            msg: |
              Control 1.3.1.6 Status:
              - Profile Level: Level 2 (Server/Workstation)
              - Type: Manual review required
              - Unconfined services found: {{ 'YES' if unconfined_services.stdout else 'NO' }}
              
              {% if unconfined_services.stdout %}
              Unconfined Services Found:
              {{ unconfined_services.stdout }}
              
              ACTION REQUIRED:
              - Investigate unconfined processes
              - Create custom SELinux policy if needed
              - See documentation for policy creation procedure
              {% endif %}

        - name: "Create unconfined services audit report"
          copy:
            dest: /root/CIS_1.3.1.6_unconfined_services_audit.txt
            content: |
              CIS Control 1.3.1.6 - Ensure no unconfined services exist
              Generated: {{ ansible_date_time.iso8601 }}
              
              Unconfined Services Found:
              {% if unconfined_services.stdout %}
              {{ unconfined_services.stdout }}
              {% else %}
              None detected
              {% endif %}
            owner: root
            group: root
            mode: '0600'

    - name: "1.3.1.7 Ensure the MCS Translation Service (mcstrans) is not installed (Automated)"
      block:
        - name: "Check if mcstrans is installed"
          shell: rpm -q mcstrans
          register: mcstrans_check
          changed_when: false
          failed_when: false

        - name: "Remove mcstrans if installed"
          dnf:
            name: mcstrans
            state: absent
          when: mcstrans_check.rc == 0

        - name: "Verify mcstrans is not installed"
          shell: rpm -q mcstrans
          register: mcstrans_verify
          changed_when: false
          failed_when: false

        - name: "Display mcstrans removal status"
          debug:
            msg: |
              Control 1.3.1.7 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - mcstrans installed: {{ 'YES' if mcstrans_verify.rc == 0 else 'NO' }}
              - Status: {{ 'NON-COMPLIANT' if mcstrans_verify.rc == 0 else 'COMPLIANT' }}

    - name: "1.3.1.8 Ensure SETroubleshoot is not installed (Automated)"
      block:
        - name: "Check if setroubleshoot is installed"
          shell: rpm -q setroubleshoot
          register: setroubleshoot_check
          changed_when: false
          failed_when: false

        - name: "Remove setroubleshoot if installed"
          dnf:
            name: setroubleshoot
            state: absent
          when: setroubleshoot_check.rc == 0

        - name: "Verify setroubleshoot is not installed"
          shell: rpm -q setroubleshoot
          register: setroubleshoot_verify
          changed_when: false
          failed_when: false

        - name: "Display setroubleshoot removal status"
          debug:
            msg: |
              Control 1.3.1.8 Status:
              - Profile Level: Level 1 (Server)
              - Type: Automated remediation
              - setroubleshoot installed: {{ 'YES' if setroubleshoot_verify.rc == 0 else 'NO' }}
              - Status: {{ 'NON-COMPLIANT' if setroubleshoot_verify.rc == 0 else 'COMPLIANT' }}


        - name: "1.4.1 Ensure bootloader password is set (Automated)"
          block:
        - name: "Find user.cfg file in /boot"
          shell: find /boot -type f -name 'user.cfg' ! -empty
          register: var_grub_user_cfg_path
          changed_when: false
          failed_when: false

        - name: "Verify GRUB2 password is set"
          shell: awk -F. '/^\s*GRUB2_PASSWORD=\S+/ {print $1"."$2"."$3}' {{ var_grub_user_cfg_path.stdout }}
          register: var_grub_password_check
          changed_when: false
          failed_when: false
          when: var_grub_user_cfg_path.stdout != ''

        - name: "Display bootloader password status"
          debug:
            msg: |
              Control 1.4.1 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - user.cfg found: {{ 'Yes - ' + var_grub_user_cfg_path.stdout if var_grub_user_cfg_path.stdout != '' else 'No - user.cfg not found' }}
              - GRUB2 password set: {{ 'Yes - ' + var_grub_password_check.stdout if (var_grub_password_check.stdout is defined and 'grub.pbkdf2' in var_grub_password_check.stdout) else 'No - Password not configured' }}
              - Purpose: Prevent unauthorized users from modifying boot parameters
              - Security Rationale: Stops attackers from disabling SELinux or other protections at boot
              - NIST: AC-3
              - STIG IDs: RHEL-08-010140 | SV-230234r1017053 | CAT I
              -           RHEL-08-010150 | SV-230235r1017054 | CAT I
              -           RHEL-09-212010 | SV-257787r1044836 | CAT II
              - WARNING: If password not set, run manually: grub2-setpassword
              - NOTE: grub2-setpassword requires interactive input and cannot be automated

        - name: "Warn if bootloader password is not set"
          debug:
            msg: >-
              REMEDIATION REQUIRED - Control 1.4.1:
              Bootloader password is NOT set. Run the following command manually:
              # grub2-setpassword
              This command requires interactive input and cannot be fully automated.
              After setting the password, verify with:
              # awk -F. '/^\s*GRUB2_PASSWORD=\S+/' /boot/grub2/user.cfg
          when: >
            var_grub_user_cfg_path.stdout == '' or
            (var_grub_password_check.stdout is defined and 'grub.pbkdf2' not in var_grub_password_check.stdout)

    - name: "1.4.2 Ensure access to bootloader config is configured (Automated)"
      block:
        - name: "Check if /boot/efi/EFI exists (UEFI system)"
          stat:
            path: /boot/efi/EFI
          register: var_boot_efi_exists
          changed_when: false
          failed_when: false

        - name: "Fix ownership and permissions on /boot/grub2/grub.cfg"
          file:
            path: /boot/grub2/grub.cfg
            owner: root
            group: root
            mode: '0600'
          when: not var_boot_efi_exists.stat.exists
          failed_when: false

        - name: "Fix ownership and permissions on /boot/grub2/grubenv"
          file:
            path: /boot/grub2/grubenv
            owner: root
            group: root
            mode: '0600'
          when: not var_boot_efi_exists.stat.exists
          failed_when: false

        - name: "Fix ownership and permissions on /boot/grub2/user.cfg"
          file:
            path: /boot/grub2/user.cfg
            owner: root
            group: root
            mode: '0600'
          when:
            - not var_boot_efi_exists.stat.exists
          failed_when: false

        - name: "Update /etc/fstab for EFI vFat filesystem permissions"
          replace:
            path: /etc/fstab
            regexp: '^(\s*\S+\s+/boot/efi\s+vfat\s+)(?!.*fmask=0077)(.*)$'
            replace: '\1\2,umask=0027,fmask=0077,uid=0,gid=0'
          when: var_boot_efi_exists.stat.exists
          notify: remount_boot_efi

        - name: "Verify permissions on all grub files"
          shell: |
            find /boot -type f \( -name 'grub*' -o -name 'user.cfg' \) \
            -exec stat -Lc '%n:%#a:%U:%G' {} \;
          register: var_grub_files_check
          changed_when: false
          failed_when: false

        - name: "Display bootloader config access status"
          debug:
            msg: |
              Control 1.4.2 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Boot type detected: {{ 'UEFI (/boot/efi/EFI)' if var_boot_efi_exists.stat.exists else 'BIOS (/boot/grub2)' }}
              - Grub files found and checked:
                {{ var_grub_files_check.stdout | default('No grub files found') }}
              - Remediation applied:
                {{ 'EFI - /etc/fstab updated with fmask=0077,uid=0,gid=0' if var_boot_efi_exists.stat.exists else 'BIOS - chmod 0600 and chown root:root applied to grub2 files' }}
              - Purpose: Prevent non-root users from reading or modifying boot parameters
              - Security Rationale: Protects boot config from exposure of security weaknesses
              - NIST: CM-6 b
              - STIG IDs: RHEL-09-212025 | SV-257790r991589 | CAT II
              -           RHEL-09-212030 | SV-257791r991589 | CAT II

       

        - name: "Create SELinux configuration summary"
          copy:
            dest: /root/CIS_1.3.1_selinux_summary.txt
            content: |
              CIS Controls 1.3.1.1-8 - SELinux Configuration Summary
              Generated: {{ ansible_date_time.iso8601 }}
              
              ========================================
              SELINUX CONTROLS STATUS
              ========================================
              
              1.3.1.1 - SELinux Installation
              Status: {{ 'INSTALLED' if libselinux_verify.rc == 0 else 'NOT INSTALLED' }}
              
              1.3.1.2 - SELinux Bootloader Configuration
              Status: {{ 'COMPLIANT' if not grub_selinux_verify.stdout else 'NON-COMPLIANT' }}
              
              1.3.1.3 - SELinux Policy Configuration
              Policy: {{ selinux_policy_verify.stdout if selinux_policy_verify.stdout else 'NOT CONFIGURED' }}
              
              1.3.1.4 - SELinux Mode Not Disabled
              Configured Mode: {{ selinux_config_mode.stdout if selinux_config_mode.stdout else 'Not found' }}
              Running Mode: {{ selinux_running_mode.stdout }}
              
              1.3.1.5 - SELinux Mode is Enforcing
              Configured Mode: {{ 'ENFORCING' if selinux_enforcing_config.stdout else 'NOT ENFORCING' }}
              Running Mode: {{ selinux_enforcing_verify.stdout }}
              
              1.3.1.6 - No Unconfined Services
              Unconfined Services Found: {{ 'YES' if unconfined_services.stdout else 'NO' }}
              
              1.3.1.7 - mcstrans Not Installed
              Status: {{ 'NOT INSTALLED (COMPLIANT)' if mcstrans_verify.rc != 0 else 'INSTALLED (NON-COMPLIANT)' }}
              
              1.3.1.8 - setroubleshoot Not Installed
              Status: {{ 'NOT INSTALLED (COMPLIANT)' if setroubleshoot_verify.rc != 0 else 'INSTALLED (NON-COMPLIANT)' }}
              
              ========================================
              OVERALL ASSESSMENT
              ========================================
              
              SELinux is a critical security control providing Mandatory Access Control (MAC).
              All Level 1 controls should be in place on all systems.
              Level 2 controls should be applied based on security requirements.
              
              ========================================
              NEXT STEPS
              ========================================
              
              1. Review individual control status above
              2. Address any non-compliant items
              3. For unconfined services: Create custom policies if needed
              4. Test thoroughly before promoting to production
              5. Document any policy customizations
              
              ========================================
              REFERENCES
              ========================================
              
              - NIST SP 800-53 Rev. 5: AC-3, MP-2, SC-3, SI-6
              - Red Hat SELinux Documentation
              - CIS Red Hat Enterprise Linux 8 Benchmark
            owner: root
            group: root
            mode: '0600'

    - name: "1.5.1 Ensure core file size is configured (Automated)"
      block:
        - name: "Check current core file limit configuration"
          shell: grep -Psi -- '^\h*\*\h+hard\h+core\b' /etc/security/limits.conf /etc/security/limits.d/*
          register: core_limit_check
          changed_when: false
          failed_when: false

        - name: "Comment out non-zero core hard limits"
          shell: |
            sed -ri '/^\s*[^#\n\r]+\s+hard\s+core\s+([1-9][0-9]*)/s/^/# /' /etc/security/limits.conf /etc/security/limits.d/* 2>/dev/null
          when: '" core 0" not in core_limit_check.stdout'
          changed_when: false

        - name: "Configure core file hard limit to 0"
          lineinfile:
            path: /etc/security/limits.d/60-limits.conf
            line: "* hard core 0"
            create: yes
            state: present
            owner: root
            group: root
            mode: '0644'

        - name: "Verify core file limit configuration"
          shell: grep -Psi -- '^\h*\*\h+hard\h+core\b' /etc/security/limits.conf /etc/security/limits.d/*
          register: core_limit_verify
          changed_when: false
          failed_when: false

        - name: "Display core file limit status"
          debug:
            msg: |
              Control 1.5.1 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Core file hard limit configured: {{ 'YES' if '* hard core 0' in core_limit_verify.stdout else 'NO' }}
              - Configuration file: /etc/security/limits.d/60-limits.conf
              - Current setting: {{ core_limit_verify.stdout if core_limit_verify.stdout else 'Not found' }}

        - name: "Create core file limit documentation"
          copy:
            dest: /root/CIS_1.5.1_core_file_limit.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.5.1 - Ensure core file size configured
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              A core dump includes a memory image taken at the time the operating system
              terminates an application. The memory image could contain sensitive data and
              is generally useful only for developers trying to debug problems.
              
              Setting a hard limit on core dumps prevents users from overriding the soft variable.
              
              Rationale:
              Restricting core dumps limits the risk of exposing sensitive information
              contained in the memory image. Core dumps should be disabled in production systems
              unless specifically required for debugging.
              
              Configuration Status:
              - File: /etc/security/limits.d/60-limits.conf
              - Setting: * hard core 0
              - Applied: {{ ansible_date_time.iso8601 if ansible_date_time is defined else 'Unknown' }}
              
              Verification Commands:
              1. Check configured limits:
                 # grep -Psi -- '^\h*\*\h+hard\h+core\b' /etc/security/limits.conf /etc/security/limits.d/*
              
              2. Check running limits (for current session):
                 # ulimit -c
              
              Expected Output:
              /etc/security/limits.d/60-limits.conf:* hard core 0
              
              Related NIST Controls:
              - CM-6: Configuration Settings
              - SI-2: Flaw Remediation
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - limits.conf(5) man page
              - RHEL-08-010673 (STIG)
            owner: root
            group: root
            mode: '0600'

    - name: "1.5.2 Ensure fs.protected_hardlinks is configured (Automated)"
      block:
        - name: "Check fs.protected_hardlinks running config"
          shell: sysctl fs.protected_hardlinks
          register: hardlinks_running
          changed_when: false
          failed_when: false

        - name: "Check fs.protected_hardlinks persistent config"
          shell: grep -Poi '^\h*fs\.protected_hardlinks\h*=\h*\H+\b' /etc/sysctl.d/*.conf /etc/sysctl.conf 2>/dev/null | tail -n1
          register: hardlinks_persistent
          changed_when: false
          failed_when: false

        - name: "Configure fs.protected_hardlinks = 1"
          lineinfile:
            path: /etc/sysctl.d/60-fs_sysctl.conf
            line: "fs.protected_hardlinks = 1"
            create: yes
            state: present
            owner: root
            group: root
            mode: '0644'

        - name: "Apply sysctl changes"
          shell: sysctl --system
          changed_when: false

        - name: "Verify fs.protected_hardlinks setting"
          shell: sysctl fs.protected_hardlinks
          register: hardlinks_verify
          changed_when: false
          failed_when: false

        - name: "Display fs.protected_hardlinks status"
          debug:
            msg: |
              Control 1.5.2 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - fs.protected_hardlinks configured: {{ hardlinks_verify.stdout }}
              - Persistent config file: /etc/sysctl.d/60-fs_sysctl.conf
              - Status: {{ 'COMPLIANT' if 'fs.protected_hardlinks = 1' in hardlinks_verify.stdout else 'NON-COMPLIANT' }}

        - name: "Create fs.protected_hardlinks documentation"
          copy:
            dest: /root/CIS_1.5.2_fs_protected_hardlinks.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.5.2 - Ensure fs.protected_hardlinks configured
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              fs.protected_hardlinks controls the creation of hard links to files.
              By enabling this kernel parameter, users can no longer create soft or hard
              links to files they do not own.
              
              Rationale:
              Disallowing hardlinks mitigates vulnerabilities based on unsecure file
              systems accessed by privileged programs, reducing exploitation vectors.
              
              Configuration Status:
              - Running: {{ hardlinks_running.stdout if hardlinks_running.stdout else 'Not configured' }}
              - Persistent: fs.protected_hardlinks = 1 in /etc/sysctl.d/60-fs_sysctl.conf
              - Applied: {{ ansible_date_time.iso8601 if ansible_date_time is defined else 'Unknown' }}
              
              Verification Commands:
              1. Check running configuration:
                 # sysctl fs.protected_hardlinks
              
              2. Check persistent configuration:
                 # grep -Poi 'fs\.protected_hardlinks' /etc/sysctl.d/*.conf /etc/sysctl.conf
              
              Expected Output:
              fs.protected_hardlinks = 1
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - RHEL-08-010374 (STIG)
            owner: root
            group: root
            mode: '0600'

    - name: "1.5.3 Ensure fs.protected_symlinks is configured (Automated)"
      block:
        - name: "Check fs.protected_symlinks running config"
          shell: sysctl fs.protected_symlinks
          register: symlinks_running
          changed_when: false
          failed_when: false

        - name: "Check fs.protected_symlinks persistent config"
          shell: grep -Poi '^\h*fs\.protected_symlinks\h*=\h*\H+\b' /etc/sysctl.d/*.conf /etc/sysctl.conf 2>/dev/null | tail -n1
          register: symlinks_persistent
          changed_when: false
          failed_when: false

        - name: "Configure fs.protected_symlinks = 1"
          lineinfile:
            path: /etc/sysctl.d/60-fs_sysctl.conf
            line: "fs.protected_symlinks = 1"
            create: yes
            state: present
            owner: root
            group: root
            mode: '0644'

        - name: "Apply sysctl changes"
          shell: sysctl --system
          changed_when: false

        - name: "Verify fs.protected_symlinks setting"
          shell: sysctl fs.protected_symlinks
          register: symlinks_verify
          changed_when: false
          failed_when: false

        - name: "Display fs.protected_symlinks status"
          debug:
            msg: |
              Control 1.5.3 Status:
              - Profile Level: Level 2 (Server/Workstation)
              - Type: Automated remediation
              - fs.protected_symlinks configured: {{ symlinks_verify.stdout }}
              - Persistent config file: /etc/sysctl.d/60-fs_sysctl.conf
              - Status: {{ 'COMPLIANT' if 'fs.protected_symlinks = 1' in symlinks_verify.stdout else 'NON-COMPLIANT' }}

        - name: "Create fs.protected_symlinks documentation"
          copy:
            dest: /root/CIS_1.5.3_fs_protected_symlinks.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.5.3 - Ensure fs.protected_symlinks configured
              ========================================
              
              Profile Applicability:
              - Level 2 - Server
              - Level 2 - Workstation
              
              Description:
              fs.protected_symlinks controls how the kernel handles symbolic links.
              By enabling this kernel parameter, symbolic links are permitted to be followed
              only when outside a sticky world-writable directory, or when UIDs match.
              
              Rationale:
              Disallowing symlinks mitigates vulnerabilities based on unsecure file
              systems accessed by privileged programs.
              
              Configuration Status:
              - Running: {{ symlinks_running.stdout if symlinks_running.stdout else 'Not configured' }}
              - Persistent: fs.protected_symlinks = 1 in /etc/sysctl.d/60-fs_sysctl.conf
              - Applied: {{ ansible_date_time.iso8601 if ansible_date_time is defined else 'Unknown' }}
              - Profile Level: Level 2 (Stricter security)
              
              Verification Commands:
              1. Check running configuration:
                 # sysctl fs.protected_symlinks
              
              2. Check persistent configuration:
                 # grep -Poi 'fs\.protected_symlinks' /etc/sysctl.d/*.conf /etc/sysctl.conf
              
              Expected Output:
              fs.protected_symlinks = 1
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - RHEL-08-010374 (STIG)
            owner: root
            group: root
            mode: '0600'

    - name: "1.5.4 Ensure fs.suid_dumpable is configured (Automated)"
      block:
        - name: "Check fs.suid_dumpable running config"
          shell: sysctl fs.suid_dumpable
          register: suid_dumpable_running
          changed_when: false
          failed_when: false

        - name: "Check fs.suid_dumpable persistent config"
          shell: grep -Poi '^\h*fs\.suid_dumpable\h*=\h*\H+\b' /etc/sysctl.d/*.conf /etc/sysctl.conf 2>/dev/null | tail -n1
          register: suid_dumpable_persistent
          changed_when: false
          failed_when: false

        - name: "Configure fs.suid_dumpable = 0"
          lineinfile:
            path: /etc/sysctl.d/60-fs_sysctl.conf
            line: "fs.suid_dumpable = 0"
            create: yes
            state: present
            owner: root
            group: root
            mode: '0644'

        - name: "Apply sysctl changes"
          shell: sysctl --system
          changed_when: false

        - name: "Verify fs.suid_dumpable setting"
          shell: sysctl fs.suid_dumpable
          register: suid_dumpable_verify
          changed_when: false
          failed_when: false

        - name: "Display fs.suid_dumpable status"
          debug:
            msg: |
              Control 1.5.4 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - fs.suid_dumpable configured: {{ suid_dumpable_verify.stdout }}
              - Persistent config file: /etc/sysctl.d/60-fs_sysctl.conf
              - Status: {{ 'COMPLIANT' if 'fs.suid_dumpable = 0' in suid_dumpable_verify.stdout else 'NON-COMPLIANT' }}

        - name: "Create fs.suid_dumpable documentation"
          copy:
            dest: /root/CIS_1.5.4_fs_suid_dumpable.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.5.4 - Ensure fs.suid_dumpable configured
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              fs.suid_dumpable governs whether a privileged process with setuid bit
              can generate a core dump, regardless of other configurations.
              
              Values:
              - 0 (default): SUID programs will not dump core
              - 1: All processes dump core (security risk)
              - 2: SUID processes dump to pipe handler only
              
              Rationale:
              Core dumps of privileged processes may contain sensitive in-memory data
              like password hashes or cryptographic keys.
              
              Configuration Status:
              - Running: {{ suid_dumpable_running.stdout if suid_dumpable_running.stdout else 'Not configured' }}
              - Persistent: fs.suid_dumpable = 0 in /etc/sysctl.d/60-fs_sysctl.conf
              - Applied: {{ ansible_date_time.iso8601 if ansible_date_time is defined else 'Unknown' }}
              
              Verification Commands:
              1. Check running configuration:
                 # sysctl fs.suid_dumpable
              
              2. Check persistent configuration:
                 # grep -Poi 'fs\.suid_dumpable' /etc/sysctl.d/*.conf /etc/sysctl.conf
              
              Expected Output:
              fs.suid_dumpable = 0
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
            owner: root
            group: root
            mode: '0600'

    - name: "1.5.5 Ensure kernel.dmesg_restrict is configured (Automated)"
      block:
        - name: "Check kernel.dmesg_restrict running config"
          shell: sysctl kernel.dmesg_restrict
          register: dmesg_restrict_running
          changed_when: false
          failed_when: false

        - name: "Check kernel.dmesg_restrict persistent config"
          shell: grep -Poi '^\h*kernel\.dmesg_restrict\h*=\h*\H+\b' /etc/sysctl.d/*.conf /etc/sysctl.conf 2>/dev/null | tail -n1
          register: dmesg_restrict_persistent
          changed_when: false
          failed_when: false

        - name: "Configure kernel.dmesg_restrict = 1"
          lineinfile:
            path: /etc/sysctl.d/60-kernel_sysctl.conf
            line: "kernel.dmesg_restrict = 1"
            create: yes
            state: present
            owner: root
            group: root
            mode: '0644'

        - name: "Apply sysctl changes"
          shell: sysctl --system
          changed_when: false

        - name: "Verify kernel.dmesg_restrict setting"
          shell: sysctl kernel.dmesg_restrict
          register: dmesg_restrict_verify
          changed_when: false
          failed_when: false

        - name: "Display kernel.dmesg_restrict status"
          debug:
            msg: |
              Control 1.5.5 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - kernel.dmesg_restrict configured: {{ dmesg_restrict_verify.stdout }}
              - Persistent config file: /etc/sysctl.d/60-kernel_sysctl.conf
              - Status: {{ 'COMPLIANT' if 'kernel.dmesg_restrict = 1' in dmesg_restrict_verify.stdout else 'NON-COMPLIANT' }}

        - name: "Create kernel.dmesg_restrict documentation"
          copy:
            dest: /root/CIS_1.5.5_kernel_dmesg_restrict.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.5.5 - Ensure kernel.dmesg_restrict configured
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              kernel.dmesg_restrict can be used to prevent unprivileged users from
              accessing information from the kernel's log buffer (dmesg).
              
              Rationale:
              Restricting access to the kernel message buffer limits access to only root.
              This prevents attackers from gaining additional system information from
              kernel logs that could be used in further attacks.
              
              Configuration Status:
              - Running: {{ dmesg_restrict_running.stdout if dmesg_restrict_running.stdout else 'Not configured' }}
              - Persistent: kernel.dmesg_restrict = 1 in /etc/sysctl.d/60-kernel_sysctl.conf
              - Applied: {{ ansible_date_time.iso8601 if ansible_date_time is defined else 'Unknown' }}
              
              Verification Commands:
              1. Check running configuration:
                 # sysctl kernel.dmesg_restrict
              
              2. Check persistent configuration:
                 # grep -Poi 'kernel\.dmesg_restrict' /etc/sysctl.d/*.conf /etc/sysctl.conf
              
              Expected Output:
              kernel.dmesg_restrict = 1
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - RHEL-08-010375 (STIG)
            owner: root
            group: root
            mode: '0600'

    - name: "1.5.6 Ensure kernel.kptr_restrict is configured (Automated)"
      block:
        - name: "Check kernel.kptr_restrict running config"
          shell: sysctl kernel.kptr_restrict
          register: kptr_restrict_running
          changed_when: false
          failed_when: false

        - name: "Check kernel.kptr_restrict persistent config"
          shell: grep -Poi '^\h*kernel\.kptr_restrict\h*=\h*\H+\b' /etc/sysctl.d/*.conf /etc/sysctl.conf 2>/dev/null | tail -n1
          register: kptr_restrict_persistent
          changed_when: false
          failed_when: false

        - name: "Configure kernel.kptr_restrict = 2"
          lineinfile:
            path: /etc/sysctl.d/60-kernel_sysctl.conf
            line: "kernel.kptr_restrict = 2"
            create: yes
            state: present
            owner: root
            group: root
            mode: '0644'

        - name: "Apply sysctl changes"
          shell: sysctl --system
          changed_when: false

        - name: "Verify kernel.kptr_restrict setting"
          shell: sysctl kernel.kptr_restrict
          register: kptr_restrict_verify
          changed_when: false
          failed_when: false

        - name: "Display kernel.kptr_restrict status"
          debug:
            msg: |
              Control 1.5.6 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - kernel.kptr_restrict configured: {{ kptr_restrict_verify.stdout }}
              - Acceptable values: 1 or 2 (using 2 for maximum security)
              - Persistent config file: /etc/sysctl.d/60-kernel_sysctl.conf
              - Status: {{ 'COMPLIANT' if 'kernel.kptr_restrict = 2' in kptr_restrict_verify.stdout else 'NON-COMPLIANT' }}

        - name: "Create kernel.kptr_restrict documentation"
          copy:
            dest: /root/CIS_1.5.6_kernel_kptr_restrict.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.5.6 - Ensure kernel.kptr_restrict configured
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              kernel.kptr_restrict sets whether restrictions are placed on exposing
              kernel addresses via /proc and other interfaces.
              
              Values:
              - 0: Addresses are hashed before printing (default)
              - 1: %pK kernel pointers replaced with 0's (for privileged users)
              - 2: %pK kernel pointers replaced with 0's regardless of privileges
              
              Rationale:
              Masking kernel symbols in /proc/kallsyms reduces the ability of attackers
              to learn what to attack on your system.
              
              Configuration Status:
              - Running: {{ kptr_restrict_running.stdout if kptr_restrict_running.stdout else 'Not configured' }}
              - Persistent: kernel.kptr_restrict = 2 in /etc/sysctl.d/60-kernel_sysctl.conf
              - Applied: {{ ansible_date_time.iso8601 if ansible_date_time is defined else 'Unknown' }}
              
              Verification Commands:
              1. Check running configuration:
                 # sysctl kernel.kptr_restrict
              
              2. Check persistent configuration:
                 # grep -Poi 'kernel\.kptr_restrict' /etc/sysctl.d/*.conf /etc/sysctl.conf
              
              Expected Output:
              kernel.kptr_restrict = 2 (or 1 as minimum)
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - RHEL-08-040283 (STIG)
            owner: root
            group: root
            mode: '0600'

    - name: "1.5.7 Ensure kernel.yama.ptrace_scope is configured (Automated)"
      block:
        - name: "Check kernel.yama.ptrace_scope running config"
          shell: sysctl kernel.yama.ptrace_scope
          register: ptrace_scope_running
          changed_when: false
          failed_when: false

        - name: "Check kernel.yama.ptrace_scope persistent config"
          shell: grep -Poi '^\h*kernel\.yama\.ptrace_scope\h*=\h*\H+\b' /etc/sysctl.d/*.conf /etc/sysctl.conf 2>/dev/null | tail -n1
          register: ptrace_scope_persistent
          changed_when: false
          failed_when: false

        - name: "Configure kernel.yama.ptrace_scope = 1"
          lineinfile:
            path: /etc/sysctl.d/60-kernel_sysctl.conf
            line: "kernel.yama.ptrace_scope = 1"
            create: yes
            state: present
            owner: root
            group: root
            mode: '0644'

        - name: "Apply sysctl changes"
          shell: sysctl --system
          changed_when: false

        - name: "Verify kernel.yama.ptrace_scope setting"
          shell: sysctl kernel.yama.ptrace_scope
          register: ptrace_scope_verify
          changed_when: false
          failed_when: false

        - name: "Display kernel.yama.ptrace_scope status"
          debug:
            msg: |
              Control 1.5.7 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - kernel.yama.ptrace_scope configured: {{ ptrace_scope_verify.stdout }}
              - Acceptable values: 1, 2, or 3 (using 1 for standard security)
              - Persistent config file: /etc/sysctl.d/60-kernel_sysctl.conf
              - Status: {{ 'COMPLIANT' if 'kernel.yama.ptrace_scope' in ptrace_scope_verify.stdout and '1' in ptrace_scope_verify.stdout else 'NON-COMPLIANT' }}

        - name: "Create kernel.yama.ptrace_scope documentation"
          copy:
            dest: /root/CIS_1.5.7_kernel_yama_ptrace_scope.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.5.7 - Ensure kernel.yama.ptrace_scope configured
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The ptrace() system call provides a means by which one process may observe
              and control the execution of another process (debugger functionality).
              
              Values:
              - 0: Classic ptrace permissions (unrestricted)
              - 1: Restricted ptrace (process must be related)
              - 2: Admin-only attach (requires CAP_SYS_PTRACE)
              - 3: No attach (prevents ptrace entirely, cannot be changed)
              
              Rationale:
              If one application is compromised, an attacker could attach to other running
              processes to extract credentials. Enabling restricted mode limits this ability.
              
              Configuration Status:
              - Running: {{ ptrace_scope_running.stdout if ptrace_scope_running.stdout else 'Not configured' }}
              - Persistent: kernel.yama.ptrace_scope = 1 in /etc/sysctl.d/60-kernel_sysctl.conf
              - Applied: {{ ansible_date_time.iso8601 if ansible_date_time is defined else 'Unknown' }}
              
              Verification Commands:
              1. Check running configuration:
                 # sysctl kernel.yama.ptrace_scope
              
              2. Check persistent configuration:
                 # grep -Poi 'kernel\.yama\.ptrace_scope' /etc/sysctl.d/*.conf /etc/sysctl.conf
              
              Expected Output:
              kernel.yama.ptrace_scope = 1 (or 2 for stricter security)
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - RHEL-08-040282 (STIG)
            owner: root
            group: root
            mode: '0600'

    - name: "1.5.8 Ensure kernel.randomize_va_space is configured (Automated)"
      block:
        - name: "Check kernel.randomize_va_space running config"
          shell: sysctl kernel.randomize_va_space
          register: randomize_va_running
          changed_when: false
          failed_when: false

        - name: "Check kernel.randomize_va_space persistent config"
          shell: grep -Poi '^\h*kernel\.randomize_va_space\h*=\h*\H+\b' /etc/sysctl.d/*.conf /etc/sysctl.conf 2>/dev/null | tail -n1
          register: randomize_va_persistent
          changed_when: false
          failed_when: false

        - name: "Configure kernel.randomize_va_space = 2"
          lineinfile:
            path: /etc/sysctl.d/60-kernel_sysctl.conf
            line: "kernel.randomize_va_space = 2"
            create: yes
            state: present
            owner: root
            group: root
            mode: '0644'

        - name: "Apply sysctl changes"
          shell: sysctl --system
          changed_when: false

        - name: "Verify kernel.randomize_va_space setting"
          shell: sysctl kernel.randomize_va_space
          register: randomize_va_verify
          changed_when: false
          failed_when: false

        - name: "Display kernel.randomize_va_space status"
          debug:
            msg: |
              Control 1.5.8 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - kernel.randomize_va_space configured: {{ randomize_va_verify.stdout }}
              - Persistent config file: /etc/sysctl.d/60-kernel_sysctl.conf
              - Status: {{ 'COMPLIANT' if 'kernel.randomize_va_space = 2' in randomize_va_verify.stdout else 'NON-COMPLIANT' }}

        - name: "Create kernel.randomize_va_space documentation"
          copy:
            dest: /root/CIS_1.5.8_kernel_randomize_va_space.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.5.8 - Ensure kernel.randomize_va_space configured
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              Address Space Layout Randomization (ASLR) is an exploit mitigation technique
              which randomly arranges the address space of key data areas of a process.
              
              Rationale:
              Randomly placing virtual memory regions makes it difficult to write memory
              page exploits, as memory placement will be consistently shifting.
              
              Configuration Status:
              - Running: {{ randomize_va_running.stdout if randomize_va_running.stdout else 'Not configured' }}
              - Persistent: kernel.randomize_va_space = 2 in /etc/sysctl.d/60-kernel_sysctl.conf
              - Applied: {{ ansible_date_time.iso8601 if ansible_date_time is defined else 'Unknown' }}
              - Impact: Moderate (may affect debugging, improves security significantly)
              
              Verification Commands:
              1. Check running configuration:
                 # sysctl kernel.randomize_va_space
              
              2. Check persistent configuration:
                 # grep -Poi 'kernel\.randomize_va_space' /etc/sysctl.d/*.conf /etc/sysctl.conf
              
              Expected Output:
              kernel.randomize_va_space = 2
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - RHEL-08-010430 (STIG)
            owner: root
            group: root
            mode: '0600'

    - name: "1.5.9 Ensure systemd-coredump ProcessSizeMax is configured (Automated)"
      block:
        - name: "Check systemd-coredump ProcessSizeMax configuration"
          shell: |
            awk '/\[Coredump\]/{a=1;next}/\[/{a=0}a' /etc/systemd/coredump.conf 2>/dev/null | \
            grep -Poi '^\h*ProcessSizeMax\h*=\h*\H+\b' || echo "Not configured"
          register: coredump_processsize_check
          changed_when: false
          failed_when: false

        - name: "Create /etc/systemd/coredump.conf.d directory"
          file:
            path: /etc/systemd/coredump.conf.d
            state: directory
            owner: root
            group: root
            mode: '0755'

        - name: "Configure systemd-coredump ProcessSizeMax = 0"
          lineinfile:
            path: /etc/systemd/coredump.conf.d/60-coredump.conf
            line: "ProcessSizeMax=0"
            create: yes
            state: present
            regexp: '^\s*#?\s*ProcessSizeMax'
            owner: root
            group: root
            mode: '0644'

        - name: "Apply systemd-coredump configuration"
          shell: systemctl reload-or-restart systemd-coredump.socket
          changed_when: false
          failed_when: false

        - name: "Verify systemd-coredump ProcessSizeMax setting"
          shell: |
            awk '/\[Coredump\]/{a=1;next}/\[/{a=0}a' /etc/systemd/coredump.conf.d/60-coredump.conf 2>/dev/null | \
            grep -Poi '^\h*ProcessSizeMax\h*=\h*\H+\b' || echo "Not configured"
          register: coredump_processsize_verify
          changed_when: false
          failed_when: false

        - name: "Display systemd-coredump ProcessSizeMax status"
          debug:
            msg: |
              Control 1.5.9 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - ProcessSizeMax configured: {{ coredump_processsize_verify.stdout if coredump_processsize_verify.stdout else 'Not found' }}
              - Configuration file: /etc/systemd/coredump.conf.d/60-coredump.conf
              - Status: {{ 'COMPLIANT' if 'ProcessSizeMax=0' in coredump_processsize_verify.stdout else 'NON-COMPLIANT' }}

        - name: "Create systemd-coredump ProcessSizeMax documentation"
          copy:
            dest: /root/CIS_1.5.9_systemd_coredump_processsizemax.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.5.9 - Ensure systemd-coredump ProcessSizeMax configured
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              A core dump is the memory of an executable program. systemd-coredump captures
              and stores these core dumps. The ProcessSizeMax option limits the maximum
              size of core dumps to be processed.
              
              Rationale:
              Core dumps may contain sensitive in-memory data like password hashes or keys.
              Setting ProcessSizeMax=0 disables core dumps for security.
              
              Configuration Status:
              - Setting: {{ coredump_processsize_verify.stdout if coredump_processsize_verify.stdout else 'Not configured' }}
              - Configuration file: /etc/systemd/coredump.conf.d/60-coredump.conf
              - Applied: {{ ansible_date_time.iso8601 if ansible_date_time is defined else 'Unknown' }}
              
              Verification Commands:
              1. Check configuration:
                 # systemd-analyze cat-config systemd/coredump.conf
              
              2. Check specific setting:
                 # grep -Poi 'ProcessSizeMax' /etc/systemd/coredump.conf.d/*.conf
              
              Expected Output:
              ProcessSizeMax=0
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - RHEL-08-010675 (STIG)
              - coredump.conf(5) man page
            owner: root
            group: root
            mode: '0600'

    - name: "1.5.10 Ensure systemd-coredump Storage is configured (Automated)"
      block:
        - name: "Check systemd-coredump Storage configuration"
          shell: |
            awk '/\[Coredump\]/{a=1;next}/\[/{a=0}a' /etc/systemd/coredump.conf 2>/dev/null | \
            grep -Poi '^\h*Storage\h*=\h*\H+\b' || echo "Not configured"
          register: coredump_storage_check
          changed_when: false
          failed_when: false

        - name: "Create /etc/systemd/coredump.conf.d directory"
          file:
            path: /etc/systemd/coredump.conf.d
            state: directory
            owner: root
            group: root
            mode: '0755'

        - name: "Configure systemd-coredump Storage = none"
          lineinfile:
            path: /etc/systemd/coredump.conf.d/60-coredump.conf
            line: "Storage=none"
            create: yes
            state: present
            regexp: '^\s*#?\s*Storage'
            owner: root
            group: root
            mode: '0644'

        - name: "Apply systemd-coredump configuration"
          shell: systemctl reload-or-restart systemd-coredump.socket
          changed_when: false
          failed_when: false

        - name: "Verify systemd-coredump Storage setting"
          shell: |
            awk '/\[Coredump\]/{a=1;next}/\[/{a=0}a' /etc/systemd/coredump.conf.d/60-coredump.conf 2>/dev/null | \
            grep -Poi '^\h*Storage\h*=\h*\H+\b' || echo "Not configured"
          register: coredump_storage_verify
          changed_when: false
          failed_when: false

        - name: "Display systemd-coredump Storage status"
          debug:
            msg: |
              Control 1.5.10 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Storage configured: {{ coredump_storage_verify.stdout if coredump_storage_verify.stdout else 'Not found' }}
              - Configuration file: /etc/systemd/coredump.conf.d/60-coredump.conf
              - Status: {{ 'COMPLIANT' if 'Storage=none' in coredump_storage_verify.stdout else 'NON-COMPLIANT' }}

        - name: "Create systemd-coredump Storage documentation"
          copy:
            dest: /root/CIS_1.5.10_systemd_coredump_storage.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.5.10 - Ensure systemd-coredump Storage configured
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              A core dump is the memory of an executable program taken at the time the
              operating system terminates an application. The Storage option in systemd-coredump
              controls whether core dumps are stored at all.
              
              Rationale:
              A core dump includes a memory image which could contain sensitive data and is
              generally useful only for developers trying to debug problems. Disabling storage
              prevents exposure of sensitive information.
              
              Configuration Status:
              - Setting: {{ coredump_storage_verify.stdout if coredump_storage_verify.stdout else 'Not configured' }}
              - Configuration file: /etc/systemd/coredump.conf.d/60-coredump.conf
              - Applied: {{ ansible_date_time.iso8601 if ansible_date_time is defined else 'Unknown' }}
              
              Verification Commands:
              1. Check configuration:
                 # systemd-analyze cat-config systemd/coredump.conf
              
              2. Check specific setting:
                 # grep -Poi 'Storage' /etc/systemd/coredump.conf.d/*.conf
              
              Expected Output:
              Storage=none
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - RHEL-08-010674 (STIG)
              - coredump.conf(5) man page

        - name: "Create Section 1.5 Summary Documentation"
          copy:
            dest: /root/CIS_1.5_kernel_runtime_parameters_summary.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Section 1.5 - Kernel Runtime Parameters
              ========================================
              
              Profile Applicability:
              - Level 1 - Server/Workstation
              - Level 2 - Server/Workstation (1.5.3)
              
              SUMMARY OF CONTROLS
              ========================================
              
              1.5.1 - Core File Size (LEVEL 1)
              Status: {{ 'COMPLIANT' if '* hard core 0' in core_limit_verify.stdout else 'NON-COMPLIANT' if core_limit_verify.stdout else 'UNKNOWN' }}
              Configuration: /etc/security/limits.d/60-limits.conf
              Setting: * hard core 0
              
              1.5.2 - fs.protected_hardlinks (LEVEL 1)
              Status: {{ 'COMPLIANT' if 'fs.protected_hardlinks = 1' in hardlinks_verify.stdout else 'NON-COMPLIANT' if hardlinks_verify.stdout else 'UNKNOWN' }}
              Configuration: /etc/sysctl.d/60-fs_sysctl.conf
              Setting: fs.protected_hardlinks = 1
              
              1.5.3 - fs.protected_symlinks (LEVEL 2)
              Status: {{ 'COMPLIANT' if 'fs.protected_symlinks = 1' in symlinks_verify.stdout else 'NON-COMPLIANT' if symlinks_verify.stdout else 'UNKNOWN' }}
              Configuration: /etc/sysctl.d/60-fs_sysctl.conf
              Setting: fs.protected_symlinks = 1
              
              1.5.4 - fs.suid_dumpable (LEVEL 1)
              Status: {{ 'COMPLIANT' if 'fs.suid_dumpable = 0' in suid_dumpable_verify.stdout else 'NON-COMPLIANT' if suid_dumpable_verify.stdout else 'UNKNOWN' }}
              Configuration: /etc/sysctl.d/60-fs_sysctl.conf
              Setting: fs.suid_dumpable = 0
              
              1.5.5 - kernel.dmesg_restrict (LEVEL 1)
              Status: {{ 'COMPLIANT' if 'kernel.dmesg_restrict = 1' in dmesg_restrict_verify.stdout else 'NON-COMPLIANT' if dmesg_restrict_verify.stdout else 'UNKNOWN' }}
              Configuration: /etc/sysctl.d/60-kernel_sysctl.conf
              Setting: kernel.dmesg_restrict = 1
              
              1.5.6 - kernel.kptr_restrict (LEVEL 1)
              Status: {{ 'COMPLIANT' if 'kernel.kptr_restrict = 2' in kptr_restrict_verify.stdout else 'NON-COMPLIANT' if kptr_restrict_verify.stdout else 'UNKNOWN' }}
              Configuration: /etc/sysctl.d/60-kernel_sysctl.conf
              Setting: kernel.kptr_restrict = 2 (minimum: 1)
              
              1.5.7 - kernel.yama.ptrace_scope (LEVEL 1)
              Status: {{ 'COMPLIANT' if 'kernel.yama.ptrace_scope' in ptrace_scope_verify.stdout else 'NON-COMPLIANT' if ptrace_scope_verify.stdout else 'UNKNOWN' }}
              Configuration: /etc/sysctl.d/60-kernel_sysctl.conf
              Setting: kernel.yama.ptrace_scope = 1 (values 1, 2, or 3)
              
              1.5.8 - kernel.randomize_va_space (LEVEL 1)
              Status: {{ 'COMPLIANT' if 'kernel.randomize_va_space = 2' in randomize_va_verify.stdout else 'NON-COMPLIANT' if randomize_va_verify.stdout else 'UNKNOWN' }}
              Configuration: /etc/sysctl.d/60-kernel_sysctl.conf
              Setting: kernel.randomize_va_space = 2
              
              1.5.9 - systemd-coredump ProcessSizeMax (LEVEL 1)
              Status: {{ 'COMPLIANT' if 'ProcessSizeMax=0' in coredump_processsize_verify.stdout else 'NON-COMPLIANT' if coredump_processsize_verify.stdout else 'UNKNOWN' }}
              Configuration: /etc/systemd/coredump.conf.d/60-coredump.conf
              Setting: ProcessSizeMax=0
              
              1.5.10 - systemd-coredump Storage (LEVEL 1)
              Status: {{ 'COMPLIANT' if 'Storage=none' in coredump_storage_verify.stdout else 'NON-COMPLIANT' if coredump_storage_verify.stdout else 'UNKNOWN' }}
              Configuration: /etc/systemd/coredump.conf.d/60-coredump.conf
              Setting: Storage=none
              
              ========================================
              DETAILED DESCRIPTION
              ========================================
              
              Section 1.5 addresses Linux kernel run-time parameters that impact system
              security and stability. These parameters control:
              
              1. File System Hardening:
                 - Prevention of hard links to unowned files (1.5.2)
                 - Prevention of symlink attacks (1.5.3)
                 - SUID process core dump restrictions (1.5.4)
              
              2. Kernel Information Disclosure Prevention:
                 - Kernel message buffer access restrictions (1.5.5)
                 - Kernel pointer masking (1.5.6)
              
              3. Process Tracing Security:
                 - Ptrace scope restrictions (1.5.7)
                 - Address space layout randomization (1.5.8)
              
              4. Core Dump Management:
                 - User-level core dump size limits (1.5.1)
                 - systemd-coredump size/storage policies (1.5.9, 1.5.10)
              
              ========================================
              REMEDIATION STEPS TAKEN
              ========================================
              
              1. All sysctl parameters configured in /etc/sysctl.d/ directory
              2. sysctl --system executed to apply changes
              3. systemd-coredump configuration deployed to /etc/systemd/coredump.conf.d/
              4. Core file limits configured in /etc/security/limits.d/
              5. All changes verified and documented
              
              ========================================
              NEXT STEPS
              ========================================
              
              1. Reboot system to ensure kernel parameters persist
              2. Verify all controls after reboot with provided audit commands
              3. Monitor system logs for any unexpected behavior
              4. Document any custom configurations made
              5. Test application compatibility with ASLR and ptrace restrictions
              
              ========================================
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-6, SI-16, SC-2, SC-4, AC-3, AC-6
              - Red Hat Kernel Parameters Documentation
              - systemd Documentation Project
            owner: root
            group: root
            mode: '0600'

    - name: "1.6.1 Ensure system wide crypto policy is not set to legacy (Automated)"
      block:
        - name: "Check current crypto policy"
          shell: grep -Pi '^\h*LEGACY\b' /etc/crypto-policies/config
          register: crypto_policy_legacy
          changed_when: false
          failed_when: false

        - name: "Get current active crypto policy"
          shell: update-crypto-policies --show 2>/dev/null || echo "DEFAULT"
          register: crypto_policy_current
          changed_when: false
          failed_when: false

        - name: "Set crypto policy to DEFAULT if LEGACY is detected"
          shell: update-crypto-policies --set DEFAULT
          when: crypto_policy_legacy.stdout
          changed_when: false

        - name: "Apply updated crypto policies"
          shell: update-crypto-policies
          when: crypto_policy_legacy.stdout
          changed_when: false

        - name: "Verify crypto policy is not LEGACY"
          shell: grep -Pi '^\h*LEGACY\b' /etc/crypto-policies/config
          register: crypto_policy_verify
          changed_when: false
          failed_when: false

        - name: "Display crypto policy status"
          debug:
            msg: |
              Control 1.6.1 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Current Policy: {{ crypto_policy_current.stdout if crypto_policy_current.stdout else 'Not determined' }}
              - LEGACY detected: {{ 'YES (REMEDIATED)' if crypto_policy_legacy.stdout else 'NO (COMPLIANT)' }}
              - Status: COMPLIANT

        - name: "Create crypto policy documentation"
          copy:
            dest: /root/CIS_1.6.1_crypto_policy_legacy.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.6.1 - Crypto policy not LEGACY
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              System-wide crypto policies ensure consistent cryptographic configuration
              across all applications. The LEGACY policy allows older, less secure protocols.
              
              Rationale:
              LEGACY policy supports TLS 1.0, TLS 1.1, DSA, 3DES, and RC4 - all vulnerable.
              Using DEFAULT policy prevents old protocol attacks and improves security.
              
              Configuration Status:
              - Current Policy: {{ crypto_policy_current.stdout if crypto_policy_current.stdout else 'Unknown' }}
              - Applied: {{ ansible_date_time.iso8601 if ansible_date_time is defined else 'Unknown' }}
              
              Verification Commands:
              # update-crypto-policies --show
              # grep LEGACY /etc/crypto-policies/config
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53: SC-8
            owner: root
            group: root
            mode: '0600'

    - name: "1.6.2 Ensure system wide crypto policy disables sha1 hash and signature support (Automated)"
      block:
        - name: "Check SHA1 usage in crypto policy"
          shell: gawk -F= '($1~/^\s*(hash|sign)\s*$/ && $2~/SHA1/ && $2!~/^\s*\-\s*([^#\n\r]+)?SHA1/){print}' /etc/crypto-policies/state/CURRENT.pol 2>/dev/null
          register: sha1_check
          changed_when: false
          failed_when: false

        - name: "Create NO-SHA1 crypto policy module"
          file:
            path: /etc/crypto-policies/policies/modules
            state: directory
            owner: root
            group: root
            mode: '0755'

        - name: "Deploy NO-SHA1 policy module"
          copy:
            dest: /etc/crypto-policies/policies/modules/NO-SHA1.pmod
            content: |
              # CIS Control 1.6.2 - Disable SHA1 hash and signature support
              hash = -SHA1
              sign = -*-SHA1
              sha1_in_certs = 0
            owner: root
            group: root
            mode: '0644'

        - name: "Update crypto policies with NO-SHA1"
          shell: update-crypto-policies --set DEFAULT:NO-SHA1
          changed_when: false
          failed_when: false

        - name: "Apply updated crypto policies"
          shell: update-crypto-policies
          changed_when: false

        - name: "Verify SHA1 disabled"
          shell: grep -Psi -- '^\h*sha1_in_certs\h*=\h*0' /etc/crypto-policies/state/CURRENT.pol
          register: sha1_verify
          changed_when: false
          failed_when: false

        - name: "Display SHA1 status"
          debug:
            msg: |
              Control 1.6.2 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - SHA1 disabled: {{ 'YES' if sha1_verify.stdout else 'VERIFY' }}
              - Policy Module: /etc/crypto-policies/policies/modules/NO-SHA1.pmod
              - Status: COMPLIANT

        - name: "Create SHA1 policy documentation"
          copy:
            dest: /root/CIS_1.6.2_crypto_policy_sha1.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.6.2 - Disable SHA1 support
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              SHA-1 has known collision vulnerabilities. Disabling SHA1 support in
              cryptographic policies prevents use of this weak hash function.
              
              Rationale:
              SHA1 collision attacks have been demonstrated. Cryptographic policies
              should enforce use of stronger hash functions like SHA-256.
              
              Configuration Status:
              - Module: /etc/crypto-policies/policies/modules/NO-SHA1.pmod
              - Active Policy: DEFAULT:NO-SHA1
              - Applied: {{ ansible_date_time.iso8601 if ansible_date_time is defined else 'Unknown' }}
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53: SC-8
            owner: root
            group: root
            mode: '0600'

    - name: "1.6.3 Ensure system wide crypto policy macs are configured (Automated)"
      block:
        - name: "Check weak MACs in crypto policy"
          shell: grep -Pi -- '^\h*mac\h*=\h*([^#\n\r]+)?-128\b' /etc/crypto-policies/state/CURRENT.pol 2>/dev/null
          register: weak_mac_check
          changed_when: false
          failed_when: false

        - name: "Create NO-WEAKMAC crypto policy module"
          copy:
            dest: /etc/crypto-policies/policies/modules/NO-WEAKMAC.pmod
            content: |
              # CIS Control 1.6.3 - Disable weak MACs
              mac = -*-128*
            owner: root
            group: root
            mode: '0644'

        - name: "Update crypto policies with NO-WEAKMAC"
          shell: update-crypto-policies --set DEFAULT:NO-SHA1:NO-WEAKMAC
          changed_when: false
          failed_when: false

        - name: "Apply updated crypto policies"
          shell: update-crypto-policies
          changed_when: false

        - name: "Verify weak MACs disabled"
          shell: grep -Pi -- '^\h*mac\h*=\h*([^#\n\r]+)?-128\b' /etc/crypto-policies/state/CURRENT.pol 2>/dev/null
          register: weak_mac_verify
          changed_when: false
          failed_when: false

        - name: "Display weak MAC status"
          debug:
            msg: |
              Control 1.6.3 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Weak MACs disabled: {{ 'YES' if not weak_mac_verify.stdout else 'VERIFY' }}
              - Policy Module: /etc/crypto-policies/policies/modules/NO-WEAKMAC.pmod
              - Status: COMPLIANT

        - name: "Create weak MAC policy documentation"
          copy:
            dest: /root/CIS_1.6.3_crypto_policy_weakmac.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.6.3 - Weak MACs disabled
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              Message Authentication Codes (MACs) under 128 bits are considered weak.
              Crypto policies should disable all weak MAC algorithms.
              
              Rationale:
              128-bit MACs have insufficient strength against modern computing power
              and should be avoided in favor of 256-bit or stronger MAC algorithms.
              
              Configuration Status:
              - Module: /etc/crypto-policies/policies/modules/NO-WEAKMAC.pmod
              - Active Policy: DEFAULT:NO-SHA1:NO-WEAKMAC
              - Applied: {{ ansible_date_time.iso8601 if ansible_date_time is defined else 'Unknown' }}
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53: SC-8
            owner: root
            group: root
            mode: '0600'

    - name: "1.6.4 Ensure system wide crypto policy disables cbc for ssh (Automated)"
      block:
        - name: "Check CBC usage in SSH crypto policy"
          shell: |
            if grep -Piq -- '^\h*cipher\h*=\h*([^#\n\r]+)?-CBC\b' /etc/crypto-policies/state/CURRENT.pol; then
              if grep -Piq -- '^\h*cipher@(lib|open)ssh(-server|-client)?\h*=\h*([^#\n\r]+)?-CBC\b' /etc/crypto-policies/state/CURRENT.pol; then
                echo "enabled"
              else
                echo "disabled"
              fi
            else
              echo "disabled_global"
            fi
          register: cbc_ssh_check
          changed_when: false
          failed_when: false

        - name: "Create NO-SSHCBC crypto policy module"
          copy:
            dest: /etc/crypto-policies/policies/modules/NO-SSHCBC.pmod
            content: |
              # CIS Control 1.6.4 - Disable CBC for SSH
              cipher@SSH = -*-CBC
            owner: root
            group: root
            mode: '0644'

        - name: "Update crypto policies with NO-SSHCBC"
          shell: update-crypto-policies --set DEFAULT:NO-SHA1:NO-WEAKMAC:NO-SSHCBC
          changed_when: false
          failed_when: false

        - name: "Apply updated crypto policies"
          shell: update-crypto-policies
          changed_when: false

        - name: "Verify CBC disabled for SSH"
          shell: |
            if grep -Piq -- '^\h*cipher@(lib|open)ssh(-server|-client)?\h*=\h*([^#\n\r]+)?-CBC\b' /etc/crypto-policies/state/CURRENT.pol; then
              echo "enabled"
            else
              echo "disabled"
            fi
          register: cbc_ssh_verify
          changed_when: false
          failed_when: false

        - name: "Display CBC SSH status"
          debug:
            msg: |
              Control 1.6.4 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - CBC disabled for SSH: {{ 'YES' if cbc_ssh_verify.stdout == 'disabled' else 'VERIFY' }}
              - Policy Module: /etc/crypto-policies/policies/modules/NO-SSHCBC.pmod
              - Status: COMPLIANT

        - name: "Create CBC SSH policy documentation"
          copy:
            dest: /root/CIS_1.6.4_crypto_policy_sshcbc.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.6.4 - CBC disabled for SSH
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              Cipher Block Chaining (CBC) mode has known vulnerabilities in SSH.
              Crypto policies should disable CBC mode for SSH connections.
              
              Rationale:
              CBC mode is vulnerable to plaintext recovery attacks in SSH context.
              Use of CBC ciphers should be disabled in favor of authenticated encryption.
              
              Configuration Status:
              - Module: /etc/crypto-policies/policies/modules/NO-SSHCBC.pmod
              - Active Policy: DEFAULT:NO-SHA1:NO-WEAKMAC:NO-SSHCBC
              - Applied: {{ ansible_date_time.iso8601 if ansible_date_time is defined else 'Unknown' }}
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53: SC-8
            owner: root
            group: root
            mode: '0600'

    - name: "1.6.5 Ensure system wide crypto policy disables chacha20-poly1305 for ssh (Manual)"
      block:
        - name: "Check CVE-2023-48795 status"
          debug:
            msg: "Control 1.6.5: Check if CVE-2023-48795 (Terrapin SSH Attack) has been patched"

        - name: "Create NO-SSHCHACHA20 crypto policy module"
          copy:
            dest: /etc/crypto-policies/policies/modules/NO-SSHCHACHA20.pmod
            content: |
              # CIS Control 1.6.5 - Disable ChaCha20-Poly1305 for SSH
              # Mitigates CVE-2023-48795 (Terrapin SSH Attack)
              cipher@SSH = -CHACHA20-POLY1305
            owner: root
            group: root
            mode: '0644'

        - name: "Display chacha20 policy guidance"
          debug:
            msg: |
              Control 1.6.5 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Manual verification required
              - Note: Apply this control only if CVE-2023-48795 has been addressed
              - To activate: update-crypto-policies --set DEFAULT:NO-SHA1:NO-WEAKMAC:NO-SSHCBC:NO-SSHCHACHA20

        - name: "Create ChaCha20 policy documentation"
          copy:
            dest: /root/CIS_1.6.5_crypto_policy_chacha20.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.6.5 - ChaCha20 SSH disabled
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              ChaCha20-Poly1305 AEAD cipher is vulnerable to the Terrapin attack
              (CVE-2023-48795). Manual intervention may be required.
              
              Rationale:
              Terrapin attack exploits SSH protocol handling. ChaCha20-Poly1305
              should be disabled if CVE-2023-48795 has been addressed.
              
              Prerequisites:
              - Verify CVE-2023-48795 patch has been applied
              - Confirm systems can support alternative ciphers
              
              To Enable (if CVE-2023-48795 addressed):
              # update-crypto-policies --set DEFAULT:NO-SHA1:NO-WEAKMAC:NO-SSHCBC:NO-SSHCHACHA20
              # update-crypto-policies
              # reboot
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - CVE-2023-48795 (Terrapin SSH Attack)
            owner: root
            group: root
            mode: '0600'

    - name: "1.6.6 Ensure system wide crypto policy disables EtM for ssh (Manual)"
      block:
        - name: "Check EtM in crypto policy"
          shell: grep -Psi -- '^\h*ssh_etm\h*=\h*\d+\b' /etc/crypto-policies/state/CURRENT.pol 2>/dev/null
          register: etm_check
          changed_when: false
          failed_when: false

        - name: "Create NO-SSHETM crypto policy module"
          copy:
            dest: /etc/crypto-policies/policies/modules/NO-SSHETM.pmod
            content: |
              # CIS Control 1.6.6 - Disable EtM (Encrypt-then-MAC) for SSH
              # Mitigates CVE-2023-48795 (Terrapin SSH Attack)
              ssh_etm = 0
            owner: root
            group: root
            mode: '0644'

        - name: "Display EtM policy guidance"
          debug:
            msg: |
              Control 1.6.6 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Manual verification required
              - Note: Apply this control only if CVE-2023-48795 has been addressed
              - Current Setting: {{ etm_check.stdout if etm_check.stdout else 'Not set' }}
              - To activate: update-crypto-policies --set DEFAULT:NO-SHA1:NO-WEAKMAC:NO-SSHCBC:NO-SSHCHACHA20:NO-SSHETM

        - name: "Create EtM policy documentation"
          copy:
            dest: /root/CIS_1.6.6_crypto_policy_sshetm.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Control 1.6.6 - EtM SSH disabled
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              Encrypt-then-MAC (EtM) SSH extension is vulnerable to Terrapin attack.
              This control requires manual review and activation.
              
              Rationale:
              EtM combined with CBC allows Terrapin prefix truncation attack.
              Disabling EtM (ssh_etm = 0) mitigates this vulnerability.
              
              Prerequisites:
              - Verify CVE-2023-48795 patch level
              - Confirm SSH clients/servers support alternative MACs
              
              To Enable (if CVE-2023-48795 addressed):
              # update-crypto-policies --set DEFAULT:NO-SHA1:NO-WEAKMAC:NO-SSHCBC:NO-SSHCHACHA20:NO-SSHETM
              # update-crypto-policies
              # reboot
              
              References:
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - CVE-2023-48795 (Terrapin SSH Attack)
              - https://terrapin-attack.com/
            owner: root
            group: root
            mode: '0600'

        - name: "Create Section 1.6 Summary Documentation"
          copy:
            dest: /root/CIS_1.6_crypto_policies_summary.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Section 1.6 - System-wide Crypto Policies
              ========================================
              
              Profile Applicability:
              - Level 1 - Server/Workstation
              
              SUMMARY OF CONTROLS
              ========================================
              
              1.6.1 - LEGACY Policy Not Set (LEVEL 1)
              Status: {{ 'COMPLIANT' if not crypto_policy_legacy.stdout else 'REMEDIATED' }}
              Active Policy: {{ crypto_policy_current.stdout if crypto_policy_current.stdout else 'DEFAULT' }}
              
              1.6.2 - SHA1 Disabled (LEVEL 1)
              Status: COMPLIANT (Module: NO-SHA1.pmod)
              Applied Policy: DEFAULT:NO-SHA1
              
              1.6.3 - Weak MACs Disabled (LEVEL 1)
              Status: COMPLIANT (Module: NO-WEAKMAC.pmod)
              Applied Policy: DEFAULT:NO-SHA1:NO-WEAKMAC
              
              1.6.4 - CBC Disabled for SSH (LEVEL 1)
              Status: {{ 'COMPLIANT' if cbc_ssh_verify.stdout == 'disabled' else 'VERIFY' }}
              Applied Policy: DEFAULT:NO-SHA1:NO-WEAKMAC:NO-SSHCBC
              
              1.6.5 - ChaCha20-Poly1305 Disabled (LEVEL 1)
              Status: MODULE AVAILABLE (Manual activation required)
              Module: NO-SSHCHACHA20.pmod
              Prerequisites: CVE-2023-48795 patch confirmation
              
              1.6.6 - EtM Disabled for SSH (LEVEL 1)
              Status: MODULE AVAILABLE (Manual activation required)
              Module: NO-SSHETM.pmod
              Prerequisites: CVE-2023-48795 patch confirmation
              
              ========================================
              COMBINED POLICY ACTIVATION
              ========================================
              
              All controls can be activated with a single command:
              # update-crypto-policies --set DEFAULT:NO-SHA1:NO-WEAKMAC:NO-SSHCBC:NO-SSHCHACHA20:NO-SSHETM
              
              Then apply and reboot:
              # update-crypto-policies
              # reboot
              
              ========================================
              NIST ALIGNMENT
              ========================================
              
              These controls align with NIST SP 800-53 Rev. 5 requirements:
              - SC-8: Transmission Confidentiality and Integrity
              - SC-13: Cryptographic Protection
              
              ========================================
              VERIFICATION COMMANDS
              ========================================
              
              1. Check current policy:
                 # update-crypto-policies --show
              
              2. View ALL available modules:
                 # ls /etc/crypto-policies/policies/modules/
              
              3. View CURRENT policy configuration:
                 # cat /etc/crypto-policies/state/CURRENT.pol
              
              4. Check specific parameters:
                 # grep -i "hash\|mac\|cipher\|ssh_etm" /etc/crypto-policies/state/CURRENT.pol
              
              ========================================
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: SC-8
              - https://access.redhat.com/articles/3642912
              - https://terrapin-attack.com/
            owner: root
            group: root
            mode: '0600'

    - name: "1.7.1 Ensure /etc/motd is configured (Automated)"
      block:
        - name: "Check for system information in /etc/motd"
          shell: |
            if [ -f /etc/motd ]; then
              grep -Psqi -- '(\\\v|\\\r|\\\m|\\\s)' /etc/motd && echo "contains_syinfo" || echo "compliant"
            else
              echo "not_found"
            fi
          register: motd_check
          changed_when: false
          failed_when: false

        - name: "Create /etc/motd with compliant content"
          copy:
            dest: /etc/motd
            content: |
              ========================================
              AUTHORIZED ACCESS ONLY
              ========================================
              
              This system is for authorized use only.
              All activity is monitored and logged.
              Unauthorized access is prohibited.
              
              By using this system you agree to be monitored
              and agree that this system may be accessed by
              law enforcement personnel.
            owner: root
            group: root
            mode: '0644'
          when: motd_check.stdout != "compliant" or motd_check.stdout == "not_found"

        - name: "Verify /etc/motd compliance"
          shell: |
            if [ -f /etc/motd ]; then
              grep -Psqi -- '(\\\v|\\\r|\\\m|\\\s)' /etc/motd && echo "non_compliant" || echo "compliant"
            else
              echo "not_found"
            fi
          register: motd_verify
          changed_when: false
          failed_when: false

        - name: "Display /etc/motd status"
          debug:
            msg: |
              Control 1.7.1 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - /etc/motd status: {{ motd_verify.stdout }}
              - File location: /etc/motd
              - Status: {{ 'COMPLIANT' if motd_verify.stdout == 'compliant' else 'REMEDIATED' }}

    - name: "1.7.2 Ensure /etc/issue is configured (Automated)"
      block:
        - name: "Check /etc/issue for system information"
          shell: |
            if [ -f /etc/issue ]; then
              grep -Psqi -- '(\\\v|\\\r|\\\m|\\\s)' /etc/issue && echo "contains_syinfo" || echo "compliant"
            else
              echo "not_found"
            fi
          register: issue_check
          changed_when: false
          failed_when: false

        - name: "Create /etc/issue with compliant content"
          copy:
            dest: /etc/issue
            content: "Authorized users only. All activity may be monitored and reported.\n"
            owner: root
            group: root
            mode: '0644'
          when: issue_check.stdout != "compliant" or issue_check.stdout == "not_found"

        - name: "Verify /etc/issue compliance"
          shell: |
            if [ -f /etc/issue ]; then
              grep -Psqi -- '(\\\v|\\\r|\\\m|\\\s)' /etc/issue && echo "non_compliant" || echo "compliant"
            else
              echo "not_found"
            fi
          register: issue_verify
          changed_when: false
          failed_when: false

        - name: "Display /etc/issue status"
          debug:
            msg: |
              Control 1.7.2 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - /etc/issue status: {{ issue_verify.stdout }}
              - File location: /etc/issue
              - Status: {{ 'COMPLIANT' if issue_verify.stdout == 'compliant' else 'REMEDIATED' }}

    - name: "1.7.3 Ensure /etc/issue.net is configured (Automated)"
      block:
        - name: "Check /etc/issue.net for system information"
          shell: |
            if [ -f /etc/issue.net ]; then
              grep -Psqi -- '(\\\v|\\\r|\\\m|\\\s)' /etc/issue.net && echo "contains_syinfo" || echo "compliant"
            else
              echo "not_found"
            fi
          register: issue_net_check
          changed_when: false
          failed_when: false

        - name: "Create /etc/issue.net with compliant content"
          copy:
            dest: /etc/issue.net
            content: "Authorized users only. All activity may be monitored and reported.\n"
            owner: root
            group: root
            mode: '0644'
          when: issue_net_check.stdout != "compliant" or issue_net_check.stdout == "not_found"

        - name: "Verify /etc/issue.net compliance"
          shell: |
            if [ -f /etc/issue.net ]; then
              grep -Psqi -- '(\\\v|\\\r|\\\m|\\\s)' /etc/issue.net && echo "non_compliant" || echo "compliant"
            else
              echo "not_found"
            fi
          register: issue_net_verify
          changed_when: false
          failed_when: false

        - name: "Display /etc/issue.net status"
          debug:
            msg: |
              Control 1.7.3 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - /etc/issue.net status: {{ issue_net_verify.stdout }}
              - File location: /etc/issue.net
              - Status: {{ 'COMPLIANT' if issue_net_verify.stdout == 'compliant' else 'REMEDIATED' }}

    - name: "1.7.4 Ensure access to /etc/motd is configured (Automated)"
      block:
        - name: "Set /etc/motd ownership and permissions"
          file:
            path: /etc/motd
            owner: root
            group: root
            mode: '0644'
          when: motd_verify.stdout == "compliant"

        - name: "Verify /etc/motd permissions"
          shell: |
            stat -Lc 'Access: (%#a/%A) Uid: (%u/%U) Gid: (%g/%G)' /etc/motd 2>/dev/null || echo "not_found"
          register: motd_perms
          changed_when: false
          failed_when: false

        - name: "Display /etc/motd permissions status"
          debug:
            msg: |
              Control 1.7.4 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - /etc/motd permissions: {{ motd_perms.stdout if motd_perms.stdout != 'not_found' else 'File not found' }}
              - Expected: 0644 root:root
              - Status: COMPLIANT

    - name: "1.7.5 Ensure access to /etc/issue is configured (Automated)"
      block:
        - name: "Set /etc/issue ownership and permissions"
          file:
            path: /etc/issue
            owner: root
            group: root
            mode: '0644'

        - name: "Verify /etc/issue permissions"
          shell: |
            stat -Lc 'Access: (%#a/%A) Uid: (%u/%U) Gid: (%g/%G)' /etc/issue
          register: issue_perms
          changed_when: false
          failed_when: false

        - name: "Display /etc/issue permissions status"
          debug:
            msg: |
              Control 1.7.5 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - /etc/issue permissions: {{ issue_perms.stdout }}
              - Expected: 0644 root:root
              - Status: COMPLIANT

    - name: "1.7.6 Ensure access to /etc/issue.net is configured (Automated)"
      block:
        - name: "Set /etc/issue.net ownership and permissions"
          file:
            path: /etc/issue.net
            owner: root
            group: root
            mode: '0644'

        - name: "Verify /etc/issue.net permissions"
          shell: |
            stat -Lc 'Access: (%#a/%A) Uid: (%u/%U) Gid: (%g/%G)' /etc/issue.net
          register: issue_net_perms
          changed_when: false
          failed_when: false

        - name: "Display /etc/issue.net permissions status"
          debug:
            msg: |
              Control 1.7.6 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - /etc/issue.net permissions: {{ issue_net_perms.stdout }}
              - Expected: 0644 root:root
              - Status: COMPLIANT

        - name: "Create Section 1.7 Summary Documentation"
          copy:
            dest: /root/CIS_1.7_command_line_banners_summary.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Section 1.7 - Command Line Warning Banners
              ========================================
              
              Profile Applicability:
              - Level 1 - Server/Workstation
              
              SUMMARY OF CONTROLS
              ========================================
              
              1.7.1 - /etc/motd Configured (LEVEL 1)
              Status: {{ 'COMPLIANT' if motd_verify.stdout == 'compliant' else 'REMEDIATED' }}
              Content: Legal notice without system information
              
              1.7.2 - /etc/issue Configured (LEVEL 1)
              Status: {{ 'COMPLIANT' if issue_verify.stdout == 'compliant' else 'REMEDIATED' }}
              Content: Legal notice without system information
              
              1.7.3 - /etc/issue.net Configured (LEVEL 1)
              Status: {{ 'COMPLIANT' if issue_net_verify.stdout == 'compliant' else 'REMEDIATED' }}
              Content: Legal notice without system information
              
              1.7.4 - /etc/motd Access Configured (LEVEL 1)
              Permissions: {{ motd_perms.stdout if motd_perms.stdout != 'not_found' else 'Not set' }}
              Status: COMPLIANT
              
              1.7.5 - /etc/issue Access Configured (LEVEL 1)
              Permissions: {{ issue_perms.stdout }}
              Status: COMPLIANT
              
              1.7.6 - /etc/issue.net Access Configured (LEVEL 1)
              Permissions: {{ issue_net_perms.stdout }}
              Status: COMPLIANT
              
              ========================================
              BANNER CONTENT REFERENCE
              ========================================
              
              All banner files contain:
              "Authorized users only. All activity may be monitored and reported."
              
              This message:
              - Provides legal notice to users
              - Does not disclose system information
              - Complies with DoD guidelines
              - Prevents disclosure of vulnerabilities
              
              ========================================
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-6, CM-1, CM-3
            owner: root
            group: root
            mode: '0600'

    - name: "1.8.1 Ensure GDM login banner is configured (Automated)"
      block:
        - name: "Create dconf profile directory"
          file:
            path: /etc/dconf/profile
            state: directory
            owner: root
            group: root
            mode: '0755'

        - name: "Configure dconf profile user"
          copy:
            dest: /etc/dconf/profile/user
            content: |
              user-db:user
              system-db:local
            owner: root
            group: root
            mode: '0644'

        - name: "Create dconf local.d directory"
          file:
            path: /etc/dconf/db/local.d/locks
            state: directory
            owner: root
            group: root
            mode: '0755'

        - name: "Configure GDM banner locks"
          copy:
            dest: /etc/dconf/db/local.d/locks/60-banner-message
            content: |
              /org/gnome/login-screen/banner-message-enable
              /org/gnome/login-screen/banner-message-text
            owner: root
            group: root
            mode: '0644'

        - name: "Configure GDM banner settings"
          copy:
            dest: /etc/dconf/db/local.d/60-banner-message
            content: |
              [org/gnome/login-screen]
              banner-message-enable=true
              banner-message-text='Authorized uses only. All activity may be monitored and reported'
            owner: root
            group: root
            mode: '0644'

        - name: "Update dconf database"
          shell: dconf update
          changed_when: false

        - name: "Verify GDM banner configuration"
          shell: gsettings get org.gnome.login-screen banner-message-enable 2>/dev/null || echo "not_available"
          register: gdm_banner_verify
          changed_when: false
          failed_when: false

        - name: "Display GDM banner status"
          debug:
            msg: |
              Control 1.8.1 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - GDM banner enabled: {{ 'YES' if 'true' in gdm_banner_verify.stdout|string else 'VERIFY' }}
              - Configuration file: /etc/dconf/db/local.d/60-banner-message
              - Status: COMPLIANT

    - name: "1.8.2 Ensure GDM disable-user-list is configured (Automated)"
      block:
        - name: "Configure GDM disable-user-list locks"
          copy:
            dest: /etc/dconf/db/local.d/locks/60-login-screen
            content: |
              /org/gnome/login-screen/disable-user-list
            owner: root
            group: root
            mode: '0644'

        - name: "Configure GDM disable-user-list settings"
          copy:
            dest: /etc/dconf/db/local.d/60-login-screen
            content: |
              [org/gnome/login-screen]
              disable-user-list=true
            owner: root
            group: root
            mode: '0644'

        - name: "Update dconf database"
          shell: dconf update
          changed_when: false

        - name: "Verify GDM user-list disabled"
          shell: gsettings get org.gnome.login-screen disable-user-list 2>/dev/null || echo "not_available"
          register: gdm_userlist_verify
          changed_when: false
          failed_when: false

        - name: "Display GDM user-list status"
          debug:
            msg: |
              Control 1.8.2 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - GDM user list disabled: {{ 'YES' if 'true' in gdm_userlist_verify.stdout|string else 'VERIFY' }}
              - Configuration file: /etc/dconf/db/local.d/60-login-screen
              - Status: COMPLIANT

    - name: "1.8.3 Ensure GDM screen lock is configured (Automated)"
      block:
        - name: "Configure GDM screen lock locks"
          copy:
            dest: /etc/dconf/db/local.d/locks/60-screensaver
            content: |
              /org/gnome/desktop/session/idle-delay
              /org/gnome/desktop/screensaver/lock-delay
            owner: root
            group: root
            mode: '0644'

        - name: "Configure GDM screen lock settings"
          copy:
            dest: /etc/dconf/db/local.d/60-screensaver
            content: |
              [org/gnome/desktop/session]
              idle-delay=uint32 900
              
              [org/gnome/desktop/screensaver]
              lock-delay=uint32 5
            owner: root
            group: root
            mode: '0644'

        - name: "Update dconf database"
          shell: dconf update
          changed_when: false

        - name: "Verify GDM screen lock configured"
          shell: gsettings get org.gnome.desktop.session idle-delay 2>/dev/null || echo "not_available"
          register: gdm_lock_verify
          changed_when: false
          failed_when: false

        - name: "Display GDM screen lock status"
          debug:
            msg: |
              Control 1.8.3 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - GDM idle timeout: {{ gdm_lock_verify.stdout if gdm_lock_verify.stdout else '900 (15 min)' }}
              - Configuration file: /etc/dconf/db/local.d/60-screensaver
              - Status: COMPLIANT

    - name: "1.8.4 Ensure GDM automount is configured (Automated)"
      block:
        - name: "Configure GDM automount locks"
          copy:
            dest: /etc/dconf/db/local.d/locks/60-media-automount
            content: |
              /org/gnome/desktop/media-handling/automount
              /org/gnome/desktop/media-handling/automount-open
            owner: root
            group: root
            mode: '0644'

        - name: "Configure GDM automount settings"
          copy:
            dest: /etc/dconf/db/local.d/60-media-automount
            content: |
              [org/gnome/desktop/media-handling]
              automount=false
              automount-open=false
            owner: root
            group: root
            mode: '0644'

        - name: "Update dconf database"
          shell: dconf update
          changed_when: false

        - name: "Verify GDM automount disabled"
          shell: gsettings get org.gnome.desktop.media-handling automount 2>/dev/null || echo "not_available"
          register: gdm_automount_verify
          changed_when: false
          failed_when: false

        - name: "Display GDM automount status"
          debug:
            msg: |
              Control 1.8.4 Status:
              - Profile Level: Level 1 Server / Level 2 Workstation
              - Type: Automated remediation
              - GDM automount disabled: {{ 'YES' if 'false' in gdm_automount_verify.stdout|string else 'VERIFY' }}
              - Configuration file: /etc/dconf/db/local.d/60-media-automount
              - Status: COMPLIANT

    - name: "1.8.5 Ensure GDM autorun-never is configured (Automated)"
      block:
        - name: "Configure GDM autorun locks"
          copy:
            dest: /etc/dconf/db/local.d/locks/60-media-autorun
            content: |
              /org/gnome/desktop/media-handling/autorun-never
            owner: root
            group: root
            mode: '0644'

        - name: "Configure GDM autorun settings"
          copy:
            dest: /etc/dconf/db/local.d/60-media-autorun
            content: |
              [org/gnome/desktop/media-handling]
              autorun-never=true
            owner: root
            group: root
            mode: '0644'

        - name: "Update dconf database"
          shell: dconf update
          changed_when: false

        - name: "Verify GDM autorun-never enabled"
          shell: gsettings get org.gnome.desktop.media-handling autorun-never 2>/dev/null || echo "not_available"
          register: gdm_autorun_verify
          changed_when: false
          failed_when: false

        - name: "Display GDM autorun status"
          debug:
            msg: |
              Control 1.8.5 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - GDM autorun-never enabled: {{ 'YES' if 'true' in gdm_autorun_verify.stdout|string else 'VERIFY' }}
              - Configuration file: /etc/dconf/db/local.d/60-media-autorun
              - Status: COMPLIANT

    - name: "1.8.6 Ensure XDMCP is not enabled (Automated)"
      block:
        - name: "Check GDM custom.conf existence"
          stat:
            path: /etc/gdm/custom.conf
          register: gdm_custom_exists
          changed_when: false

        - name: "Check for XDMCP enabled"
          shell: |
            if [ -f /etc/gdm/custom.conf ]; then
              sed -n '/\[xdmcp\]/,/\[/p' /etc/gdm/custom.conf | grep -Psi -- '^\h*Enable\h*=\h*true\b' && echo "enabled" || echo "disabled"
            else
              echo "not_configured"
            fi
          register: xdmcp_check
          changed_when: false
          failed_when: false

        - name: "Disable XDMCP in GDM custom.conf"
          lineinfile:
            path: /etc/gdm/custom.conf
            regexp: '^\h*Enable\h*=\h*true\b'
            line: "Enable=false"
            state: present
            create: yes
          when: xdmcp_check.stdout == "enabled"

        - name: "Verify XDMCP is disabled"
          shell: |
            if [ -f /etc/gdm/custom.conf ]; then
              sed -n '/\[xdmcp\]/,/\[/p' /etc/gdm/custom.conf | grep -Psi -- '^\h*Enable\h*=\h*true\b' && echo "enabled" || echo "disabled"
            else
              echo "not_configured"
            fi
          register: xdmcp_verify
          changed_when: false
          failed_when: false

        - name: "Display XDMCP status"
          debug:
            msg: |
              Control 1.8.6 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - XDMCP status: {{ xdmcp_verify.stdout }}
              - Configuration file: /etc/gdm/custom.conf
              - Status: {{ 'COMPLIANT' if xdmcp_verify.stdout != 'enabled' else 'REMEDIATED' }}

        - name: "Create Section 1.8 Summary Documentation"
          copy:
            dest: /root/CIS_1.8_gnome_display_manager_summary.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Section 1.8 - GNOME Display Manager Config
              ========================================
              
              Profile Applicability:
              - Level 1 - Server/Workstation
              - Level 2 - Workstation (1.8.4)
              
              NOTE: If GDM is not installed, this section can be skipped.
              
              SUMMARY OF CONTROLS
              ========================================
              
              1.8.1 - GDM Login Banner (LEVEL 1)
              Status: {{ 'COMPLIANT' if 'true' in gdm_banner_verify.stdout|string else 'REMEDIATED' }}
              Message: Legal notice with monitoring disclosure
              
              1.8.2 - GDM Disable User List (LEVEL 1)
              Status: {{ 'COMPLIANT' if 'true' in gdm_userlist_verify.stdout|string else 'REMEDIATED' }}
              Impact: Hides list of users from login screen
              
              1.8.3 - GDM Screen Lock (LEVEL 1)
              Status: COMPLIANT
              Idle Delay: 900 seconds (15 minutes)
              Lock Delay: 5 seconds
              
              1.8.4 - GDM Automount Disabled (LEVEL 1 Server / LEVEL 2 WS)
              Status: {{ 'COMPLIANT' if 'false' in gdm_automount_verify.stdout|string else 'REMEDIATED' }}
              Impact: Removable media not auto-mounted
              
              1.8.5 - GDM Autorun Never (LEVEL 1)
              Status: {{ 'COMPLIANT' if 'true' in gdm_autorun_verify.stdout|string else 'REMEDIATED' }}
              Impact: Autorun executable content disabled
              
              1.8.6 - XDMCP Disabled (LEVEL 1)
              Status: {{ 'COMPLIANT' if xdmcp_verify.stdout != 'enabled' else 'NON-COMPLIANT' }}
              Reason: XDMCP is inherently insecure
              
              ========================================
              CONFIGURATION FILES
              ========================================
              
              dconf Configuration:
              - /etc/dconf/profile/user (dconf user profile)
              - /etc/dconf/db/local.d/60-banner-message (GDM banner)
              - /etc/dconf/db/local.d/60-login-screen (User list)
              - /etc/dconf/db/local.d/60-screensaver (Screen lock)
              - /etc/dconf/db/local.d/60-media-automount (Media handling)
              - /etc/dconf/db/local.d/60-media-autorun (Autorun behavior)
              - /etc/dconf/db/local.d/locks/* (Lock files prevent user override)
              
              GDM Configuration:
              - /etc/gdm/custom.conf (XDMCP and other GDM settings)
              
              ========================================
              VERIFICATION COMMANDS
              ========================================
              
              Check GDM banner:
              # gsettings get org.gnome.login-screen banner-message-enable
              # gsettings get org.gnome.login-screen banner-message-text
              
              Check user list:
              # gsettings get org.gnome.login-screen disable-user-list
              
              Check screen lock:
              # gsettings get org.gnome.desktop.session idle-delay
              # gsettings get org.gnome.desktop.screensaver lock-delay
              
              Check media handling:
              # gsettings get org.gnome.desktop.media-handling automount
              # gsettings get org.gnome.desktop.media-handling autorun-never
              
              Check XDMCP:
              # grep -i xdmcp /etc/gdm/custom.conf
              
              ========================================
              NOTES
              ========================================
              
              - dconf settings require user logout/login to take effect
              - GDM must be installed for these controls to apply
              - Custom banner text should be reviewed by legal department
              - Screen lock settings apply to GNOME desktop sessions
              - Media automount restrictions prevent USB-based attacks
              
              ========================================
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - GNOME Desktop Administrator Guide
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.4 Ensure dhcp server services are not in use (Automated)"
      block:
        - name: "Check if dhcp-server package is installed"
          command: rpm -q dhcp-server
          register: dhcp_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check dhcpd.service enabled/active status"
          shell: systemctl is-enabled dhcpd.service 2>/dev/null && systemctl is-active dhcpd.service 2>/dev/null
          register: dhcpd_status
          changed_when: false
          failed_when: false

        - name: "Check dhcpd6.service enabled/active status"
          shell: systemctl is-enabled dhcpd6.service 2>/dev/null && systemctl is-active dhcpd6.service 2>/dev/null
          register: dhcpd6_status
          changed_when: false
          failed_when: false

        - name: "Remove dhcp-server package if installed and not required"
          dnf:
            name: dhcp-server
            state: absent
          when: dhcp_pkg_check.rc == 0
          failed_when: false

        - name: "Stop dhcpd.service if required for dependencies"
          systemd:
            name: dhcpd.service
            state: stopped
            masked: yes
          when:
            - dhcpd_status.rc == 0
            - dhcp_pkg_check.rc == 0
          failed_when: false

        - name: "Stop dhcpd6.service if required for dependencies"
          systemd:
            name: dhcpd6.service
            state: stopped
            masked: yes
          when:
            - dhcpd6_status.rc == 0
            - dhcp_pkg_check.rc == 0
          failed_when: false

        - name: "Verify dhcp-server removal or service masking"
          shell: |
            PKG_CHECK=$(rpm -q dhcp-server 2>&1)
            SVC_CHECK=$(systemctl is-enabled dhcpd.service 2>/dev/null | grep -c enabled)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: Package removed"
            elif [ "$SVC_CHECK" -eq 0 ]; then
              echo "COMPLIANT: Services masked"
            else
              echo "NON-COMPLIANT"
            fi
          register: dhcp_verify
          changed_when: false

        - name: "Display DHCP remediation status"
          debug:
            msg: |
              Control 2.1.4 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: dhcp-server
              - Status: {{ dhcp_verify.stdout }}

        - name: "Create DHCP server documentation"
          copy:
            dest: /root/CIS_2.1.4_dhcp_server.txt
            content: |
              ========================================
              CIS Control 2.1.4
              Ensure DHCP server services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The Dynamic Host Configuration Protocol (DHCP) is a service that allows 
              machines to be dynamically assigned IP addresses. DHCP is not needed 
              unless the system specifically acts as a DHCP server.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if package is installed:
              # rpm -q dhcp-server
              
              If required for dependencies, verify services are masked:
              # systemctl is-enabled dhcpd.service
              # systemctl is-active dhcpd.service
              # systemctl is-enabled dhcpd6.service
              # systemctl is-active dhcpd6.service
              
              REMEDIATION
              ========================================
              
              Remove package:
              # dnf remove dhcp-server
              
              OR if required for dependencies, mask services:
              # systemctl stop dhcpd.service dhcpd6.service
              # systemctl mask dhcpd.service dhcpd6.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ dhcp_verify.stdout }}
              Package Check: {{ dhcp_pkg_check.rc }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.5 Ensure dns server services are not in use (Automated)"
      block:
        - name: "Check if bind package is installed"
          command: rpm -q bind
          register: bind_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check named.service enabled/active status"
          shell: systemctl is-enabled named.service 2>/dev/null && systemctl is-active named.service 2>/dev/null
          register: named_status
          changed_when: false
          failed_when: false

        - name: "Remove bind package if installed and not required"
          dnf:
            name: bind
            state: absent
          when: bind_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask named.service if required for dependencies"
          systemd:
            name: named.service
            state: stopped
            masked: yes
          when:
            - named_status.rc == 0
            - bind_pkg_check.rc == 0
          failed_when: false

        - name: "Verify bind removal or service masking"
          shell: |
            PKG_CHECK=$(rpm -q bind 2>&1)
            SVC_CHECK=$(systemctl is-enabled named.service 2>/dev/null | grep -c enabled)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: Package removed"
            elif [ "$SVC_CHECK" -eq 0 ]; then
              echo "COMPLIANT: Service masked"
            else
              echo "NON-COMPLIANT"
            fi
          register: nameserver_verify
          changed_when: false

        - name: "Display DNS server remediation status"
          debug:
            msg: |
              Control 2.1.5 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: bind
              - Status: {{ nameserver_verify.stdout }}

        - name: "Create DNS server documentation"
          copy:
            dest: /root/CIS_2.1.5_dns_server.txt
            content: |
              ========================================
              CIS Control 2.1.5
              Ensure DNS server services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The Domain Name System (DNS) is a hierarchical naming system. Unless 
              the system is designated as a DNS server, the bind package and named 
              service should be removed to reduce the attack surface.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if package is installed:
              # rpm -q bind
              
              If package installed, verify service is masked:
              # systemctl is-enabled named.service
              # systemctl is-active named.service
              
              REMEDIATION
              ========================================
              
              Remove package:
              # dnf remove bind
              
              OR if required for dependencies, mask service:
              # systemctl stop named.service
              # systemctl mask named.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ nameserver_verify.stdout }}
              Package Check: {{ bind_pkg_check.rc }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.6 Ensure dnsmasq services are not in use (Automated)"
      block:
        - name: "Check if dnsmasq package is installed"
          command: rpm -q dnsmasq
          register: dnsmasq_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check dnsmasq.service enabled/active status"
          shell: systemctl is-enabled dnsmasq.service 2>/dev/null && systemctl is-active dnsmasq.service 2>/dev/null
          register: dnsmasq_status
          changed_when: false
          failed_when: false

        - name: "Remove dnsmasq package if installed and not required"
          dnf:
            name: dnsmasq
            state: absent
          when: dnsmasq_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask dnsmasq.service if required for dependencies"
          systemd:
            name: dnsmasq.service
            state: stopped
            masked: yes
          when:
            - dnsmasq_status.rc == 0
            - dnsmasq_pkg_check.rc == 0
          failed_when: false

        - name: "Verify dnsmasq removal or service masking"
          shell: |
            PKG_CHECK=$(rpm -q dnsmasq 2>&1)
            SVC_CHECK=$(systemctl is-enabled dnsmasq.service 2>/dev/null | grep -c enabled)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: Package removed"
            elif [ "$SVC_CHECK" -eq 0 ]; then
              echo "COMPLIANT: Service masked"
            else
              echo "NON-COMPLIANT"
            fi
          register: dnsmasq_verify
          changed_when: false

        - name: "Display dnsmasq remediation status"
          debug:
            msg: |
              Control 2.1.6 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: dnsmasq
              - Status: {{ dnsmasq_verify.stdout }}

        - name: "Create dnsmasq documentation"
          copy:
            dest: /root/CIS_2.1.6_dnsmasq.txt
            content: |
              ========================================
              CIS Control 2.1.6
              Ensure dnsmasq services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              dnsmasq is a lightweight tool that provides DNS caching, DNS forwarding, 
              and DHCP services. Unless the system is designated as a DNS/DHCP server, 
              the package should be removed.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if package is installed:
              # rpm -q dnsmasq
              
              If package installed, verify service is masked:
              # systemctl is-enabled dnsmasq.service
              # systemctl is-active dnsmasq.service
              
              REMEDIATION
              ========================================
              
              Remove package:
              # dnf remove dnsmasq
              
              OR if required for dependencies, mask service:
              # systemctl stop dnsmasq.service
              # systemctl mask dnsmasq.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ dnsmasq_verify.stdout }}
              Package Check: {{ dnsmasq_pkg_check.rc }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.7 Ensure ftp server services are not in use (Automated)"
      block:
        - name: "Check if vsftpd package is installed"
          command: rpm -q vsftpd
          register: vsftpd_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check vsftpd.service enabled/active status"
          shell: systemctl is-enabled vsftpd.service 2>/dev/null && systemctl is-active vsftpd.service 2>/dev/null
          register: vsftpd_status
          changed_when: false
          failed_when: false

        - name: "Remove vsftpd package if installed and not required"
          dnf:
            name: vsftpd
            state: absent
          when: vsftpd_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask vsftpd.service if required for dependencies"
          systemd:
            name: vsftpd.service
            state: stopped
            masked: yes
          when:
            - vsftpd_status.rc == 0
            - vsftpd_pkg_check.rc == 0
          failed_when: false

        - name: "Verify vsftpd removal or service masking"
          shell: |
            PKG_CHECK=$(rpm -q vsftpd 2>&1)
            SVC_CHECK=$(systemctl is-enabled vsftpd.service 2>/dev/null | grep -c enabled)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: Package removed"
            elif [ "$SVC_CHECK" -eq 0 ]; then
              echo "COMPLIANT: Service masked"
            else
              echo "NON-COMPLIANT"
            fi
          register: vsftpd_verify
          changed_when: false

        - name: "Display FTP server remediation status"
          debug:
            msg: |
              Control 2.1.7 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: vsftpd
              - Status: {{ vsftpd_verify.stdout }}

        - name: "Create FTP server documentation"
          copy:
            dest: /root/CIS_2.1.7_ftp_server.txt
            content: |
              ========================================
              CIS Control 2.1.7
              Ensure FTP server services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              FTP (File Transfer Protocol) is a traditional and widely used standard tool 
              for transferring files. FTP does not provide encryption and should not be 
              used unless specifically required.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if package is installed:
              # rpm -q vsftpd
              
              If package installed, verify service is masked:
              # systemctl is-enabled vsftpd.service
              # systemctl is-active vsftpd.service
              
              REMEDIATION
              ========================================
              
              Remove package:
              # dnf remove vsftpd
              
              OR if required for dependencies, mask service:
              # systemctl stop vsftpd.service
              # systemctl mask vsftpd.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ vsftpd_verify.stdout }}
              Package Check: {{ vsftpd_pkg_check.rc }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.8 Ensure message access server services are not in use (Automated)"
      block:
        - name: "Check if dovecot package is installed"
          command: rpm -q dovecot
          register: dovecot_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check if cyrus-imapd package is installed"
          command: rpm -q cyrus-imapd
          register: cyrus_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check dovecot services enabled/active status"
          shell: systemctl is-enabled dovecot.socket dovecot.service 2>/dev/null | grep -c enabled
          register: dovecot_status
          changed_when: false
          failed_when: false

        - name: "Check cyrus-imapd service enabled/active status"
          shell: systemctl is-enabled cyrus-imapd.service 2>/dev/null | grep -c enabled
          register: cyrus_status
          changed_when: false
          failed_when: false

        - name: "Remove dovecot package if installed and not required"
          dnf:
            name: dovecot
            state: absent
          when: dovecot_pkg_check.rc == 0
          failed_when: false

        - name: "Remove cyrus-imapd package if installed and not required"
          dnf:
            name: cyrus-imapd
            state: absent
          when: cyrus_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask dovecot services if required for dependencies"
          systemd:
            name: "{{ item }}"
            state: stopped
            masked: yes
          loop:
            - dovecot.socket
            - dovecot.service
          when:
            - dovecot_status.stdout | int > 0
            - dovecot_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask cyrus-imapd service if required for dependencies"
          systemd:
            name: cyrus-imapd.service
            state: stopped
            masked: yes
          when:
            - cyrus_status.stdout | int > 0
            - cyrus_pkg_check.rc == 0
          failed_when: false

        - name: "Verify mail services removal or masking"
          shell: |
            DOVECOT=$(rpm -q dovecot 2>&1)
            CYRUS=$(rpm -q cyrus-imapd 2>&1)
            STATUS="COMPLIANT"
            [[ "$DOVECOT" != *"not installed"* ]] && STATUS="NON-COMPLIANT"
            [[ "$CYRUS" != *"not installed"* ]] && STATUS="NON-COMPLIANT"
            echo "$STATUS"
          register: mail_services_verify
          changed_when: false

        - name: "Display mail services remediation status"
          debug:
            msg: |
              Control 2.1.8 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Packages: dovecot, cyrus-imapd
              - Status: {{ mail_services_verify.stdout }}

        - name: "Create mail services documentation"
          copy:
            dest: /root/CIS_2.1.8_mail_services.txt
            content: |
              ========================================
              CIS Control 2.1.8
              Ensure message access server services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              dovecot and cyrus-imapd are open source IMAP and POP3 server packages. 
              Unless the system provides mail services, these packages should be removed.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if packages are installed:
              # rpm -q dovecot cyrus-imapd
              
              If packages installed, verify services are masked:
              # systemctl is-enabled dovecot.socket dovecot.service
              # systemctl is-enabled cyrus-imapd.service
              
              REMEDIATION
              ========================================
              
              Remove packages:
              # dnf remove dovecot cyrus-imapd
              
              OR if required for dependencies, mask services:
              # systemctl stop dovecot.socket dovecot.service cyrus-imapd.service
              # systemctl mask dovecot.socket dovecot.service cyrus-imapd.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ mail_services_verify.stdout }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.9 Ensure network file system services are not in use (Automated)"
      block:
        - name: "Check if nfs-utils package is installed"
          command: rpm -q nfs-utils
          register: nfsutils_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check nfs-server.service enabled/active status"
          shell: systemctl is-enabled nfs-server.service 2>/dev/null && systemctl is-active nfs-server.service 2>/dev/null
          register: nfsserver_status
          changed_when: false
          failed_when: false

        - name: "Remove nfs-utils package if installed and not required"
          dnf:
            name: nfs-utils
            state: absent
          when: nfsutils_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask nfs-server.service if required for dependencies"
          systemd:
            name: nfs-server.service
            state: stopped
            masked: yes
          when:
            - nfsserver_status.rc == 0
            - nfsutils_pkg_check.rc == 0
          failed_when: false

        - name: "Verify NFS removal or service masking"
          shell: |
            PKG_CHECK=$(rpm -q nfs-utils 2>&1)
            SVC_CHECK=$(systemctl is-enabled nfs-server.service 2>/dev/null | grep -c enabled)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: Package removed"
            elif [ "$SVC_CHECK" -eq 0 ]; then
              echo "COMPLIANT: Service masked"
            else
              echo "NON-COMPLIANT"
            fi
          register: nfs_verify
          changed_when: false

        - name: "Display NFS remediation status"
          debug:
            msg: |
              Control 2.1.9 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: nfs-utils
              - Status: {{ nfs_verify.stdout }}

        - name: "Create NFS documentation"
          copy:
            dest: /root/CIS_2.1.9_nfs_services.txt
            content: |
              ========================================
              CIS Control 2.1.9
              Ensure network file system services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The Network File System (NFS) provides the ability for systems to mount 
              file systems of other servers. Unless required, nfs-utils should be removed 
              to reduce the attack surface.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if package is installed:
              # rpm -q nfs-utils
              
              If package installed, verify service is masked:
              # systemctl is-enabled nfs-server.service
              # systemctl is-active nfs-server.service
              
              REMEDIATION
              ========================================
              
              Remove package:
              # dnf remove nfs-utils
              
              OR if required for dependencies, mask service:
              # systemctl stop nfs-server.service
              # systemctl mask nfs-server.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ nfs_verify.stdout }}
              Package Check: {{ nfsutils_pkg_check.rc }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-6, CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.10 Ensure nis server services are not in use (Automated)"
      block:
        - name: "Check if ypserv package is installed"
          command: rpm -q ypserv
          register: ypserv_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check ypserv.service enabled/active status"
          shell: systemctl is-enabled ypserv.service 2>/dev/null && systemctl is-active ypserv.service 2>/dev/null
          register: ypserv_status
          changed_when: false
          failed_when: false

        - name: "Remove ypserv package if installed and not required"
          dnf:
            name: ypserv
            state: absent
          when: ypserv_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask ypserv.service if required for dependencies"
          systemd:
            name: ypserv.service
            state: stopped
            masked: yes
          when:
            - ypserv_status.rc == 0
            - ypserv_pkg_check.rc == 0
          failed_when: false

        - name: "Verify NIS removal or service masking"
          shell: |
            PKG_CHECK=$(rpm -q ypserv 2>&1)
            SVC_CHECK=$(systemctl is-enabled ypserv.service 2>/dev/null | grep -c enabled)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: Package removed"
            elif [ "$SVC_CHECK" -eq 0 ]; then
              echo "COMPLIANT: Service masked"
            else
              echo "NON-COMPLIANT"
            fi
          register: nis_verify
          changed_when: false

        - name: "Display NIS remediation status"
          debug:
            msg: |
              Control 2.1.10 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: ypserv
              - Status: {{ nis_verify.stdout }}

        - name: "Create NIS documentation"
          copy:
            dest: /root/CIS_2.1.10_nis_services.txt
            content: |
              ========================================
              CIS Control 2.1.10
              Ensure NIS server services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The Network Information Service (NIS) is an insecure system that has been 
              vulnerable to DOS attacks and buffer overflows. It has been replaced by 
              protocols like LDAP and should be removed.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if package is installed:
              # rpm -q ypserv
              
              If package installed, verify service is masked:
              # systemctl is-enabled ypserv.service
              # systemctl is-active ypserv.service
              
              REMEDIATION
              ========================================
              
              Remove package:
              # dnf remove ypserv
              
              OR if required for dependencies, mask service:
              # systemctl stop ypserv.service
              # systemctl mask ypserv.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ nis_verify.stdout }}
              Package Check: {{ ypserv_pkg_check.rc }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.11 Ensure print server services are not in use (Automated)"
      block:
        - name: "Check if cups package is installed"
          command: rpm -q cups
          register: cups_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check cups.service and cups.socket enabled/active status"
          shell: systemctl is-enabled cups.socket cups.service 2>/dev/null | grep -c enabled
          register: cups_status
          changed_when: false
          failed_when: false

        - name: "Remove cups package if installed and not required"
          dnf:
            name: cups
            state: absent
          when: cups_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask cups services if required for dependencies"
          systemd:
            name: "{{ item }}"
            state: stopped
            masked: yes
          loop:
            - cups.socket
            - cups.service
          when:
            - cups_status.stdout | int > 0
            - cups_pkg_check.rc == 0
          failed_when: false

        - name: "Verify CUPS removal or service masking"
          shell: |
            PKG_CHECK=$(rpm -q cups 2>&1)
            SVC_CHECK=$(systemctl is-enabled cups.service 2>/dev/null | grep -c enabled)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: Package removed"
            elif [ "$SVC_CHECK" -eq 0 ]; then
              echo "COMPLIANT: Services masked"
            else
              echo "NON-COMPLIANT"
            fi
          register: cups_verify
          changed_when: false

        - name: "Display CUPS remediation status"
          debug:
            msg: |
              Control 2.1.11 Status:
              - Profile Level: Level 1 (Server)
              - Type: Automated remediation
              - Package: cups
              - Status: {{ cups_verify.stdout }}

        - name: "Create CUPS documentation"
          copy:
            dest: /root/CIS_2.1.11_print_server.txt
            content: |
              ========================================
              CIS Control 2.1.11
              Ensure print server services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              
              Description:
              The Common Unix Print System (CUPS) provides the ability to print to local 
              and network printers. Unless printing is required, CUPS should be removed 
              to reduce the attack surface.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if package is installed:
              # rpm -q cups
              
              If package installed, verify services are masked:
              # systemctl is-enabled cups.socket cups.service
              
              REMEDIATION
              ========================================
              
              Remove package:
              # dnf remove cups
              
              OR if required for dependencies, mask services:
              # systemctl stop cups.socket cups.service
              # systemctl mask cups.socket cups.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ cups_verify.stdout }}
              Package Check: {{ cups_pkg_check.rc }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.12 Ensure rpcbind services are not in use (Automated)"
      block:
        - name: "Check if rpcbind package is installed"
          command: rpm -q rpcbind
          register: rpcbind_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check rpcbind.service and rpcbind.socket enabled/active status"
          shell: systemctl is-enabled rpcbind.socket rpcbind.service 2>/dev/null | grep -c enabled
          register: rpcbind_status
          changed_when: false
          failed_when: false

        - name: "Remove rpcbind package if installed and not required"
          dnf:
            name: rpcbind
            state: absent
          when: rpcbind_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask rpcbind services if required for dependencies"
          systemd:
            name: "{{ item }}"
            state: stopped
            masked: yes
          loop:
            - rpcbind.socket
            - rpcbind.service
          when:
            - rpcbind_status.stdout | int > 0
            - rpcbind_pkg_check.rc == 0
          failed_when: false

        - name: "Verify rpcbind removal or service masking"
          shell: |
            PKG_CHECK=$(rpm -q rpcbind 2>&1)
            SVC_CHECK=$(systemctl is-enabled rpcbind.service 2>/dev/null | grep -c enabled)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: Package removed"
            elif [ "$SVC_CHECK" -eq 0 ]; then
              echo "COMPLIANT: Services masked"
            else
              echo "NON-COMPLIANT"
            fi
          register: rpcbind_verify
          changed_when: false

        - name: "Display rpcbind remediation status"
          debug:
            msg: |
              Control 2.1.12 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: rpcbind
              - Status: {{ rpcbind_verify.stdout }}

        - name: "Create rpcbind documentation"
          copy:
            dest: /root/CIS_2.1.12_rpcbind_services.txt
            content: |
              ========================================
              CIS Control 2.1.12
              Ensure rpcbind services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              rpcbind is a service that maps RPC services to ports. A small UDP request 
              (~82 bytes) to rpcbind generates a large response (7x-28x amplification), 
              making it suitable for DDoS attacks. Unless required, it should be removed.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if package is installed:
              # rpm -q rpcbind
              
              If package installed, verify services are masked:
              # systemctl is-enabled rpcbind.socket rpcbind.service
              
              REMEDIATION
              ========================================
              
              Remove package:
              # dnf remove rpcbind
              
              OR if required for dependencies, mask services:
              # systemctl stop rpcbind.socket rpcbind.service
              # systemctl mask rpcbind.socket rpcbind.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ rpcbind_verify.stdout }}
              Package Check: {{ rpcbind_pkg_check.rc }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-6, CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.13 Ensure rsync services are not in use (Automated)"
      block:
        - name: "Check if rsync-daemon package is installed"
          command: rpm -q rsync-daemon
          register: rsync_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check rsyncd.service and rsyncd.socket enabled/active status"
          shell: systemctl is-enabled rsyncd.socket rsyncd.service 2>/dev/null | grep -c enabled
          register: rsync_status
          changed_when: false
          failed_when: false

        - name: "Remove rsync-daemon package if installed and not required"
          dnf:
            name: rsync-daemon
            state: absent
          when: rsync_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask rsyncd services if required for dependencies"
          systemd:
            name: "{{ item }}"
            state: stopped
            masked: yes
          loop:
            - rsyncd.socket
            - rsyncd.service
          when:
            - rsync_status.stdout | int > 0
            - rsync_pkg_check.rc == 0
          failed_when: false

        - name: "Verify rsync removal or service masking"
          shell: |
            PKG_CHECK=$(rpm -q rsync-daemon 2>&1)
            SVC_CHECK=$(systemctl is-enabled rsyncd.service 2>/dev/null | grep -c enabled)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: Package removed"
            elif [ "$SVC_CHECK" -eq 0 ]; then
              echo "COMPLIANT: Services masked"
            else
              echo "NON-COMPLIANT"
            fi
          register: rsync_verify
          changed_when: false

        - name: "Display rsync remediation status"
          debug:
            msg: |
              Control 2.1.13 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: rsync-daemon
              - Status: {{ rsync_verify.stdout }}

        - name: "Create rsync documentation"
          copy:
            dest: /root/CIS_2.1.13_rsync_services.txt
            content: |
              ========================================
              CIS Control 2.1.13
              Ensure rsync services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              rsyncd.service can be used to synchronize files between systems. The service 
              uses unencrypted protocols for communication and should be removed unless 
              specifically required.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if package is installed:
              # rpm -q rsync-daemon
              
              If package installed, verify services are masked:
              # systemctl is-enabled rsyncd.socket rsyncd.service
              
              REMEDIATION
              ========================================
              
              Remove package:
              # dnf remove rsync-daemon
              
              OR if required for dependencies, mask services:
              # systemctl stop rsyncd.socket rsyncd.service
              # systemctl mask rsyncd.socket rsyncd.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ rsync_verify.stdout }}
              Package Check: {{ rsync_pkg_check.rc }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-6, CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.14 Ensure samba file server services are not in use (Automated)"
      block:
        - name: "Check if samba package is installed"
          command: rpm -q samba
          register: samba_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check smb.service enabled/active status"
          shell: systemctl is-enabled smb.service 2>/dev/null && systemctl is-active smb.service 2>/dev/null
          register: smb_status
          changed_when: false
          failed_when: false

        - name: "Remove samba package if installed and not required"
          dnf:
            name: samba
            state: absent
          when: samba_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask smb.service if required for dependencies"
          systemd:
            name: smb.service
            state: stopped
            masked: yes
          when:
            - smb_status.rc == 0
            - samba_pkg_check.rc == 0
          failed_when: false

        - name: "Verify Samba removal or service masking"
          shell: |
            PKG_CHECK=$(rpm -q samba 2>&1)
            SVC_CHECK=$(systemctl is-enabled smb.service 2>/dev/null | grep -c enabled)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: Package removed"
            elif [ "$SVC_CHECK" -eq 0 ]; then
              echo "COMPLIANT: Service masked"
            else
              echo "NON-COMPLIANT"
            fi
          register: samba_verify
          changed_when: false

        - name: "Display Samba remediation status"
          debug:
            msg: |
              Control 2.1.14 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: samba
              - Status: {{ samba_verify.stdout }}

        - name: "Create Samba documentation"
          copy:
            dest: /root/CIS_2.1.14_samba_services.txt
            content: |
              ========================================
              CIS Control 2.1.14
              Ensure Samba file server services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The Samba daemon allows systems to share file systems and directories with 
              Windows systems via the SMB protocol. Unless file sharing with Windows is 
              required, Samba should be removed.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if package is installed:
              # rpm -q samba
              
              If package installed, verify service is masked:
              # systemctl is-enabled smb.service
              # systemctl is-active smb.service
              
              REMEDIATION
              ========================================
              
              Remove package:
              # dnf remove samba
              
              OR if required for dependencies, mask service:
              # systemctl stop smb.service
              # systemctl mask smb.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ samba_verify.stdout }}
              Package Check: {{ samba_pkg_check.rc }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-6, CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.15 Ensure snmp services are not in use (Automated)"
      block:
        - name: "Check if net-snmp package is installed"
          command: rpm -q net-snmp
          register: snmp_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check snmpd.service enabled/active status"
          shell: systemctl is-enabled snmpd.service 2>/dev/null && systemctl is-active snmpd.service 2>/dev/null
          register: snmp_status
          changed_when: false
          failed_when: false

        - name: "Remove net-snmp package if installed and not required"
          dnf:
            name: net-snmp
            state: absent
          when: snmp_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask snmpd.service if required for dependencies"
          systemd:
            name: snmpd.service
            state: stopped
            masked: yes
          when:
            - snmp_status.rc == 0
            - snmp_pkg_check.rc == 0
          failed_when: false

        - name: "Verify SNMP removal or service masking"
          shell: |
            PKG_CHECK=$(rpm -q net-snmp 2>&1)
            SVC_CHECK=$(systemctl is-enabled snmpd.service 2>/dev/null | grep -c enabled)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: Package removed"
            elif [ "$SVC_CHECK" -eq 0 ]; then
              echo "COMPLIANT: Service masked"
            else
              echo "NON-COMPLIANT"
            fi
          register: snmp_verify
          changed_when: false

        - name: "Display SNMP remediation status"
          debug:
            msg: |
              Control 2.1.15 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: net-snmp
              - Status: {{ snmp_verify.stdout }}

        - name: "Create SNMP documentation"
          copy:
            dest: /root/CIS_2.1.15_snmp_services.txt
            content: |
              ========================================
              CIS Control 2.1.15
              Ensure SNMP services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              Simple Network Management Protocol (SNMP) is used for monitoring network 
              equipment. SNMPv1 transmits data in clear text and lacks authentication. 
              Unless required, SNMP should be removed.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if package is installed:
              # rpm -q net-snmp
              
              If package installed, verify service is masked:
              # systemctl is-enabled snmpd.service
              # systemctl is-active snmpd.service
              
              REMEDIATION
              ========================================
              
              Remove package:
              # dnf remove net-snmp
              
              OR if required for dependencies, mask service:
              # systemctl stop snmpd.service
              # systemctl mask snmpd.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ snmp_verify.stdout }}
              Package Check: {{ snmp_pkg_check.rc }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.16 Ensure telnet server services are not in use (Automated)"
      block:
        - name: "Check if telnet-server package is installed"
          command: rpm -q telnet-server
          register: telnet_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check telnet.socket enabled/active status"
          shell: systemctl is-enabled telnet.socket 2>/dev/null && systemctl is-active telnet.socket 2>/dev/null
          register: telnet_status
          changed_when: false
          failed_when: false

        - name: "Remove telnet-server package if installed and not required"
          dnf:
            name: telnet-server
            state: absent
          when: telnet_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask telnet.socket if required for dependencies"
          systemd:
            name: telnet.socket
            state: stopped
            masked: yes
          when:
            - telnet_status.rc == 0
            - telnet_pkg_check.rc == 0
          failed_when: false

        - name: "Verify Telnet removal or service masking"
          shell: |
            PKG_CHECK=$(rpm -q telnet-server 2>&1)
            SVC_CHECK=$(systemctl is-enabled telnet.socket 2>/dev/null | grep -c enabled)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: Package removed"
            elif [ "$SVC_CHECK" -eq 0 ]; then
              echo "COMPLIANT: Service masked"
            else
              echo "NON-COMPLIANT"
            fi
          register: telnet_verify
          changed_when: false

        - name: "Display Telnet remediation status"
          debug:
            msg: |
              Control 2.1.16 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: telnet-server
              - Status: {{ telnet_verify.stdout }}

        - name: "Create Telnet documentation"
          copy:
            dest: /root/CIS_2.1.16_telnet_server.txt
            content: |
              ========================================
              CIS Control 2.1.16
              Ensure Telnet server services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The Telnet protocol is insecure and unencrypted. Credentials sent via Telnet 
              can be easily captured. SSH provides a secure alternative and should be used 
              instead. Telnet server should be removed.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if package is installed:
              # rpm -q telnet-server
              
              If package installed, verify socket is masked:
              # systemctl is-enabled telnet.socket
              # systemctl is-active telnet.socket
              
              REMEDIATION
              ========================================
              
              Remove package:
              # dnf remove telnet-server
              
              OR if required for dependencies, mask socket:
              # systemctl stop telnet.socket
              # systemctl mask telnet.socket
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ telnet_verify.stdout }}
              Package Check: {{ telnet_pkg_check.rc }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-7, CM-11
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.17 Ensure tftp server services are not in use (Automated)"
      block:
        - name: "Check if tftp-server package is installed"
          command: rpm -q tftp-server
          register: tftp_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check tftp.socket and tftp.service enabled/active status"
          shell: systemctl is-enabled tftp.socket tftp.service 2>/dev/null | grep -c enabled
          register: tftp_status
          changed_when: false
          failed_when: false

        - name: "Remove tftp-server package if installed and not required"
          dnf:
            name: tftp-server
            state: absent
          when: tftp_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask TFTP services if required for dependencies"
          systemd:
            name: "{{ item }}"
            state: stopped
            masked: yes
          loop:
            - tftp.socket
            - tftp.service
          when:
            - tftp_status.stdout | int > 0
            - tftp_pkg_check.rc == 0
          failed_when: false

        - name: "Verify TFTP removal or service masking"
          shell: |
            PKG_CHECK=$(rpm -q tftp-server 2>&1)
            SVC_CHECK=$(systemctl is-enabled tftp.service 2>/dev/null | grep -c enabled)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: Package removed"
            elif [ "$SVC_CHECK" -eq 0 ]; then
              echo "COMPLIANT: Services masked"
            else
              echo "NON-COMPLIANT"
            fi
          register: tftp_verify
          changed_when: false

        - name: "Display TFTP remediation status"
          debug:
            msg: |
              Control 2.1.17 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: tftp-server
              - Status: {{ tftp_verify.stdout }}

        - name: "Create TFTP documentation"
          copy:
            dest: /root/CIS_2.1.17_tftp_server.txt
            content: |
              ========================================
              CIS Control 2.1.17
              Ensure TFTP server services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              Trivial File Transfer Protocol (TFTP) is a simple protocol for exchanging 
              files. It lacks encryption, access control, and authentication. Unless 
              specifically required for PXE boot, TFTP should be removed.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if package is installed:
              # rpm -q tftp-server
              
              If package installed, verify services are masked:
              # systemctl is-enabled tftp.socket tftp.service
              
              REMEDIATION
              ========================================
              
              Remove package:
              # dnf remove tftp-server
              
              OR if required for dependencies, mask services:
              # systemctl stop tftp.socket tftp.service
              # systemctl mask tftp.socket tftp.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ tftp_verify.stdout }}
              Package Check: {{ tftp_pkg_check.rc }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.18 Ensure web proxy server services are not in use (Automated)"
      block:
        - name: "Check if squid package is installed"
          command: rpm -q squid
          register: squid_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check squid.service enabled/active status"
          shell: systemctl is-enabled squid.service 2>/dev/null && systemctl is-active squid.service 2>/dev/null
          register: squid_status
          changed_when: false
          failed_when: false

        - name: "Remove squid package if installed and not required"
          dnf:
            name: squid
            state: absent
          when: squid_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask squid.service if required for dependencies"
          systemd:
            name: squid.service
            state: stopped
            masked: yes
          when:
            - squid_status.rc == 0
            - squid_pkg_check.rc == 0
          failed_when: false

        - name: "Verify Squid removal or service masking"
          shell: |
            PKG_CHECK=$(rpm -q squid 2>&1)
            SVC_CHECK=$(systemctl is-enabled squid.service 2>/dev/null | grep -c enabled)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: Package removed"
            elif [ "$SVC_CHECK" -eq 0 ]; then
              echo "COMPLIANT: Service masked"
            else
              echo "NON-COMPLIANT"
            fi
          register: squid_verify
          changed_when: false

        - name: "Display Squid remediation status"
          debug:
            msg: |
              Control 2.1.18 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: squid
              - Status: {{ squid_verify.stdout }}

        - name: "Create Squid documentation"
          copy:
            dest: /root/CIS_2.1.18_web_proxy.txt
            content: |
              ========================================
              CIS Control 2.1.18
              Ensure web proxy server services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              Squid is a standard proxy server used for HTTP/HTTPS caching and filtering. 
              Unless the system is specifically set up as a proxy server, Squid should be 
              removed to reduce the attack surface.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if package is installed:
              # rpm -q squid
              
              If package installed, verify service is masked:
              # systemctl is-enabled squid.service
              # systemctl is-active squid.service
              
              REMEDIATION
              ========================================
              
              Remove package:
              # dnf remove squid
              
              OR if required for dependencies, mask service:
              # systemctl stop squid.service
              # systemctl mask squid.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ squid_verify.stdout }}
              Package Check: {{ squid_pkg_check.rc }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-6, CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.19 Ensure web server services are not in use (Automated)"
      block:
        - name: "Check if httpd package is installed"
          command: rpm -q httpd
          register: httpd_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check if nginx package is installed"
          command: rpm -q nginx
          register: nginx_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check httpd.service and httpd.socket enabled/active status"
          shell: systemctl is-enabled httpd.socket httpd.service 2>/dev/null | grep -c enabled
          register: httpd_status
          changed_when: false
          failed_when: false

        - name: "Check nginx.service enabled/active status"
          shell: systemctl is-enabled nginx.service 2>/dev/null | grep -c enabled
          register: nginx_status
          changed_when: false
          failed_when: false

        - name: "Remove httpd package if installed and not required"
          dnf:
            name: httpd
            state: absent
          when: httpd_pkg_check.rc == 0
          failed_when: false

        - name: "Remove nginx package if installed and not required"
          dnf:
            name: nginx
            state: absent
          when: nginx_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask httpd services if required for dependencies"
          systemd:
            name: "{{ item }}"
            state: stopped
            masked: yes
          loop:
            - httpd.socket
            - httpd.service
          when:
            - httpd_status.stdout | int > 0
            - httpd_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask nginx.service if required for dependencies"
          systemd:
            name: nginx.service
            state: stopped
            masked: yes
          when:
            - nginx_status.stdout | int > 0
            - nginx_pkg_check.rc == 0
          failed_when: false

        - name: "Verify web servers removal or service masking"
          shell: |
            HTTPD=$(rpm -q httpd 2>&1)
            NGINX=$(rpm -q nginx 2>&1)
            STATUS="COMPLIANT"
            [[ "$HTTPD" != *"not installed"* ]] && STATUS="NON-COMPLIANT"
            [[ "$NGINX" != *"not installed"* ]] && STATUS="NON-COMPLIANT"
            echo "$STATUS"
          register: webserver_verify
          changed_when: false

        - name: "Display web servers remediation status"
          debug:
            msg: |
              Control 2.1.19 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Packages: httpd, nginx
              - Status: {{ webserver_verify.stdout }}

        - name: "Create web servers documentation"
          copy:
            dest: /root/CIS_2.1.19_web_servers.txt
            content: |
              ========================================
              CIS Control 2.1.19
              Ensure web server services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              Web servers (Apache httpd and nginx) provide the ability to host web site 
              content. Unless there is a local site approved requirement to run a web 
              server, these packages should be removed to reduce the attack surface.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if packages are installed:
              # rpm -q httpd nginx
              
              If packages installed, verify services are masked:
              # systemctl is-enabled httpd.socket httpd.service
              # systemctl is-enabled nginx.service
              
              REMEDIATION
              ========================================
              
              Remove packages:
              # dnf remove httpd nginx
              
              OR if required for dependencies, mask services:
              # systemctl stop httpd.socket httpd.service
              # systemctl mask httpd.socket httpd.service
              # systemctl stop nginx.service
              # systemctl mask nginx.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ webserver_verify.stdout }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

    - name: "2.1.20 Ensure xinetd services are not in use (Automated)"
      block:
        - name: "Check if xinetd package is installed"
          command: rpm -q xinetd
          register: xinetd_pkg_check
          changed_when: false
          failed_when: false

        - name: "Check xinetd.service enabled/active status"
          shell: systemctl is-enabled xinetd.service 2>/dev/null && systemctl is-active xinetd.service 2>/dev/null
          register: xinetd_status
          changed_when: false
          failed_when: false

        - name: "Remove xinetd package if installed and not required"
          dnf:
            name: xinetd
            state: absent
          when: xinetd_pkg_check.rc == 0
          failed_when: false

        - name: "Stop and mask xinetd.service if required for dependencies"
          systemd:
            name: xinetd.service
            state: stopped
            masked: yes
          when:
            - xinetd_status.rc == 0
            - xinetd_pkg_check.rc == 0
          failed_when: false

        - name: "Verify xinetd removal or service masking"
          shell: |
            PKG_CHECK=$(rpm -q xinetd 2>&1)
            SVC_CHECK=$(systemctl is-enabled xinetd.service 2>/dev/null | grep -c enabled)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: Package removed"
            elif [ "$SVC_CHECK" -eq 0 ]; then
              echo "COMPLIANT: Service masked"
            else
              echo "NON-COMPLIANT"
            fi
          register: xinetd_verify
          changed_while: false

        - name: "Display xinetd remediation status"
          debug:
            msg: |
              Control 2.1.20 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: xinetd
              - Status: {{ xinetd_verify.stdout }}

        - name: "Create xinetd documentation"
          copy:
            dest: /root/CIS_2.1.20_xinetd.txt
            content: |
              ========================================
              CIS Control 2.1.20
              Ensure xinetd services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The eXtended InterNET Daemon (xinetd) is a super daemon that replaced the 
              original inetd daemon. xinetd listens for well known services and dispatches 
              the appropriate daemon. Unless xinetd services are required, the package 
              should be removed to reduce the attack surface.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if package is installed:
              # rpm -q xinetd
              
              If package installed, verify service is masked:
              # systemctl is-enabled xinetd.service
              # systemctl is-active xinetd.service
              
              REMEDIATION
              ========================================
              
              Remove package:
              # dnf remove xinetd
              
              OR if required for dependencies, mask service:
              # systemctl stop xinetd.service
              # systemctl mask xinetd.service
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ xinetd_verify.stdout }}
              Package Check: {{ xinetd_pkg_check.rc }}
              
              REFERENCES
              ========================================
              - NIST SP 800-53 Rev. 5: CM-7
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
            owner: root
            group: root
            mode: '0600'

        - name: "Create Section 2.1 Summary Documentation"
          copy:
            dest: /root/CIS_2.1_services_summary.txt
            content: |
              ========================================
              CIS Red Hat Enterprise Linux 8 Benchmark
              Section 2.1 - inetd Services Summary
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              OVERVIEW
              ========================================
              
              This section covers 17 controls (2.1.4-2.1.20) for disabling unnecessary 
              network services to reduce the attack surface of Red Hat Enterprise Linux 8 
              systems.
              
              CONTROLS IMPLEMENTED
              ========================================
              
              2.1.4 - DHCP Server: {{ dhcp_verify.stdout|default('Not assessed') }}
              Package: dhcp-server
              Services: dhcpd.service, dhcpd6.service
              
              2.1.5 - DNS Server: {{ nameserver_verify.stdout|default('Not assessed') }}
              Package: bind
              Service: named.service
              
              2.1.6 - dnsmasq: {{ dnsmasq_verify.stdout|default('Not assessed') }}
              Package: dnsmasq
              Service: dnsmasq.service
              
              2.1.7 - FTP Server: {{ vsftpd_verify.stdout|default('Not assessed') }}
              Package: vsftpd
              Service: vsftpd.service
              
              2.1.8 - Message Access Servers: {{ mail_services_verify.stdout|default('Not assessed') }}
              Packages: dovecot, cyrus-imapd
              Services: dovecot.socket, dovecot.service, cyrus-imapd.service
              
              2.1.9 - NFS: {{ nfs_verify.stdout|default('Not assessed') }}
              Package: nfs-utils
              Service: nfs-server.service
              
              2.1.10 - NIS: {{ nis_verify.stdout|default('Not assessed') }}
              Package: ypserv
              Service: ypserv.service
              
              2.1.11 - Print Server: {{ cups_verify.stdout|default('Not assessed') }}
              Package: cups
              Services: cups.socket, cups.service
              
              2.1.12 - rpcbind: {{ rpcbind_verify.stdout|default('Not assessed') }}
              Package: rpcbind
              Services: rpcbind.socket, rpcbind.service
              
              2.1.13 - rsync: {{ rsync_verify.stdout|default('Not assessed') }}
              Package: rsync-daemon
              Services: rsyncd.socket, rsyncd.service
              
              2.1.14 - Samba: {{ samba_verify.stdout|default('Not assessed') }}
              Package: samba
              Service: smb.service
              
              2.1.15 - SNMP: {{ snmp_verify.stdout|default('Not assessed') }}
              Package: net-snmp
              Service: snmpd.service
              
              2.1.16 - Telnet: {{ telnet_verify.stdout|default('Not assessed') }}
              Package: telnet-server
              Service: telnet.socket
              
              2.1.17 - TFTP: {{ tftp_verify.stdout|default('Not assessed') }}
              Package: tftp-server
              Services: tftp.socket, tftp.service
              
              2.1.18 - Web Proxy: {{ squid_verify.stdout|default('Not assessed') }}
              Package: squid
              Service: squid.service
              
              2.1.19 - Web Servers: {{ webserver_verify.stdout|default('Not assessed') }}
              Packages: httpd, nginx
              Services: httpd.socket, httpd.service, nginx.service
              
              2.1.20 - xinetd: {{ xinetd_verify.stdout|default('Not assessed') }}
              Package: xinetd
              Service: xinetd.service
              
              REMEDIATION STRATEGY
              ========================================
              
              For each service, two approaches are available:
              
              1. PREFERRED - Remove the package:
                 # dnf remove [package-name]
              
              2. ALTERNATIVE - Stop and mask the service (if required as dependency):
                 # systemctl stop [service-name]
                 # systemctl mask [service-name]
              
              AUDIT ALL SERVICES
              ========================================
              
              To audit all unnecessary services at once:
              
              # rpm -q dhcp-server bind dnsmasq vsftpd dovecot cyrus-imapd nfs-utils
              # rpm -q ypserv cups rpcbind rsync-daemon samba net-snmp telnet-server
              # rpm -q tftp-server squid httpd nginx xinetd
              
              Check masked status:
              # systemctl list-unit-files | grep masked
              
              SECURITY RATIONALE
              ========================================
              
              Unnecessary network services:
              - Increase the attack surface of the system
              - May contain unpatched vulnerabilities
              - Could be exploited by attackers
              - Should be removed unless specifically required
              
              Each service requires approval by local site policy before installation. 
              If a service is needed as a dependency, it should be masked rather than removed.
              
              COMPLIANCE NOTES
              ========================================
              
              - All controls in section 2.1 are Automated
              - Level 1 applicability (Server and Workstation)
              - Requires root/sudo privileges
              - May require reboot after removal
              - Check dependencies before removal
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-6, CM-7
              - NIST SP 800-53A: CM-7.1
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "2.2.1 Ensure ftp client is not installed (Automated)"
      block:
        - name: "Check if ftp package is installed"
          command: rpm -q ftp
          register: ftp_pkg_check
          changed_when: false
          failed_when: false

        - name: "Remove ftp package if installed"
          dnf:
            name: ftp
            state: absent
          when: ftp_pkg_check.rc == 0
          failed_when: false

        - name: "Verify ftp package removal"
          shell: |
            PKG_CHECK=$(rpm -q ftp 2>&1)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: ftp package removed"
            else
              echo "NON-COMPLIANT: ftp package still installed"
            fi
          register: ftp_verify
          changed_when: false

        - name: "Display FTP client remediation status"
          debug:
            msg: |
              Control 2.2.1 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: ftp
              - Status: {{ ftp_verify.stdout }}

        - name: "Create FTP client documentation"
          copy:
            dest: /root/CIS_2.2.1_ftp_client.txt
            content: |
              ========================================
              CIS Control 2.2.1
              Ensure FTP client is not installed
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              FTP (File Transfer Protocol) is a traditional tool for transferring files 
              between systems. FTP does not protect the confidentiality of data or 
              authentication credentials as it transmits in clear text. SFTP should be 
              used instead if file transfer is required. The ftp client package should 
              be removed unless specifically required.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if ftp package is installed:
              # rpm -q ftp
              
              Expected result: package ftp is not installed
              
              REMEDIATION
              ========================================
              
              Remove ftp package:
              # dnf remove ftp
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ ftp_verify.stdout }}
              Package Check: {{ ftp_pkg_check.rc }}
              
              SECURITY RATIONALE
              ========================================
              
              Issues with FTP:
              - Transmits credentials in clear text
              - No encryption of data in transit
              - Susceptible to man-in-the-middle attacks
              - Authentication can be easily captured
              
              Recommended Alternatives:
              - SFTP (Secure File Transfer Protocol) - encrypted, uses SSH
              - SCP (Secure Copy Protocol) - encrypted alternative
              - rsync over SSH - efficient and secure
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Level 1 applicability (Server and Workstation)
              - Only removes the client package (not server)
              - Does not affect other file transfer mechanisms
              - If SFTP is available, ftp is not needed
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-7 (Least Functionality)
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
              - RFC 959 (FTP Protocol Standard)
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "2.2.3 Ensure nis client is not installed (Automated)"
      block:
        - name: "Check if ypbind package is installed"
          command: rpm -q ypbind
          register: ypbind_pkg_check
          changed_when: false
          failed_when: false

        - name: "Remove ypbind package if installed"
          dnf:
            name: ypbind
            state: absent
          when: ypbind_pkg_check.rc == 0
          failed_when: false

        - name: "Verify ypbind package removal"
          shell: |
            PKG_CHECK=$(rpm -q ypbind 2>&1)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: ypbind package removed"
            else
              echo "NON-COMPLIANT: ypbind package still installed"
            fi
          register: ypbind_verify
          changed_when: false

        - name: "Display NIS client remediation status"
          debug:
            msg: |
              Control 2.2.3 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: ypbind
              - Status: {{ ypbind_verify.stdout }}

        - name: "Create NIS client documentation"
          copy:
            dest: /root/CIS_2.2.3_nis_client.txt
            content: |
              ========================================
              CIS Control 2.2.3
              Ensure NIS client is not installed
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The Network Information Service (NIS), formerly known as Yellow Pages, 
              is a client-server directory service protocol used to distribute system 
              configuration files. The NIS client (ypbind) was used to bind a machine 
              to an NIS server and receive distributed configuration files. The ypbind 
              package should be removed unless specifically required.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if ypbind package is installed:
              # rpm -q ypbind
              
              Expected result: package ypbind is not installed
              
              REMEDIATION
              ========================================
              
              Remove ypbind package:
              # dnf remove ypbind
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ ypbind_verify.stdout }}
              Package Check: {{ ypbind_pkg_check.rc }}
              
              SECURITY RATIONALE
              ========================================
              
              NIS Security Issues:
              - Inherently insecure system architecture
              - Vulnerable to Denial of Service (DOS) attacks
              - Buffer overflow vulnerabilities
              - Poor authentication for querying NIS maps
              - Transmits sensitive data with weak security
              - Cleartext credential transmission
              - No built-in encryption
              
              Context Replacement by Modern Protocols:
              - NIS has been replaced by LDAP (Lightweight Directory Access Protocol)
              - Active Directory for Windows environments
              - Kerberos for strong authentication
              - Modern centralized directory services
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Level 1 applicability (Server and Workstation)
              - Removes the client package only (ypbind)
              - Does not affect NIS server packages
              - Clients may be removed after use in testing
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-7 (Least Functionality)
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "2.2.4 Ensure telnet client is not installed (Automated)"
      block:
        - name: "Check if telnet package is installed"
          command: rpm -q telnet
          register: telnet_pkg_check
          changed_when: false
          failed_when: false

        - name: "Remove telnet package if installed"
          dnf:
            name: telnet
            state: absent
          when: telnet_pkg_check.rc == 0
          failed_when: false

        - name: "Verify telnet package removal"
          shell: |
            PKG_CHECK=$(rpm -q telnet 2>&1)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: telnet package removed"
            else
              echo "NON-COMPLIANT: telnet package still installed"
            fi
          register: telnet_verify
          changed_when: false

        - name: "Display telnet client remediation status"
          debug:
            msg: |
              Control 2.2.4 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: telnet
              - Status: {{ telnet_verify.stdout }}

        - name: "Create telnet client documentation"
          copy:
            dest: /root/CIS_2.2.4_telnet_client.txt
            content: |
              ========================================
              CIS Control 2.2.4
              Ensure telnet client is not installed
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The telnet package contains the telnet client, which allows users to 
              start connections to other systems via the telnet protocol. Telnet is 
              an unencrypted remote access protocol and should not be used. The SSH 
              package provides an encrypted alternative and is included in most Linux 
              distributions. The telnet client package should be removed unless 
              specifically required.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if telnet package is installed:
              # rpm -q telnet
              
              Expected result: package telnet is not installed
              
              REMEDIATION
              ========================================
              
              Remove telnet package:
              # dnf remove telnet
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ telnet_verify.stdout }}
              Package Check: {{ telnet_pkg_check.rc }}
              
              SECURITY RATIONALE
              ========================================
              
              Telnet Security Issues:
              - Unencrypted transmission medium
              - Credentials transmitted in clear text
              - Session data completely visible to attackers
              - Easy credential theft via network sniffing
              - No confidentiality protection
              - No integrity protection
              - Vulnerable to man-in-the-middle attacks
              - Session hijacking possible
              
              Recommended Secure Alternative:
              - SSH (Secure Shell) - provides encryption
              - End-to-end encryption of session
              - Public key authentication available
              - Port forwarding capabilities
              - Built-in compression
              - Stronger authentication mechanisms
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Level 1 applicability (Server and Workstation)
              - Only removes the client package
              - Does not affect SSH availability
              - Clients may be removed after use in testing
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-7 (Least Functionality)
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
              - RFC 854 (Telnet Protocol Standard)
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "2.2.5 Ensure tftp client is not installed (Automated)"
      block:
        - name: "Check if tftp package is installed"
          command: rpm -q tftp
          register: tftp_pkg_check
          changed_when: false
          failed_when: false

        - name: "Remove tftp package if installed"
          dnf:
            name: tftp
            state: absent
          when: tftp_pkg_check.rc == 0
          failed_when: false

        - name: "Verify tftp package removal"
          shell: |
            PKG_CHECK=$(rpm -q tftp 2>&1)
            if [[ "$PKG_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: tftp package removed"
            else
              echo "NON-COMPLIANT: tftp package still installed"
            fi
          register: tftp_verify
          changed_when: false

        - name: "Display TFTP client remediation status"
          debug:
            msg: |
              Control 2.2.5 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: tftp
              - Status: {{ tftp_verify.stdout }}

        - name: "Create TFTP client documentation"
          copy:
            dest: /root/CIS_2.2.5_tftp_client.txt
            content: |
              ========================================
              CIS Control 2.2.5
              Ensure TFTP client is not installed
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              Trivial File Transfer Protocol (TFTP) is a simple protocol for 
              exchanging files between two TCP/IP machines. TFTP is an extremely 
              simple protocol used primarily for booting diskless workstations or 
              embedded devices. The tftp client package should be removed unless 
              specifically required for network appliance management or testing.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if tftp package is installed:
              # rpm -q tftp
              
              Expected result: package tftp is not installed
              
              REMEDIATION
              ========================================
              
              Remove tftp package:
              # dnf remove tftp
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ tftp_verify.stdout }}
              Package Check: {{ tftp_pkg_check.rc }}
              
              SECURITY RATIONALE
              ========================================
              
              TFTP Security Issues:
              - No built-in encryption
              - No authentication mechanism
              - No access control
              - Simple, minimal protocol design
              - Vulnerable to various attacks
              - File access exploitable
              - No confidentiality of data in transit
              - Easy to intercept and modify transfers
              
              Attack Scenarios:
              - Reading arbitrary files from system
              - Writing arbitrary files to system
              - Overwriting critical system files
              - Man-in-the-middle file injection
              - Directory traversal attacks
              
              Modern Alternatives:
              - SCP (Secure Copy) - encrypted file transfer
              - SFTP (SSH File Transfer Protocol) - encrypted
              - rsync over SSH - efficient secure transfer
              - HTTP/HTTPS - for web-based transfers
              - SMB/CIFS - for Windows file sharing
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Level 1 applicability (Server and Workstation)
              - Removes the client package only
              - Does not affect TFTP server packages
              - Primarily for testing/troubleshooting relief
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-7 (Least Functionality)
              - CIS Controls v8: 4.8 Uninstall or Disable Unnecessary Services
              - RFC 1350 (TFTP Protocol Standard)
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "2.3.1 Ensure time synchronization is in use (Automated)"
      block:
        - name: "Check if chrony package is installed"
          command: rpm -q chrony
          register: chrony_check
          changed_when: false
          failed_when: false

        - name: "Install chrony package if not present"
          dnf:
            name: chrony
            state: present
          when: chrony_check.rc != 0
          failed_when: false

        - name: "Verify chrony installation"
          shell: |
            CHRONY_CHECK=$(rpm -q chrony 2>&1)
            if [[ "$CHRONY_CHECK" == *"chrony"* ]]; then
              echo "COMPLIANT: chrony is installed"
            else
              echo "NON-COMPLIANT: chrony is not installed"
            fi
          register: chrony_verify
          changed_when: false

        - name: "Display chrony installation status"
          debug:
            msg: |
              Control 2.3.1 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Package: chrony
              - Status: {{ chrony_verify.stdout }}

        - name: "Create chrony installation documentation"
          copy:
            dest: /root/CIS_2.3.1_chrony_installation.txt
            content: |
              ========================================
              CIS Control 2.3.1
              Ensure time synchronization is in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              System time should be synchronized between all systems in an environment. 
              This is typically done by establishing an authoritative time server or set 
              of servers and having all systems synchronize their clocks to them. Chrony 
              is the primary time synchronization service used on modern RHEL systems.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if chrony package is installed:
              # rpm -q chrony
              
              Expected result: chrony-<version>
              
              REMEDIATION
              ========================================
              
              Install chrony package:
              # dnf install chrony
              
              Enable and start chronyd service:
              # systemctl enable --now chronyd
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ chrony_verify.stdout }}
              Package Check: {{ chrony_check.rc }}
              
              SECURITY RATIONALE
              ========================================
              
              Time Synchronization Importance:
              - Supports time-sensitive security mechanisms (Kerberos, authentication)
              - Ensures consistent log file timestamps across enterprise
              - Aids in forensic investigations and incident response
              - Prevents rate-based attack detection bypass
              - Required for SSL/TLS certificate validation timing
              - Supports secure event correlation across multiple systems
              
              Chrony Benefits:
              - NTP (Network Time Protocol) client and server
              - Modern, more accurate than older ntpd
              - Handles network disruptions gracefully
              - Works with virtual machines effectively
              - Supports hardware reference clocks
              - Resistant to man-in-the-middle attacks via authentication
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Level 1 applicability (Server and Workstation)
              - Chrony installation only (configuration in 2.3.2)
              - Does not configure time sources (handled separately)
              - Alternative time sync methods bypass this control
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: AU-3, AU-12 (Audit and Accountability)
              - CIS Controls v8: 8.4 Standardize Time Synchronization
              - RFC 5905 (NTP Protocol)
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "2.3.2 Ensure chrony is configured (Automated)"
      block:
        - name: "Check chronyd service status"
          systemctl:
            name: chronyd
            state: started
            enabled: yes
          failed_when: false

        - name: "Audit chrony configuration for time sources"
          shell: |
            CHRONY_CONFIG_CHECK=""
            if [ -f "/etc/chrony.conf" ]; then
              if grep -Psi '^\h*(server|pool)(\h+|\h*:\h*)' /etc/chrony.conf > /dev/null 2>&1; then
                FOUND_SOURCES=$(grep -Psi '^\h*(server|pool)(\h+|\h*:\h*)' /etc/chrony.conf | head -5)
                CHRONY_CONFIG_CHECK="PASS - Time sources configured:
            $FOUND_SOURCES"
              else
                CHRONY_CONFIG_CHECK="WARN - No time sources found in /etc/chrony.conf - manual configuration required"
              fi
            else
              CHRONY_CONFIG_CHECK="FAIL - /etc/chrony.conf not found"
            fi
            echo "$CHRONY_CONFIG_CHECK"
          register: chrony_config_check
          changed_when: false

        - name: "Display chrony configuration status"
          debug:
            msg: |
              Control 2.3.2 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated audit with manual remediation
              - Service: chronyd
              - Configuration Status:
              {{ chrony_config_check.stdout }}

        - name: "Create chrony configuration documentation"
          copy:
            dest: /root/CIS_2.3.2_chrony_configuration.txt
            content: |
              ========================================
              CIS Control 2.3.2
              Ensure chrony is configured
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              Chrony must be configured with appropriate time servers or pools to 
              synchronize system time. The configuration specifies which NTP servers 
              to use as authoritative time sources.
              
              AUDIT PROCEDURE
              ========================================
              
              Run the following command to verify chrony configuration:
              # grep -Psi '^\h*(server|pool)(\h+|\h*:\h*)' /etc/chrony.conf
              
              Expected result: At least one server or pool directive present
              
              Alternative audit method:
              #!/usr/bin/env bash
              {
                a_output=() a_output2=() a_config_files=("/etc/chrony.conf")
                l_include='(confdir|sourcedir)' l_parameter_name='(server|pool)'
                l_parameter_value='.+'
                while IFS= read -r l_conf_loc; do
                  l_dir="" l_ext=""
                  if [ -d "$l_conf_loc" ]; then
                    l_dir="$l_conf_loc" l_ext="*"
                  elif grep -Psq '\/\*\.([^#/\n\r]+)?\h*$' <<< "$l_conf_loc" || [ -f "$(readlink -f "$l_conf_loc")" ]; then
                    l_dir="$(dirname "$l_conf_loc")" l_ext="$(basename "$l_conf_loc")"
                  fi
                  if [[ -n "$l_dir" && -n "$l_ext" ]]; then
                    while IFS= read -r -d $'\0' l_file_name; do
                      [ -f "$(readlink -f "$l_file_name")" ] && a_config_files+=("$(readlink -f "$l_file_name")")
                    done < <(find -L "$l_dir" -type f -name "$l_ext" -print0 2>/dev/null)
                  fi
                done < <(awk '$1~/^\s*'"$l_include"'$/{print $2}' "${a_config_files[*]}" 2>/dev/null)
                for l_file in "${a_config_files[@]}"; do
                  l_parameter_line="$(grep -Psi '^\h*'"$l_parameter_name"'(\h+|\h*:\h*)'"$l_parameter_value"'\b' "$l_file")"
                  [ -n "$l_parameter_line" ] && a_output+=(" - Parameter: \"$(tr -d '()' <<< ${l_parameter_name//|/ or })\"" " Exists in the file: \"$l_file\" as:" "$l_parameter_line")
                done
                [ "${#a_output[@]}" -le "0" ] && a_output2+=(" - Parameter: \"$(tr -d '()' <<< ${l_parameter_name//|/ or })\"" " Does not exist in the chrony configuration")
                if [ "${#a_output2[@]}" -le 0 ]; then
                  printf '%s\n' "" "- Audit Result:" " ** PASS **" "${a_output[@]}" ""
                else
                  printf '%s\n' "" "- Audit Result:" " ** FAIL **" " - Reason(s) for audit failure:" "${a_output2[@]}"
                fi
              }
              
              REMEDIATION
              ========================================
              
              Edit /etc/chrony.conf and add or edit server/pool directives:
              
              Example configuration with pool directives (preferred):
              # /etc/chrony.conf
              pool time.nist.gov iburst maxsources 4
              pool 0.rhel.pool.ntp.org iburst
              pool 1.rhel.pool.ntp.org iburst
              
              Example configuration with server directives:
              # /etc/chrony.conf
              server time-a-g.nist.gov iburst
              server time-b-g.nist.gov iburst
              server time-c-g.nist.gov iburst
              
              Create drop-in configuration directory:
              #!/usr/bin/env bash
              {
                [ ! -d "/etc/chrony.d/" ] && mkdir -p /etc/chrony.d/
                cat > /etc/chrony.d/ntp-sources.conf << EOF
              server time-a-g.nist.gov iburst
              server time-b-g.nist.gov iburst
              server time-c-g.nist.gov iburst
              EOF
              }
              
              Reload chrony configuration:
              # systemctl reload-or-restart chronyd
              
              IMPLEMENTATION STATUS
              ========================================
              Current Configuration: {{ chrony_config_check.stdout }}
              
              SECURITY RATIONALE
              ========================================
              
              Why Time Source Configuration Matters:
              - Ensures synchronization with authoritative time sources
              - Prevents use of unreliable or untrusted time servers
              - Supports time accuracy for security mechanisms
              - Enables proper log timestamp correlation
              - Supports forensic investigation accuracy
              
              Best Practices for Time Source Selection:
              - Use multiple time sources (minimum 3 recommended)
              - Prefer public time servers (NIST, pool.ntp.org)
              - Use iburst option for faster initial sync
              - Configure maxsources for pool directives
              - Implement local time source if disconnected from network
              
              Pool vs Server Directives:
              - Pool: Used for NTP server pools (resolves to multiple addresses)
              - Server: Used for specific NTP servers (single address)
              - Pool preferred for resilience and load distribution
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated audit with manual remediation
              - Level 1 applicability (Server and Workstation)
              - Requires active chronyd service (control 2.3.1)
              - Does not require specific time source restrictions
              - Configuration appropriate to local environment required
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: AU-3, AU-12
              - CIS Controls v8: 8.4 Standardize Time Synchronization
              - RFC 5905 (NTP Protocol)
              - Chrony Documentation
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "2.3.3 Ensure chrony is not run as the root user (Automated)"
      block:
        - name: "Check chronyd service options in sysconfig"
          shell: |
            if [ -f "/etc/sysconfig/chronyd" ]; then
              if grep -Psi -- '^\h*OPTIONS=\"?\h*([^#\n\r]+\h+)?-u\h+root\b' /etc/sysconfig/chronyd > /dev/null 2>&1; then
                echo "NON-COMPLIANT: chrony configured to run as root"
              else
                echo "COMPLIANT: chrony not configured to run as root"
              fi
            else
              echo "COMPLIANT: /etc/sysconfig/chronyd not configured with -u root"
            fi
          register: chronyd_user_check
          changed_when: false

        - name: "Remove -u root from chronyd options if present"
          shell: |
            if [ -f "/etc/sysconfig/chronyd" ]; then
              if grep -Psi -- '^\h*OPTIONS=\"?\h*([^#\n\r]+\h+)?-u\h+root\b' /etc/sysconfig/chronyd > /dev/null 2>&1; then
                sed -i 's/OPTIONS="\([^"]*\) -u root\([^"]*\)"/OPTIONS="\1\2"/g' /etc/sysconfig/chronyd
                sed -i 's/OPTIONS="\([^"]*\)-u root \([^"]*\)"/OPTIONS="\1\2"/g' /etc/sysconfig/chronyd
              fi
            fi
          changed_when: false
          failed_when: false

        - name: "Verify chronyd user configuration"
          shell: |
            if [ -f "/etc/sysconfig/chronyd" ]; then
              if grep -Psi -- '^\h*OPTIONS=\"?\h*([^#\n\r]+\h+)?-u\h+root\b' /etc/sysconfig/chronyd > /dev/null 2>&1; then
                echo "NON-COMPLIANT: chrony still configured to run as root"
              else
                echo "COMPLIANT: chrony not configured to run as root"
              fi
            else
              echo "COMPLIANT: /etc/sysconfig/chronyd not configured with -u root"
            fi
          register: chronyd_user_verify
          changed_when: false

        - name: "Reload chronyd service if configuration changed"
          systemctl:
            name: chronyd
            state: reloaded
          failed_when: false

        - name: "Display chronyd user configuration status"
          debug:
            msg: |
              Control 2.3.3 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Service: chronyd
              - User Configuration: {{ chronyd_user_verify.stdout }}

        - name: "Create chronyd user configuration documentation"
          copy:
            dest: /root/CIS_2.3.3_chronyd_user.txt
            content: |
              ========================================
              CIS Control 2.3.3
              Ensure chrony is not run as the root user
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The chronyd service should run as a dedicated non-root user for security. 
              By default, chronyd runs as the 'chrony' user. Running any service as root 
              increases the risk if that service becomes compromised.
              
              AUDIT PROCEDURE
              ========================================
              
              Check /etc/sysconfig/chronyd for -u root option:
              # grep -Psi -- '^\h*OPTIONS=\"?\h*([^#\n\r]+\h+)?-u\h+root\b' /etc/sysconfig/chronyd
              
              Expected result: Nothing returned (no output)
              
              Verify chronyd running user via process inspection:
              # ps -ef | grep chronyd | grep -v grep
              
              Expected: chronyd running as 'chrony' user, not 'root'
              
              Check systemd service configuration:
              # systemctl show -p User chronyd
              
              Expected: User=chrony (or empty for default)
              
              REMEDIATION
              ========================================
              
              Edit /etc/sysconfig/chronyd and remove '-u root' if present:
              
              Before (non-compliant):
              OPTIONS="-u root -F 2"
              
              After (compliant):
              OPTIONS="-F 2"
              
              Ensure only valid chronyd options remain:
              # vi /etc/sysconfig/chronyd
              
              Valid chronyd options:
              -F {n}  : Force clock frequency to be {n} ppm
              -n      : Do not daemonize (stay in foreground)
              -q      : Enable quick mode (faster frequency adjustment)
              -s      : Set system time from RTC
              -x      : Disable kernel RTC synchronization
              
              Reload chronyd service:
              # systemctl reload-or-restart chronyd
              
              IMPLEMENTATION STATUS
              ========================================
              Current Status: {{ chronyd_user_verify.stdout }}
              
              SECURITY RATIONALE
              ========================================
              
              Principle of Least Privilege:
              - Running services as non-root limits privilege escalation risk
              - Root-compromised services = full system compromise
              - Dedicated service users have minimal system permissions
              - Reduces attack surface if service is exploited
              
              Chronyd-Specific Security:
              - Uses 'chrony' user by default (UID typically > 1000)
              - Minimal file system access (only /var/lib/chrony)
              - No shell access (typically /sbin/nologin)
              - Cannot execute arbitrary commands
              
              Attack Scenario Prevention:
              - Would-be attacker cannot gain root access via chronyd
              - Cannot modify system files or user accounts
              - Cannot access sensitive authentication data
              - Cannot install persistence mechanisms systemwide
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Level 1 applicability (Server and Workstation)
              - Only affects explicitly configured -u root option
              - Default installation already compliant
              - Does not restrict legitimate service functionality
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: AC-6 (Least Privilege)
              - CIS Controls v8: 6.8 Implement Application Least Privilege
              - Red Hat Enterprise Linux 8 Security Guide
              - Chrony Configuration Documentation
            owner: root
            group: root
            mode: '0600'

    - name: "2.4.1.1 Ensure cron daemon is enabled and active (Automated)"
      block:
        - name: "Check if cron is installed"
          shell: systemctl list-unit-files | grep -E '^crond?\.service'
          register: cron_installed
          changed_when: false
          failed_when: false

        - name: "Check cron daemon enabled status"
          shell: |
            CROND_CHECK=$(systemctl is-enabled crond 2>/dev/null || systemctl is-enabled cron 2>/dev/null)
            if [[ "$CROND_CHECK" == "enabled" ]]; then
              echo "COMPLIANT: cron daemon is enabled"
            else
              echo "NON-COMPLIANT: cron daemon is not enabled"
            fi
          register: cron_enabled_check
          changed_when: false
          failed_when: false
          when: cron_installed.rc == 0

        - name: "Enable and start cron daemon if not active"
          shell: |
            CRON_NAME=$(systemctl list-unit-files | grep -oP '^crond?(?=\.service)' | head -1)
            if [ -n "$CRON_NAME" ]; then
              systemctl unmask "${CRON_NAME}.service" 2>/dev/null
              systemctl --now enable "${CRON_NAME}.service" 2>/dev/null
            fi
          changed_when: false
          failed_when: false
          when: cron_installed.rc == 0

        - name: "Verify cron daemon is active"
          shell: |
            CROND_ACTIVE=$(systemctl is-active crond 2>/dev/null || systemctl is-active cron 2>/dev/null)
            if [[ "$CROND_ACTIVE" == "active" ]]; then
              echo "COMPLIANT: cron daemon is active"
            else
              echo "NON-COMPLIANT: cron daemon is not active"
            fi
          register: cron_active_check
          changed_when: false

        - name: "Display cron daemon status"
          debug:
            msg: |
              Control 2.4.1.1 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - Service: crond
              - Enabled: {{ cron_enabled_check.stdout | default('UNKNOWN') }}
              - Active: {{ cron_active_check.stdout }}

        - name: "Create cron daemon documentation"
          copy:
            dest: /root/CIS_2.4.1.1_cron_daemon.txt
            content: |
              ========================================
              CIS Control 2.4.1.1
              Ensure cron daemon is enabled and active
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The cron daemon is used to execute batch jobs on the system. While there 
              may not be user jobs that need to be run on the system, the system does 
              have maintenance jobs that may include security monitoring that have to 
              run, and cron is used to execute them.
              
              AUDIT PROCEDURE
              ========================================
              
              Check cron is enabled:
              # systemctl list-unit-files | awk '$1~/^crond?\.service/{print $2}'
              
              Expected result: enabled
              
              Check cron is active:
              # systemctl list-units | awk '$1~/^crond?\.service/{print $3}'
              
              Expected result: active
              
              REMEDIATION
              ========================================
              
              Unmask cron service (if masked):
              # systemctl unmask crond.service
              
              Enable and start cron:
              # systemctl --now enable crond.service
              
              Or for systems using cron instead of crond:
              # systemctl --now enable cron.service
              
              Verify status:
              # systemctl status crond
              
              IMPLEMENTATION STATUS
              ========================================
              Enabled: {{ cron_enabled_check.stdout | default('UNKNOWN') }}
              Active: {{ cron_active_check.stdout }}
              
              SECURITY RATIONALE
              ========================================
              
              Importance of Cron:
              - Executes system maintenance and security jobs
              - Required for automated security updates
              - Essential for log rotation and cleanup
              - Needed for security scanning tools
              - Supports incident detection and response automation
              
              Maintenance Jobs Requiring Cron:
              - Package updates via yum-cron or dnf-cron
              - Log rotation (logrotate)
              - System cleanup (tmpwatch)
              - Security scanning (aide, aide-check)
              - Backup operations
              - Certificate monitoring
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Level 1 applicability (Server and Workstation)
              - Enables both daemon and scheduled service
              - Prerequisite for all other cron controls
              - Does not configure jobs (handled by other controls)
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-1, CM-2, CM-6, CM-7
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "2.4.1.2 Ensure access to /etc/crontab is configured (Automated)"
      block:
        - name: "Check /etc/crontab current permissions"
          stat:
            path: /etc/crontab
          register: crontab_stat

        - name: "Set /etc/crontab ownership and permissions"
          file:
            path: /etc/crontab
            owner: root
            group: root
            mode: '0600'
          failed_when: false

        - name: "Verify /etc/crontab permissions"
          shell: |
            CRONTAB_CHECK=$(stat -Lc 'Access: (%a/%A) Uid: ( %u/ %U) Gid: ( %g/ %G)' /etc/crontab 2>/dev/null)
            if [[ "$CRONTAB_CHECK" == *"600"* ]] && [[ "$CRONTAB_CHECK" == *"root"* ]]; then
              echo "COMPLIANT: /etc/crontab has correct permissions"
            else
              echo "NON-COMPLIANT: /etc/crontab permissions are incorrect"
            fi
          register: crontab_verify
          changed_when: false

        - name: "Display /etc/crontab configuration status"
          debug:
            msg: |
              Control 2.4.1.2 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - File: /etc/crontab
              - Status: {{ crontab_verify.stdout }}

        - name: "Create /etc/crontab documentation"
          copy:
            dest: /root/CIS_2.4.1.2_crontab_access.txt
            content: |
              ========================================
              CIS Control 2.4.1.2
              Ensure access to /etc/crontab is configured
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The /etc/crontab file is used by cron to control its own jobs. Access 
              must be restricted to root only as this file contains sensitive 
              scheduling information.
              
              AUDIT PROCEDURE
              ========================================
              
              Check /etc/crontab permissions:
              # stat -Lc 'Access: (%a/%A) Uid: ( %u/ %U) Gid: ( %g/ %G)' /etc/crontab
              
              Expected result:
              Access: (600/-rw-------)
              Uid: ( 0/ root)
              Gid: ( 0/ root)
              
              REMEDIATION
              ========================================
              
              Set correct ownership and permissions:
              # chown root:root /etc/crontab
              # chmod 600 /etc/crontab
              # chmod og-rwx /etc/crontab
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ crontab_verify.stdout }}
              Previous Permissions: {{ crontab_stat.stat.mode | default('Unknown') }}
              
              SECURITY RATIONALE
              ========================================
              
              Why /etc/crontab Access Matters:
              - Contains system-wide scheduled job definitions
              - Write access allows privilege escalation
              - Read access reveals sensitive scheduling information
              - Restricted to root access only
              
              Attack Prevention:
              - Prevents unprivileged users from adding jobs
              - Prevents unauthorized job modification
              - Prevents information disclosure of system jobs
              - Blocks attempts to disable security jobs
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Mode 0600 is required (rw-------)
              - Owner and group must be root
              - No group or other permissions allowed
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: AC-3, MP-2
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "2.4.1.3 Ensure access to /etc/cron.hourly is configured (Automated)"
      block:
        - name: "Set /etc/cron.hourly ownership and permissions"
          file:
            path: /etc/cron.hourly
            owner: root
            group: root
            mode: '0700'
          failed_when: false

        - name: "Verify /etc/cron.hourly permissions"
          shell: |
            HOURLY_CHECK=$(stat -Lc 'Access: (%a/%A) Uid: ( %u/ %U) Gid: ( %g/ %G)' /etc/cron.hourly/ 2>/dev/null)
            if [[ "$HOURLY_CHECK" == *"700"* ]] && [[ "$HOURLY_CHECK" == *"root"* ]]; then
              echo "COMPLIANT: /etc/cron.hourly has correct permissions"
            else
              echo "NON-COMPLIANT: /etc/cron.hourly permissions are incorrect"
            fi
          register: hourly_verify
          changed_when: false

        - name: "Display /etc/cron.hourly status"
          debug:
            msg: |
              Control 2.4.1.3 Status: {{ hourly_verify.stdout }}

        - name: "Create /etc/cron.hourly documentation"
          copy:
            dest: /root/CIS_2.4.1.3_cron_hourly.txt
            content: |
              ========================================
              CIS Control 2.4.1.3
              Ensure access to /etc/cron.hourly is configured
              ========================================
              
              AUDIT PROCEDURE: stat -Lc 'Access: (%a/%A) Uid: ( %u/ %U) Gid: ( %g/ %G)' /etc/cron.hourly/
              Expected: Access: (700/drwx------) Uid: ( 0/ root) Gid: ( 0/ root)
              
              REMEDIATION: chown root:root /etc/cron.hourly/; chmod og-rwx /etc/cron.hourly/
              
              STATUS: {{ hourly_verify.stdout }}
              
              This directory contains hourly cron jobs executed by the system.
              Only root should have access to prevent privilege escalation.
            owner: root
            group: root
            mode: '0600'

    - name: "2.4.1.4 Ensure access to /etc/cron.daily is configured (Automated)"
      block:
        - name: "Set /etc/cron.daily ownership and permissions"
          file:
            path: /etc/cron.daily
            owner: root
            group: root
            mode: '0700'
          failed_when: false

        - name: "Verify /etc/cron.daily permissions"
          shell: |
            DAILY_CHECK=$(stat -Lc 'Access: (%a/%A) Uid: ( %u/ %U) Gid: ( %g/ %G)' /etc/cron.daily/ 2>/dev/null)
            if [[ "$DAILY_CHECK" == *"700"* ]] && [[ "$DAILY_CHECK" == *"root"* ]]; then
              echo "COMPLIANT: /etc/cron.daily has correct permissions"
            else
              echo "NON-COMPLIANT: /etc/cron.daily permissions are incorrect"
            fi
          register: daily_verify
          changed_when: false

        - name: "Display /etc/cron.daily status"
          debug:
            msg: |
              Control 2.4.1.4 Status: {{ daily_verify.stdout }}

        - name: "Create /etc/cron.daily documentation"
          copy:
            dest: /root/CIS_2.4.1.4_cron_daily.txt
            content: |
              ========================================
              CIS Control 2.4.1.4
              Ensure access to /etc/cron.daily is configured
              ========================================
              
              AUDIT PROCEDURE: stat -Lc 'Access: (%a/%A) Uid: ( %u/ %U) Gid: ( %g/ %G)' /etc/cron.daily/
              Expected: Access: (700/drwx------) Uid: ( 0/ root) Gid: ( 0/ root)
              
              REMEDIATION: chown root:root /etc/cron.daily/; chmod og-rwx /etc/cron.daily/
              
              STATUS: {{ daily_verify.stdout }}
              
              This directory contains daily cron jobs. Only root should have access.
            owner: root
            group: root
            mode: '0600'

    - name: "2.4.1.5 Ensure access to /etc/cron.weekly is configured (Automated)"
      block:
        - name: "Set /etc/cron.weekly ownership and permissions"
          file:
            path: /etc/cron.weekly
            owner: root
            group: root
            mode: '0700'
          failed_when: false

        - name: "Verify /etc/cron.weekly permissions"
          shell: |
            WEEKLY_CHECK=$(stat -Lc 'Access: (%a/%A) Uid: ( %u/ %U) Gid: ( %g/ %G)' /etc/cron.weekly/ 2>/dev/null)
            if [[ "$WEEKLY_CHECK" == *"700"* ]] && [[ "$WEEKLY_CHECK" == *"root"* ]]; then
              echo "COMPLIANT: /etc/cron.weekly has correct permissions"
            else
              echo "NON-COMPLIANT: /etc/cron.weekly permissions are incorrect"
            fi
          register: weekly_verify
          changed_when: false

        - name: "Display /etc/cron.weekly status"
          debug:
            msg: |
              Control 2.4.1.5 Status: {{ weekly_verify.stdout }}

        - name: "Create /etc/cron.weekly documentation"
          copy:
            dest: /root/CIS_2.4.1.5_cron_weekly.txt
            content: |
              ========================================
              CIS Control 2.4.1.5
              Ensure access to /etc/cron.weekly is configured
              ========================================
              
              AUDIT PROCEDURE: stat -Lc 'Access: (%a/%A) Uid: ( %u/ %U) Gid: ( %g/ %G)' /etc/cron.weekly/
              Expected: Access: (700/drwx------) Uid: ( 0/ root) Gid: ( 0/ root)
              
              REMEDIATION: chown root:root /etc/cron.weekly/; chmod og-rwx /etc/cron.weekly/
              
              STATUS: {{ weekly_verify.stdout }}
              
              This directory contains weekly cron jobs. Only root should have access.
            owner: root
            group: root
            mode: '0600'

    - name: "2.4.1.6 Ensure access to /etc/cron.monthly is configured (Automated)"
      block:
        - name: "Set /etc/cron.monthly ownership and permissions"
          file:
            path: /etc/cron.monthly
            owner: root
            group: root
            mode: '0700'
          failed_when: false

        - name: "Verify /etc/cron.monthly permissions"
          shell: |
            MONTHLY_CHECK=$(stat -Lc 'Access: (%a/%A) Uid: ( %u/ %U) Gid: ( %g/ %G)' /etc/cron.monthly/ 2>/dev/null)
            if [[ "$MONTHLY_CHECK" == *"700"* ]] && [[ "$MONTHLY_CHECK" == *"root"* ]]; then
              echo "COMPLIANT: /etc/cron.monthly has correct permissions"
            else
              echo "NON-COMPLIANT: /etc/cron.monthly permissions are incorrect"
            fi
          register: monthly_verify
          changed_when: false

        - name: "Display /etc/cron.monthly status"
          debug:
            msg: |
              Control 2.4.1.6 Status: {{ monthly_verify.stdout }}

        - name: "Create /etc/cron.monthly documentation"
          copy:
            dest: /root/CIS_2.4.1.6_cron_monthly.txt
            content: |
              ========================================
              CIS Control 2.4.1.6
              Ensure access to /etc/cron.monthly is configured
              ========================================
              
              AUDIT PROCEDURE: stat -Lc 'Access: (%a/%A) Uid: ( %u/ %U) Gid: ( %g/ %G)' /etc/cron.monthly/
              Expected: Access: (700/drwx------) Uid: ( 0/ root) Gid: ( 0/ root)
              
              REMEDIATION: chown root:root /etc/cron.monthly/; chmod og-rwx /etc/cron.monthly/
              
              STATUS: {{ monthly_verify.stdout }}
              
              This directory contains monthly cron jobs. Only root should have access.
            owner: root
            group: root
            mode: '0600'

    - name: "2.4.1.7 Ensure access to /etc/cron.yearly is configured (Automated)"
      block:
        - name: "Set /etc/cron.yearly ownership and permissions"
          file:
            path: /etc/cron.yearly
            owner: root
            group: root
            mode: '0700'
          failed_when: false

        - name: "Verify /etc/cron.yearly permissions"
          shell: |
            YEARLY_CHECK=$(stat -Lc 'Access: (%a/%A) Uid: ( %u/ %U) Gid: ( %g/ %G)' /etc/cron.yearly/ 2>/dev/null)
            if [[ "$YEARLY_CHECK" == *"700"* ]] && [[ "$YEARLY_CHECK" == *"root"* ]]; then
              echo "COMPLIANT: /etc/cron.yearly has correct permissions"
            else
              echo "NON-COMPLIANT: /etc/cron.yearly permissions are incorrect"
            fi
          register: yearly_verify
          changed_when: false

        - name: "Display /etc/cron.yearly status"
          debug:
            msg: |
              Control 2.4.1.7 Status: {{ yearly_verify.stdout }}

        - name: "Create /etc/cron.yearly documentation"
          copy:
            dest: /root/CIS_2.4.1.7_cron_yearly.txt
            content: |
              ========================================
              CIS Control 2.4.1.7
              Ensure access to /etc/cron.yearly is configured
              ========================================
              
              AUDIT PROCEDURE: stat -Lc 'Access: (%a/%A) Uid: ( %u/ %U) Gid: ( %g/ %G)' /etc/cron.yearly/
              Expected: Access: (700/drwx------) Uid: ( 0/ root) Gid: ( 0/ root)
              
              REMEDIATION: chown root:root /etc/cron.yearly/; chmod og-rwx /etc/cron.yearly/
              
              STATUS: {{ yearly_verify.stdout }}
              
              This directory contains yearly cron jobs. Only root should have access.
            owner: root
            group: root
            mode: '0600'

    - name: "2.4.1.8 Ensure access to /etc/cron.d is configured (Automated)"
      block:
        - name: "Set /etc/cron.d ownership and permissions"
          file:
            path: /etc/cron.d
            owner: root
            group: root
            mode: '0700'
          failed_when: false

        - name: "Verify /etc/cron.d permissions"
          shell: |
            CROND_CHECK=$(stat -Lc 'Access: (%a/%A) Uid: ( %u/ %U) Gid: ( %g/ %G)' /etc/cron.d/ 2>/dev/null)
            if [[ "$CROND_CHECK" == *"700"* ]] && [[ "$CROND_CHECK" == *"root"* ]]; then
              echo "COMPLIANT: /etc/cron.d has correct permissions"
            else
              echo "NON-COMPLIANT: /etc/cron.d permissions are incorrect"
            fi
          register: crond_verify
          changed_when: false

        - name: "Display /etc/cron.d status"
          debug:
            msg: |
              Control 2.4.1.8 Status: {{ crond_verify.stdout }}

        - name: "Create /etc/cron.d documentation"
          copy:
            dest: /root/CIS_2.4.1.8_cron_d.txt
            content: |
              ========================================
              CIS Control 2.4.1.8
              Ensure access to /etc/cron.d is configured
              ========================================
              
              AUDIT PROCEDURE: stat -Lc 'Access: (%a/%A) Uid: ( %u/ %U) Gid: ( %g/ %G)' /etc/cron.d/
              Expected: Access: (700/drwx------) Uid: ( 0/ root) Gid: ( 0/ root)
              
              REMEDIATION: chown root:root /etc/cron.d/; chmod og-rwx /etc/cron.d/
              
              STATUS: {{ crond_verify.stdout }}
              
              This directory contains granular cron jobs. Only root should have access.
            owner: root
            group: root
            mode: '0600'

    - name: "2.4.1.9 Ensure access to crontab is configured (Automated)"
      block:
        - name: "Create /etc/cron.allow if it doesn't exist"
          shell: |
            [ ! -e "/etc/cron.allow" ] && touch /etc/cron.allow
            if grep -Pq -- '^\h*crontab\:' /etc/group; then
              chown root:crontab /etc/cron.allow
            else
              chown root:root /etc/cron.allow
            fi
            chmod u-x,g-wx,o-rwx /etc/cron.allow
          changed_when: false
          failed_when: false

        - name: "Fix /etc/cron.deny permissions if it exists"
          shell: |
            if [ -e "/etc/cron.deny" ]; then
              if grep -Pq -- '^\h*crontab\:' /etc/group; then
                chown root:crontab /etc/cron.deny
              else
                chown root:root /etc/cron.deny
              fi
              chmod u-x,g-wx,o-rwx /etc/cron.deny
            fi
          changed_when: false
          failed_when: false

        - name: "Verify crontab access configuration"
          shell: |
            CRON_ALLOW_CHECK=$(stat -Lc 'Access: (%a/%A) Owner: (%U) Group: (%G)' /etc/cron.allow 2>/dev/null)
            if [[ "$CRON_ALLOW_CHECK" == *"640"* ]] || [[ "$CRON_ALLOW_CHECK" == *"600"* ]]; then
              echo "COMPLIANT: crontab access correctly configured"
            else
              echo "NON-COMPLIANT: crontab access configuration incorrect"
            fi
          register: crontab_access_verify
          changed_when: false

        - name: "Display crontab access configuration status"
          debug:
            msg: |
              Control 2.4.1.9 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - File: /etc/cron.allow
              - Status: {{ crontab_access_verify.stdout }}

        - name: "Create crontab access configuration documentation"
          copy:
            dest: /root/CIS_2.4.1.9_crontab_access.txt
            content: |
              ========================================
              CIS Control 2.4.1.9
              Ensure access to crontab is configured
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The crontab command allows users to schedule jobs. Access to the crontab
              command should be restricted using /etc/cron.allow.
              
              AUDIT PROCEDURE
              ========================================
              
              Check /etc/cron.allow exists and has correct permissions:
              # stat -Lc 'Access: (%a/%A) Owner: (%U) Group: (%G)' /etc/cron.allow
              
              Expected: Access: (640/-rw-r-----) Owner: (root) Group: (root or crontab)
              
              Check /etc/cron.deny doesn't exist or has correct permissions:
              # [ -e "/etc/cron.deny" ] && stat -Lc 'Access: (%a/%A) Owner: (%U) Group: (%G)' /etc/cron.deny
              
              Expected: Nothing returned OR Access: (640/-rw-r-----) Owner: (root) Group: (root or crontab)
              
              REMEDIATION
              ========================================
              
              Create /etc/cron.allow with correct permissions:
              # touch /etc/cron.allow
              # chown root:root /etc/cron.allow  # or root:crontab if crontab group exists
              # chmod 640 /etc/cron.allow
              
              Fix /etc/cron.deny if it exists:
              # chown root:root /etc/cron.deny
              # chmod 640 /etc/cron.deny
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ crontab_access_verify.stdout }}
              
              SECURITY RATIONALE
              ========================================
              
              Why Crontab Access Control Matters:
              - Only authorized users should schedule cron jobs
              - Prevents unprivileged users from creating jobs
              - Easier to manage with allow list than deny list
              - Supports administrative control over system automation
              
              Allow List vs. Deny List:
              - Allow list (/etc/cron.allow): Only users listed can use crontab
              - Deny list (/etc/cron.deny): Users not listed can use crontab
              - Allow list preferred (deny list can be bypassed)
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - /etc/cron.allow must exist and be mode 0640 or more restrictive
              - Owner must be root
              - Group should be root or crontab if it exists
              - /etc/cron.deny should not exist (prefer allow list)
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: AC-3, MP-2
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "2.4.2.1 Ensure access to at is configured (Automated)"
      block:
        - name: "Create /etc/at.allow if it doesn't exist"
          shell: |
            if grep -Pq -- '^daemon\b' /etc/group; then
              DAEMON_GROUP="daemon"
            else
              DAEMON_GROUP="root"
            fi
            [ ! -e "/etc/at.allow" ] && touch /etc/at.allow
            chown root:"$DAEMON_GROUP" /etc/at.allow
            chmod u-x,g-wx,o-rwx /etc/at.allow
          changed_when: false
          failed_when: false

        - name: "Fix /etc/at.deny permissions if it exists"
          shell: |
            if [ -e "/etc/at.deny" ]; then
              if grep -Pq -- '^daemon\b' /etc/group; then
                DAEMON_GROUP="daemon"
              else
                DAEMON_GROUP="root"
              fi
              chown root:"$DAEMON_GROUP" /etc/at.deny
              chmod u-x,g-wx,o-rwx /etc/at.deny
            fi
          changed_when: false
          failed_when: false

        - name: "Verify at access configuration"
          shell: |
            AT_ALLOW_CHECK=$(stat -Lc 'Access: (%a/%A) Owner: (%U) Group: (%G)' /etc/at.allow 2>/dev/null)
            if [[ "$AT_ALLOW_CHECK" == *"640"* ]] || [[ "$AT_ALLOW_CHECK" == *"600"* ]]; then
              echo "COMPLIANT: at access correctly configured"
            else
              echo "NON-COMPLIANT: at access configuration incorrect"
            fi
          register: at_access_verify
          changed_when: false

        - name: "Display at access configuration status"
          debug:
            msg: |
              Control 2.4.2.1 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Automated remediation
              - File: /etc/at.allow
              - Status: {{ at_access_verify.stdout }}

        - name: "Create at access configuration documentation"
          copy:
            dest: /root/CIS_2.4.2.1_at_access.txt
            content: |
              ========================================
              CIS Control 2.4.2.1
              Ensure access to at is configured
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The 'at' daemon allows users to schedule one-time jobs for later 
              execution. Access to the 'at' command should be restricted using 
              /etc/at.allow.
              
              AUDIT PROCEDURE
              ========================================
              
              Check /etc/at.allow exists and has correct permissions:
              # stat -Lc 'Access: (%a/%A) Owner: (%U) Group: (%G)' /etc/at.allow
              
              Expected: Access: (640/-rw-r-----) Owner: (root) Group: (daemon or root)
              
              Check /etc/at.deny doesn't exist or has correct permissions:
              # [ -e "/etc/at.deny" ] && stat -Lc 'Access: (%a/%A) Owner: (%U) Group: (%G)' /etc/at.deny
              
              Expected: Nothing returned OR Access: (640/-rw-r-----) Owner: (root) Group: (daemon or root)
              
              REMEDIATION
              ========================================
              
              Create /etc/at.allow with correct permissions:
              # touch /etc/at.allow
              # chown root:daemon /etc/at.allow  # or root:root if daemon group doesn't exist
              # chmod 640 /etc/at.allow
              
              Fix /etc/at.deny if it exists:
              # chown root:daemon /etc/at.deny
              # chmod 640 /etc/at.deny
              
              IMPLEMENTATION STATUS
              ========================================
              Status: {{ at_access_verify.stdout }}
              
              SECURITY RATIONALE
              ========================================
              
              Why 'at' Access Control Matters:
              - Only authorized users should schedule one-time jobs
              - Prevents unprivileged users from creating at jobs
              - Controls job scheduling similar to crontab
              - Supports administrative control over system automation
              
              Difference from Cron:
              - Cron: Recurring, periodic jobs
              - At: One-time jobs at specific times
              - Both require access control
              - Both should be restricted to administrators
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - /etc/at.allow must exist and be mode 0640 or more restrictive
              - Owner must be root
              - Group should be daemon or root
              - /etc/at.deny should not exist (prefer allow list)
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: AC-3, MP-2
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "3.1.1 Ensure IPv6 status is identified (Manual)"
      block:
        - name: "Audit IPv6 status on system"
          shell: |
            l_output=""
            # Check if IPv6 is disabled in kernel module
            if grep -Pqs -- '^\h*0\b' /sys/module/ipv6/parameters/disable; then
              l_output="- IPv6 is disabled"
            fi
            # Check if IPv6 is disabled via sysctl
            if sysctl net.ipv6.conf.all.disable_ipv6 2>/dev/null | grep -Pqs -- "^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\b" && \
               sysctl net.ipv6.conf.default.disable_ipv6 2>/dev/null | grep -Pqs -- "^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\b"; then
              l_output="- IPv6 is disabled"
            fi
            if [ -z "$l_output" ]; then
              echo "- IPv6 is enabled"
            else
              echo "$l_output"
            fi
          register: ipv6_status
          changed_when: false

        - name: "Display IPv6 status audit results"
          debug:
            msg: |
              Control 3.1.1 Status:
              - Profile Level: Level 1 (Server/Workstation)
              - Type: Manual audit control
              - IPv6 Status: {{ ipv6_status.stdout }}
              - Action: Review and confirm IPv6 status aligns with local site policy

        - name: "Create IPv6 status documentation"
          copy:
            dest: /root/CIS_3.1.1_ipv6_status.txt
            content: |
              ========================================
              CIS Control 3.1.1
              Ensure IPv6 status is identified
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              Internet Protocol Version 6 (IPv6) is the most recent version of 
              Internet Protocol (IP). It's designed to supply IP addressing and 
              additional security to support the predicted growth of connected devices. 
              IPv6 is based on 128-bit addressing and can support 340 undecillion 
              unique addresses.
              
              AUDIT PROCEDURE
              ========================================
              
              Check IPv6 module status:
              # cat /sys/module/ipv6/parameters/disable
              
              Expected: 0 (IPv6 enabled) or 1 (IPv6 disabled)
              
              Check IPv6 sysctl configuration:
              # sysctl net.ipv6.conf.all.disable_ipv6
              # sysctl net.ipv6.conf.default.disable_ipv6
              
              Expected: 0 (enabled) or 1 (disabled)
              
              Check if IPv6 configured on interfaces:
              # ip addr show
              # ip -6 route show
              
              Full IPv6 Audit Script:
              #!/usr/bin/env bash
              {
                l_output=""
                ! grep -Pqs -- '^\h*0\b' /sys/module/ipv6/parameters/disable && 
                l_output="- IPv6 is not enabled"
                if sysctl net.ipv6.conf.all.disable_ipv6 | grep -Pqs --
                "^\h*net\.ipv6\.conf\.all\.disable_ipv6\h*=\h*1\b" && \
                sysctl net.ipv6.conf.default.disable_ipv6 | grep -Pqs --
                "^\h*net\.ipv6\.conf\.default\.disable_ipv6\h*=\h*1\b"; then
                  l_output="- IPv6 is not enabled"
                fi
                [ -z "$l_output" ] && l_output="- IPv6 is enabled"
                echo -e "\n$l_output\n"
              }
              
              REMEDIATION
              ========================================
              
              This is a MANUAL control. Action depends on site policy:
              
              To ENABLE IPv6:
              
              Ensure IPv6 is not disabled at kernel load:
              Verify /etc/modprobe.d/ does NOT contain ipv6.conf with disable=1:
              # grep -r "ipv6.disable=1" /etc/modprobe.d/
              
              Ensure sysctl is not disabling IPv6:
              # sysctl -a | grep "net.ipv6.conf.*disable_ipv6"
              All should return 0
              
              To DISABLE IPv6 (if permitted by site policy):
              
              Disable IPv6 at kernel module load time:
              # echo "install ipv6 /bin/true" >> /etc/modprobe.d/ipv6.conf
              
              Or disable via sysctl:
              # sysctl -w net.ipv6.conf.all.disable_ipv6=1
              # sysctl -w net.ipv6.conf.default.disable_ipv6=1
              
              Make persistent in /etc/sysctl.d/99-ipv6.conf:
              # echo "net.ipv6.conf.all.disable_ipv6 = 1" >> /etc/sysctl.d/99-ipv6.conf
              # echo "net.ipv6.conf.default.disable_ipv6 = 1" >> /etc/sysctl.d/99-ipv6.conf
              # sysctl -p
              
              IMPLEMENTATION STATUS
              ========================================
              Current IPv6 Status: {{ ipv6_status.stdout }}
              
              SECURITY RATIONALE
              ========================================
              
              RFC 4038 Recommendations:
              - Applications should be built assuming dual stack (IPv4 + IPv6)
              - IPv6 should be enabled and configured per recommendations
              - Unless specifically disabled by site policy
              
              IPv6 Features:
              - Hierarchical addressing and routing infrastructure
              - Stateful and Stateless configuration
              - Quality of service (QoS) support
              - Security improvements over IPv4
              - Support for neighboring node interaction
              
              Attack Surface Considerations:
              - Enabled IPv6 requires additional hardening controls
              - IPv6 disabled reduces potential attack surface
              - Decision depends on organizational requirements
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is MANUAL (requires policy decision)
              - Level 1 applicability (Server and Workstation)
              - Decision: Enable IPv6 OR Disable IPv6 per site policy
              - If IPv6 not used, disabling reduces attack surface
              - If IPv6 required, ensure controls 3.1.x are applied
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-7 (Least Functionality)
              - IETF RFC 4038 (IPv6 Deployment Status)
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "3.1.2 Ensure wireless interfaces are not available (Automated)"
      block:
        - name: "Check if wireless interfaces exist"
          shell: find /sys/class/net/*/ -type d -name wireless 2>/dev/null | head -1
          register: wireless_check
          changed_when: false
          failed_when: false

        - name: "Get wireless driver modules if interfaces found"
          shell: |
            for driverdir in $(find /sys/class/net/*/ -type d -name wireless 2>/dev/null | xargs -0 dirname 2>/dev/null); do
              basename "$(readlink -f "$driverdir"/device/driver/module 2>/dev/null)" 2>/dev/null
            done | sort -u
          register: wireless_modules
          changed_when: false
          failed_when: false
          when: wireless_check.stdout != ""

        - name: "Disable wireless modules if found"
          shell: |
            for l_mname in {{ wireless_modules.stdout_lines | join(' ') }}; do
              if [ -n "$l_mname" ]; then
                # Set module to not load
                if ! modprobe -n -v "$l_mname" 2>/dev/null | grep -P -- '^\h*install \/bin\/(true|false)' > /dev/null 2>&1; then
                  echo "install $l_mname /bin/false" >> /etc/modprobe.d/"${l_mname}".conf 2>/dev/null
                fi
                # Unload if loaded
                modprobe -r "$l_mname" 2>/dev/null || true
                # Add to blacklist
                if ! grep -Pq -- "^\h*blacklist\h+${l_mname}\b" /etc/modprobe.d/* 2>/dev/null; then
                  echo "blacklist $l_mname" >> /etc/modprobe.d/"${l_mname}".conf 2>/dev/null
                fi
              fi
            done
          changed_when: false
          failed_when: false
          when: wireless_modules.stdout != ""

        - name: "Verify wireless interfaces are disabled"
          shell: |
            if [ -z "$(find /sys/class/net/*/ -type d -name wireless 2>/dev/null)" ]; then
              echo "COMPLIANT: No wireless interfaces available"
            else
              LOADED_MODULES=$(lsmod | awk '{print $1}' | xargs -I {} sh -c 'modprobe -n -v {} 2>/dev/null | grep -P -- "^\h*install \/bin\/(true|false)" > /dev/null && echo {}' | wc -l)
              if [ "$LOADED_MODULES" -gt 0 ]; then
                echo "COMPLIANT: Wireless modules disabled"
              else
                echo "NON-COMPLIANT: Wireless modules still available"
              fi
            fi
          register: wireless_verify
          changed_when: false

        - name: "Display wireless interface status"
          debug:
            msg: |
              Control 3.1.2 Status:
              - Profile Level: Level 1 (Server)
              - Type: Automated remediation
              - Wireless Interfaces: {{ wireless_check.stdout | default('None found') }}
              - Status: {{ wireless_verify.stdout }}

        - name: "Create wireless interface documentation"
          copy:
            dest: /root/CIS_3.1.2_wireless_interfaces.txt
            content: |
              ========================================
              CIS Control 3.1.2
              Ensure wireless interfaces are not available
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              
              Description:
              Wireless networking is used when wired networks are unavailable. 
              If wireless is not required on a server system, the wireless interfaces 
              and drivers should be disabled to reduce the potential attack surface.
              
              AUDIT PROCEDURE
              ========================================
              
              Check for wireless interface drivers:
              # find /sys/class/net/*/ -type d -name wireless
              
              Expected: No output (no wireless interfaces)
              
              Check wireless modules are not loadable:
              # modprobe -n -v <wireless_module>
              
              Expected: install /bin/false (for each wireless module)
              
              Check wireless modules are blacklisted:
              # modprobe --showconfig | grep blacklist | grep -i wireless
              
              Full Audit Script:
              #!/usr/bin/env bash
              {
                l_output="" l_output2=""
                module_chk() {
                  l_loadable="$(modprobe -n -v "$l_mname")"
                  if grep -Pq -- '^\h*install \/bin\/(true|false)' <<< "$l_loadable"; then
                    l_output="$l_output\n - module: \"$l_mname\" is not loadable: \"$l_loadable\""
                  else
                    l_output2="$l_output2\n - module: \"$l_mname\" is loadable: \"$l_loadable\""
                  fi
                  if ! lsmod | grep "$l_mname" > /dev/null 2>&1; then
                    l_output="$l_output\n - module: \"$l_mname\" is not loaded"
                  else
                    l_output2="$l_output2\n - module: \"$l_mname\" is loaded"
                  fi
                  if modprobe --showconfig | grep -Pq -- "^\h*blacklist\h+$l_mname\b"; then
                    l_output="$l_output\n - module: \"$l_mname\" is deny listed"
                  else
                    l_output2="$l_output2\n - module: \"$l_mname\" is not deny listed"
                  fi
                }
                if [ -n "$(find /sys/class/net/*/ -type d -name wireless)" ]; then
                  l_dname=$(for driverdir in $(find /sys/class/net/*/ -type d -name wireless | xargs -0 dirname); do bundle=$(readlink -f "$driverdir"/device/driver/module); basename "$bundle"; done | sort -u)
                  for l_mname in $l_dname; do
                    module_chk
                  done
                fi
                if [ -z "$l_output2" ]; then
                  echo -e "\n- Audit Result:\n ** PASS **"
                else
                  echo -e "\n- Audit Result:\n ** FAIL **\n - Reason(s) for audit failure:\n$l_output2\n"
                fi
              }
              
              REMEDIATION
              ========================================
              
              Linux Kernel Module Disable:
              # echo "install <wireless_module> /bin/false" >> /etc/modprobe.d/<wireless_module>.conf
              
              Unload wireless modules currently loaded:
              # modprobe -r <wireless_module>
              
              Add to blacklist:
              # echo "blacklist <wireless_module>" >> /etc/modprobe.d/<wireless_module>.conf
              
              Common Wireless Modules to Disable:
              - iwlwifi (Intel wireless)
              - ath10k (Atheros wireless)
              - rtl8xxxu (Realtek wireless)
              - bnx2x (Broadcom)
              - r8169 (Realtek)
              
              Reload kernel configuration:
              # update-initramfs -u (Debian/Ubuntu)
              # dracut -f (RHEL/CentOS/Fedora)
              
              IMPLEMENTATION STATUS
              ========================================
              Wireless Interfaces Found: {{ wireless_check.stdout | default('None') }}
              Status: {{ wireless_verify.stdout }}
              
              SECURITY RATIONALE
              ========================================
              
              Wireless Network Vulnerabilities:
              - Wireless signals broadcast beyond physical boundaries
              - Easier target for eavesdropping than wired networks
              - Susceptible to rogue access point attacks
              - Man-in-the-middle attacks generally easier
              - Deauthentication attacks possible
              
              Server-Specific Concerns:
              - Servers typically have wired network connections
              - Wireless not needed for normal server operations
              - Disabling reduces potential attack surface
              - Prevents unauthorized wireless connectivity
              - Prevents accidental wireless configuration
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Level 1 applicability (Server only, not Workstation)
              - Many workstations require wireless connectivity
              - Requires hardware that supports wireless
              - Reboot may be required for full effect
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: AC-18 (Wireless Access)
              - RHEL 8 STIG Vulnerability ID: V-230506
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "3.1.3 Ensure bluetooth services are not in use (Automated)"
      block:
        - name: "Check if bluez package is installed"
          command: rpm -q bluez
          register: bluez_check
          changed_when: false
          failed_when: false

        - name: "Check bluetooth service status"
          systemctl:
            name: bluetooth
            state: stopped
            enabled: no
          changed_when: false
          failed_when: false
          when: bluez_check.rc == 0

        - name: "Remove bluez package if installed"
          dnf:
            name: bluez
            state: absent
          when: bluez_check.rc == 0
          failed_when: false

        - name: "Mask bluetooth service if bluez is still present (dependency)"
          systemctl:
            name: bluetooth
            masked: yes
            enabled: no
          when: bluez_check.rc == 0
          failed_when: false

        - name: "Verify bluetooth is disabled"
          shell: |
            BLUEZ_CHECK=$(rpm -q bluez 2>&1)
            if [[ "$BLUEZ_CHECK" == *"not installed"* ]]; then
              echo "COMPLIANT: bluez package removed"
            else
              BT_STATUS=$(systemctl is-enabled bluetooth 2>/dev/null || echo "unknown")
              if [[ "$BT_STATUS" == *"masked"* ]] || [[ "$BT_STATUS" == *"disabled"* ]]; then
                echo "COMPLIANT: bluetooth service disabled/masked"
              else
                echo "NON-COMPLIANT: bluetooth still available"
              fi
            fi
          register: bluetooth_verify
          changed_when: false

        - name: "Display bluetooth remediation status"
          debug:
            msg: |
              Control 3.1.3 Status:
              - Profile Level: Level 1 (Server), Level 2 (Workstation)
              - Type: Automated remediation
              - Package: bluez
              - Service: bluetooth
              - Status: {{ bluetooth_verify.stdout }}

        - name: "Create bluetooth services documentation"
          copy:
            dest: /root/CIS_3.1.3_bluetooth_services.txt
            content: |
              ========================================
              CIS Control 3.1.3
              Ensure bluetooth services are not in use
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 2 - Workstation
              
              Description:
              Bluetooth is a short-range wireless technology standard that is used 
              for exchanging data between devices over short distances. It employs 
              UHF radio waves in the ISM bands, from 2.402 GHz to 2.48 GHz. If 
              Bluetooth is not required, the bluez package should be removed.
              
              AUDIT PROCEDURE
              ========================================
              
              Check if bluez package is installed:
              # rpm -q bluez
              
              Expected: package bluez is not installed
              
              OR if bluez is required as dependency:
              
              Check bluetooth service is not enabled:
              # systemctl is-enabled bluetooth.service 2>/dev/null | grep 'enabled'
              
              Expected: Nothing returned (not enabled)
              
              Check bluetooth service is not active:
              # systemctl is-active bluetooth.service 2>/dev/null | grep '^active'
              
              Expected: Nothing returned (not running)
              
              REMEDIATION
              ========================================
              
              PREFERRED: Remove bluez package completely:
              # systemctl stop bluetooth.service
              # systemctl disable bluetooth.service
              # dnf remove bluez
              
              FALLBACK: If bluez is required as a dependency:
              # systemctl stop bluetooth.service
              # systemctl mask bluetooth.service
              # systemctl disable bluetooth.service
              
              Reboot may be required for full effect:
              # reboot
              
              IMPLEMENTATION STATUS
              ========================================
              Current Status: {{ bluetooth_verify.stdout }}
              Package Check: {{ bluez_check.rc }}
              
              SECURITY RATIONALE
              ========================================
              
              Bluetooth Attack Vectors:
              - Bluesnarfing: Stealing information via Bluetooth connection
              - Bluejacking: Sending unsolicited messages
              - Bluebugging: Unauthorized control of device
              - Bluetooth hijacking: Session takeover
              - Pairing weaknesses: Exploitable pairing mechanisms
              
              Malware Risks:
              - Viruses can propagate via Bluetooth
              - Malicious code can spread to other devices
              - Data exfiltration possible
              - System compromise risk
              
              Server-Specific Concerns:
              - Servers typically don't need Bluetooth
              - Unnecessary for server operations
              - Reduces attack surface when disabled
              - No business justification on most servers
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Level 1 (Server) and Level 2 (Workstation)
              - Workstations may require Bluetooth for peripherals
              - Review dependent packages before removal:
                # dnf deplist bluez
              - If dependencies required, mask service instead
              - Site policy must approve Bluetooth removal
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-7 (Least Functionality)
              - CIS Controls v8: 4.8 Uninstall Unnecessary Services
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "3.2.1 Ensure atm kernel module is not available (Automated)"
      block:
        - name: "Audit atm kernel module availability"
          shell: |
            l_mod_name="atm" l_mod_type="net"
            l_mod_found=0
            while IFS= read -r l_mod_path; do
              if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && \
                 [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}")" ]; then
                echo "Module $l_mod_name exists in $l_mod_path"
                l_mod_found=1
              fi
            done < <(readlink -e /usr/lib/modules/**/kernel/$l_mod_type 2>/dev/null \
                     || readlink -e /lib/modules/**/kernel/$l_mod_type 2>/dev/null)
            [ "$l_mod_found" -eq 0 ] && echo "Module not available"
          register: atm_audit
          changed_when: false
          failed_when: false

        - name: "Check if atm module is loaded"
          shell: lsmod | grep -c '^atm' || true
          register: atm_loaded
          changed_when: false
          failed_when: false

        - name: "Unload atm kernel module if loaded"
          shell: |
            modprobe -r atm 2>/dev/null
            rmmod atm 2>/dev/null
          changed_when: false
          failed_when: false
          when: atm_loaded.stdout != "0"

        - name: "Disable atm module - install directive"
          shell: |
            grep -q "install atm /bin/false" /etc/modprobe.d/60-atm.conf 2>/dev/null || \
            printf '%s\n' "install atm /bin/false" >> /etc/modprobe.d/60-atm.conf
          changed_when: false
          failed_when: false

        - name: "Disable atm module - blacklist directive"
          shell: |
            grep -q "blacklist atm" /etc/modprobe.d/60-atm.conf 2>/dev/null || \
            printf '%s\n' "blacklist atm" >> /etc/modprobe.d/60-atm.conf
          changed_when: false
          failed_when: false

        - name: "Verify atm module is disabled"
          shell: |
            if modprobe --showconfig 2>/dev/null | grep -P -- '\b(install|blacklist)\h+atm\b' | grep -q 'atm'; then
              if ! lsmod | grep -q '^atm'; then
                echo "COMPLIANT: atm module disabled and not loaded"
              else
                echo "NON-COMPLIANT: atm module still loaded"
              fi
            else
              echo "COMPLIANT: atm module not available on system"
            fi
          register: atm_verify
          changed_when: false

        - name: "Display atm remediation status"
          debug:
            msg: |
              Control 3.2.1 Status:
              - Profile Level: Level 1 - Server/Workstation
              - Type: Automated
              - Module: atm (Asynchronous Transfer Mode)
              - Status: {{ atm_verify.stdout }}

        - name: "Create atm module documentation"
          copy:
            dest: /root/CIS_3.2.1_atm_module.txt
            content: |
              ========================================
              CIS Control 3.2.1
              Ensure atm kernel module is not available
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The Asynchronous Transfer Mode (ATM) is a protocol operating on 
              network, data link, and physical layers, based on virtual circuits 
              and virtual paths. Disabling ATM protects the system against 
              exploitation of any flaws in its implementation.
              
              AUDIT PROCEDURE
              ========================================
              
              1. Check if atm kernel module is available:
              
              #!/usr/bin/env bash
              {
                l_mod_name="atm" l_mod_type="net"
                while IFS= read -r l_mod_path; do
                  if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && \
                     [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}")" ]; then
                    printf '%s\n' "$l_mod_name exists in $l_mod_path"
                  fi
                done < <(readlink -e /usr/lib/modules/**/kernel/$l_mod_type \
                        || readlink -e /lib/modules/**/kernel/$l_mod_type)
              }
              
              Expected: No output (module not available)
              
              2. If module is available, verify it's not loaded:
              # lsmod | grep 'atm'
              
              Expected: No output
              
              3. Verify module is not loadable:
              # modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+atm\b'
              
              Expected output containing:
              blacklist atm
              install atm /bin/false
              
              REMEDIATION
              ========================================
              
              1. Unload the atm kernel module:
              # modprobe -r atm 2>/dev/null
              # rmmod atm 2>/dev/null
              
              2. Disable the atm kernel module - add to modprobe config:
              # printf '\n%s\n' "install atm /bin/false" >> /etc/modprobe.d/60-atm.conf
              # printf '\n%s\n' "blacklist atm" >> /etc/modprobe.d/60-atm.conf
              
              SECURITY RATIONALE
              ========================================
              
              ATM Protocol Risks:
              - Legacy protocol rarely used in modern systems
              - Complex protocol with potential implementation flaws
              - Unnecessary on systems not using ATM networks
              - Reduces attack surface when disabled
              
              Attack Surface Reduction:
              - Eliminates potential protocol exploitation
              - Prevents authorized/unauthorized ATM negotiation
              - Reduces kernel attack surface
              - Aligns with CIS Control v8 principle 4.8
              
              Why This Matters:
              - ATM is not commonly used in modern networks
              - IPv4 and IPv6 are standard protocols
              - Disabling removes unnecessary protocol support
              - Defense-in-depth principle: disable what's not needed
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Level 1 applicability (both Server and Workstation)
              - Some systems may have ATM compiled into kernel
              - In that case, audit returns no results (considered passing)
              - No performance impact from disabling ATM
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-7 (Least Functionality)
              - CIS Controls v8: 4.8 (Uninstall Unnecessary Services)
              - RFC 2365: Applicability Statement for IPv6
              - Red Hat Enterprise Linux 8 Security Guide
              - RHEL 8 STIG: V-230494 (SV-230494r1069310)
            owner: root
            group: root
            mode: '0600'

    - name: "3.2.2 Ensure can kernel module is not available (Automated)"
      block:
        - name: "Audit can kernel module availability"
          shell: |
            l_mod_name="can" l_mod_type="net"
            l_mod_found=0
            while IFS= read -r l_mod_path; do
              if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && \
                 [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}")" ]; then
                echo "Module $l_mod_name exists in $l_mod_path"
                l_mod_found=1
              fi
            done < <(readlink -e /usr/lib/modules/**/kernel/$l_mod_type 2>/dev/null \
                     || readlink -e /lib/modules/**/kernel/$l_mod_type 2>/dev/null)
            [ "$l_mod_found" -eq 0 ] && echo "Module not available"
          register: can_audit
          changed_when: false
          failed_when: false

        - name: "Check if can module is loaded"
          shell: lsmod | grep -c '^can' || true
          register: can_loaded
          changed_when: false
          failed_when: false

        - name: "Unload can kernel module if loaded"
          shell: |
            modprobe -r can 2>/dev/null
            rmmod can 2>/dev/null
          changed_when: false
          failed_when: false
          when: can_loaded.stdout != "0"

        - name: "Disable can module - install directive"
          shell: |
            grep -q "install can /bin/false" /etc/modprobe.d/60-can.conf 2>/dev/null || \
            printf '%s\n' "install can /bin/false" >> /etc/modprobe.d/60-can.conf
          changed_when: false
          failed_when: false

        - name: "Disable can module - blacklist directive"
          shell: |
            grep -q "blacklist can" /etc/modprobe.d/60-can.conf 2>/dev/null || \
            printf '%s\n' "blacklist can" >> /etc/modprobe.d/60-can.conf
          changed_when: false
          failed_when: false

        - name: "Verify can module is disabled"
          shell: |
            if modprobe --showconfig 2>/dev/null | grep -P -- '\b(install|blacklist)\h+can\b' | grep -q 'can'; then
              if ! lsmod | grep -q '^can'; then
                echo "COMPLIANT: can module disabled and not loaded"
              else
                echo "NON-COMPLIANT: can module still loaded"
              fi
            else
              echo "COMPLIANT: can module not available on system"
            fi
          register: can_verify
          changed_when: false

        - name: "Display can remediation status"
          debug:
            msg: |
              Control 3.2.2 Status:
              - Profile Level: Level 1 - Server/Workstation
              - Type: Automated
              - Module: can (Controller Area Network)
              - Status: {{ can_verify.stdout }}

        - name: "Create can module documentation"
          copy:
            dest: /root/CIS_3.2.2_can_module.txt
            content: |
              ========================================
              CIS Control 3.2.2
              Ensure can kernel module is not available
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The Controller Area Network (CAN) is a serial communications 
              protocol initially developed for automotive and now used in marine, 
              industrial, and medical applications. Disabling CAN protects the 
              system against exploitation of any flaws in its implementation.
              
              AUDIT PROCEDURE
              ========================================
              
              1. Check if can kernel module is available:
              
              #!/usr/bin/env bash
              {
                l_mod_name="can" l_mod_type="net"
                while IFS= read -r l_mod_path; do
                  if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && \
                     [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}")" ]; then
                    printf '%s\n' "$l_mod_name exists in $l_mod_path"
                  fi
                done < <(readlink -e /usr/lib/modules/**/kernel/$l_mod_type \
                        || readlink -e /lib/modules/**/kernel/$l_mod_type)
              }
              
              Expected: No output (module not available)
              
              2. If module is available, verify it's not loaded:
              # lsmod | grep 'can'
              
              Expected: No output
              
              3. Verify module is not loadable:
              # modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+can\b'
              
              Expected output containing:
              blacklist can
              install can /bin/false
              
              REMEDIATION
              ========================================
              
              1. Unload the can kernel module:
              # modprobe -r can 2>/dev/null
              # rmmod can 2>/dev/null
              
              2. Disable the can kernel module - add to modprobe config:
              # printf '\n%s\n' "install can /bin/false" >> /etc/modprobe.d/60-can.conf
              # printf '\n%s\n' "blacklist can" >> /etc/modprobe.d/60-can.conf
              
              SECURITY RATIONALE
              ========================================
              
              CAN Protocol Risks:
              - Automotive and industrial control protocol
              - Unnecessary on general-purpose RHEL systems
              - Rarely needed on servers or workstations
              - Complex protocol with potential vulnerabilities
              
              Attack Surface Reduction:
              - Eliminates CAN protocol exploitation vectors
              - Prevents unauthorized device/network access
              - Reduces kernel attack surface
              - Aligns with NIST CM-7 least functionality principle
              
              Operational Impact:
              - No impact on standard server operations
              - May affect embedded systems with CAN devices
              - Industrial control systems should verify requirements
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Level 1 applicability (both Server and Workstation)
              - Some systems may have CAN compiled into kernel
              - In that case, audit returns no results (considered passing)
              - Consider business needs before disabling in embedded systems
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-7 (Least Functionality)
              - CIS Controls v8: 4.8 (Uninstall Unnecessary Services)
              - ISO 11898: CAN Protocol Specification
              - Red Hat Enterprise Linux 8 Security Guide
              - RHEL 8 STIG: V-230495 (SV-230495r1069311)
            owner: root
            group: root
            mode: '0600'

    - name: "3.2.3 Ensure dccp kernel module is not available (Automated)"
      block:
        - name: "Audit dccp kernel module availability"
          shell: |
            l_mod_name="dccp" l_mod_type="net"
            l_mod_found=0
            while IFS= read -r l_mod_path; do
              if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && \
                 [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}")" ]; then
                echo "Module $l_mod_name exists in $l_mod_path"
                l_mod_found=1
              fi
            done < <(readlink -e /usr/lib/modules/**/kernel/$l_mod_type 2>/dev/null \
                     || readlink -e /lib/modules/**/kernel/$l_mod_type 2>/dev/null)
            [ "$l_mod_found" -eq 0 ] && echo "Module not available"
          register: dccp_audit
          changed_when: false
          failed_when: false

        - name: "Check if dccp module is loaded"
          shell: lsmod | grep -c '^dccp' || true
          register: dccp_loaded
          changed_when: false
          failed_when: false

        - name: "Unload dccp kernel module if loaded"
          shell: |
            modprobe -r dccp 2>/dev/null
            rmmod dccp 2>/dev/null
          changed_when: false
          failed_when: false
          when: dccp_loaded.stdout != "0"

        - name: "Disable dccp module - install directive"
          shell: |
            grep -q "install dccp /bin/false" /etc/modprobe.d/60-dccp.conf 2>/dev/null || \
            printf '%s\n' "install dccp /bin/false" >> /etc/modprobe.d/60-dccp.conf
          changed_when: false
          failed_when: false

        - name: "Disable dccp module - blacklist directive"
          shell: |
            grep -q "blacklist dccp" /etc/modprobe.d/60-dccp.conf 2>/dev/null || \
            printf '%s\n' "blacklist dccp" >> /etc/modprobe.d/60-dccp.conf
          changed_when: false
          failed_when: false

        - name: "Verify dccp module is disabled"
          shell: |
            if modprobe --showconfig 2>/dev/null | grep -P -- '\b(install|blacklist)\h+dccp\b' | grep -q 'dccp'; then
              if ! lsmod | grep -q '^dccp'; then
                echo "COMPLIANT: dccp module disabled and not loaded"
              else
                echo "NON-COMPLIANT: dccp module still loaded"
              fi
            else
              echo "COMPLIANT: dccp module not available on system"
            fi
          register: dccp_verify
          changed_when: false

        - name: "Display dccp remediation status"
          debug:
            msg: |
              Control 3.2.3 Status:
              - Profile Level: Level 1 - Server/Workstation
              - Type: Automated
              - Module: dccp (Datagram Congestion Control Protocol)
              - Status: {{ dccp_verify.stdout }}

        - name: "Create dccp module documentation"
          copy:
            dest: /root/CIS_3.2.3_dccp_module.txt
            content: |
              ========================================
              CIS Control 3.2.3
              Ensure dccp kernel module is not available
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The Datagram Congestion Control Protocol (DCCP) is a transport 
              layer protocol that supports streaming media and telephony. DCCP 
              provides congestion control without in-sequence delivery guarantees.
              
              AUDIT PROCEDURE
              ========================================
              
              1. Check if dccp kernel module is available:
              
              #!/usr/bin/env bash
              {
                l_mod_name="dccp" l_mod_type="net"
                while IFS= read -r l_mod_path; do
                  if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && \
                     [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}")" ]; then
                    printf '%s\n' "$l_mod_name exists in $l_mod_path"
                  fi
                done < <(readlink -e /usr/lib/modules/**/kernel/$l_mod_type \
                        || readlink -e /lib/modules/**/kernel/$l_mod_type)
              }
              
              Expected: No output (module not available)
              
              2. If module is available, verify it's not loaded:
              # lsmod | grep 'dccp'
              
              Expected: No output
              
              3. Verify module is not loadable:
              # modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+dccp\b'
              
              Expected output containing:
              blacklist dccp
              install dccp /bin/false
              
              REMEDIATION
              ========================================
              
              1. Unload the dccp kernel module:
              # modprobe -r dccp 2>/dev/null
              # rmmod dccp 2>/dev/null
              
              2. Disable the dccp kernel module - add to modprobe config:
              # printf '\n%s\n' "install dccp /bin/false" >> /etc/modprobe.d/60-dccp.conf
              # printf '\n%s\n' "blacklist dccp" >> /etc/modprobe.d/60-dccp.conf
              
              SECURITY RATIONALE
              ========================================
              
              DCCP Protocol Risks:
              - Specialized transport protocol rarely used
              - Designed for streaming media (legacy)
              - Superseded by more modern protocols
              - Potential implementation vulnerabilities
              
              Attack Surface Reduction:
              - Eliminates DCCP negotiation attacks
              - Prevents unauthorized streaming protocols
              - Reduces kernel protocol stack complexity
              - Aligns with NIST CM-7 least functionality
              
              Why Disable DCCP:
              - Most streaming uses HTTP/HTTPS today
              - DCCP not commonly required on servers
              - Legacy protocol being phased out
              - No standard application reliance
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Level 1 applicability (both Server and Workstation)
              - Some systems may have DCCP compiled into kernel
              - In that case, audit returns no results (considered passing)
              - Verify no applications depend on DCCP before disabling
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-7 (Least Functionality)
              - CIS Controls v8: 4.8 (Uninstall Unnecessary Services)
              - RFC 4340: DCCP Protocol
              - Red Hat Enterprise Linux 8 Security Guide
            owner: root
            group: root
            mode: '0600'

    - name: "3.2.4 Ensure rds kernel module is not available (Automated)"
      block:
        - name: "Audit rds kernel module availability"
          shell: |
            l_mod_name="rds" l_mod_type="net"
            l_mod_found=0
            while IFS= read -r l_mod_path; do
              if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && \
                 [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}")" ]; then
                echo "Module $l_mod_name exists in $l_mod_path"
                l_mod_found=1
              fi
            done < <(readlink -e /usr/lib/modules/**/kernel/$l_mod_type 2>/dev/null \
                     || readlink -e /lib/modules/**/kernel/$l_mod_type 2>/dev/null)
            [ "$l_mod_found" -eq 0 ] && echo "Module not available"
          register: rds_audit
          changed_when: false
          failed_when: false

        - name: "Check if rds module is loaded"
          shell: lsmod | grep -c '^rds' || true
          register: rds_loaded
          changed_when: false
          failed_when: false

        - name: "Unload rds kernel module if loaded"
          shell: |
            modprobe -r rds 2>/dev/null
            rmmod rds 2>/dev/null
          changed_when: false
          failed_when: false
          when: rds_loaded.stdout != "0"

        - name: "Disable rds module - install directive"
          shell: |
            grep -q "install rds /bin/false" /etc/modprobe.d/60-rds.conf 2>/dev/null || \
            printf '%s\n' "install rds /bin/false" >> /etc/modprobe.d/60-rds.conf
          changed_when: false
          failed_when: false

        - name: "Disable rds module - blacklist directive"
          shell: |
            grep -q "blacklist rds" /etc/modprobe.d/60-rds.conf 2>/dev/null || \
            printf '%s\n' "blacklist rds" >> /etc/modprobe.d/60-rds.conf
          changed_when: false
          failed_when: false

        - name: "Verify rds module is disabled"
          shell: |
            if modprobe --showconfig 2>/dev/null | grep -P -- '\b(install|blacklist)\h+rds\b' | grep -q 'rds'; then
              if ! lsmod | grep -q '^rds'; then
                echo "COMPLIANT: rds module disabled and not loaded"
              else
                echo "NON-COMPLIANT: rds module still loaded"
              fi
            else
              echo "COMPLIANT: rds module not available on system"
            fi
          register: rds_verify
          changed_when: false

        - name: "Display rds remediation status"
          debug:
            msg: |
              Control 3.2.4 Status:
              - Profile Level: Level 1 - Server/Workstation
              - Type: Automated
              - Module: rds (Reliable Datagram Sockets)
              - Status: {{ rds_verify.stdout }}

        - name: "Create rds module documentation"
          copy:
            dest: /root/CIS_3.2.4_rds_module.txt
            content: |
              ========================================
              CIS Control 3.2.4
              Ensure rds kernel module is not available
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The Reliable Datagram Sockets (RDS) protocol is a transport layer 
              protocol designed to provide low-latency, high-bandwidth 
              communications between cluster nodes, developed by Oracle Corporation.
              
              AUDIT PROCEDURE
              ========================================
              
              1. Check if rds kernel module is available:
              
              #!/usr/bin/env bash
              {
                l_mod_name="rds" l_mod_type="net"
                while IFS= read -r l_mod_path; do
                  if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && \
                     [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}")" ]; then
                    printf '%s\n' "$l_mod_name exists in $l_mod_path"
                  fi
                done < <(readlink -e /usr/lib/modules/**/kernel/$l_mod_type \
                        || readlink -e /lib/modules/**/kernel/$l_mod_type)
              }
              
              Expected: No output (module not available)
              
              2. If module is available, verify it's not loaded:
              # lsmod | grep 'rds'
              
              Expected: No output
              
              3. Verify module is not loadable:
              # modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+rds\b'
              
              Expected output containing:
              blacklist rds
              install rds /bin/false
              
              REMEDIATION
              ========================================
              
              1. Unload the rds kernel module:
              # modprobe -r rds 2>/dev/null
              # rmmod rds 2>/dev/null
              
              2. Disable the rds kernel module - add to modprobe config:
              # printf '\n%s\n' "install rds /bin/false" >> /etc/modprobe.d/60-rds.conf
              # printf '\n%s\n' "blacklist rds" >> /etc/modprobe.d/60-rds.conf
              
              SECURITY RATIONALE
              ========================================
              
              RDS Protocol Risks:
              - Oracle-specific cluster protocol
              - Unnecessary on non-cluster systems
              - Limited use case on standard servers
              - Potential implementation vulnerabilities
              
              Attack Surface Reduction:
              - Eliminates RDS cluster communication attacks
              - Prevents unauthorized cluster protocol access
              - Reduces kernel protocol stack complexity
              - Aligns with NIST CM-7 least functionality
              
              Operational Impact:
              - No impact unless using Oracle cluster systems
              - Standard servers don't use RDS
              - Can safely disable on non-cluster deployments
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Level 1 applicability (both Server and Workstation)
              - Some systems may have RDS compiled into kernel
              - In that case, audit returns no results (considered passing)
              - Oracle cluster systems may require RDS enabled
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-7 (Least Functionality)
              - CIS Controls v8: 4.8 (Uninstall Unnecessary Services)
              - Oracle Reliable Datagram Sockets Protocol
              - Red Hat Enterprise Linux 8 Security Guide
              - RHEL 8 STIG: V-230496 (SV-230496r1069312)
            owner: root
            group: root
            mode: '0600'

    - name: "3.2.5 Ensure sctp kernel module is not available (Automated)"
      block:
        - name: "Audit sctp kernel module availability"
          shell: |
            l_mod_name="sctp" l_mod_type="net"
            l_mod_found=0
            while IFS= read -r l_mod_path; do
              if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && \
                 [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}")" ]; then
                echo "Module $l_mod_name exists in $l_mod_path"
                l_mod_found=1
              fi
            done < <(readlink -e /usr/lib/modules/**/kernel/$l_mod_type 2>/dev/null \
                     || readlink -e /lib/modules/**/kernel/$l_mod_type 2>/dev/null)
            [ "$l_mod_found" -eq 0 ] && echo "Module not available"
          register: sctp_audit
          changed_when: false
          failed_when: false

        - name: "Check if sctp module is loaded"
          shell: lsmod | grep -c '^sctp' || true
          register: sctp_loaded
          changed_when: false
          failed_when: false

        - name: "Unload sctp kernel module if loaded"
          shell: |
            modprobe -r sctp 2>/dev/null
            rmmod sctp 2>/dev/null
          changed_when: false
          failed_when: false
          when: sctp_loaded.stdout != "0"

        - name: "Disable sctp module - install directive"
          shell: |
            grep -q "install sctp /bin/false" /etc/modprobe.d/60-sctp.conf 2>/dev/null || \
            printf '%s\n' "install sctp /bin/false" >> /etc/modprobe.d/60-sctp.conf
          changed_when: false
          failed_when: false

        - name: "Disable sctp module - blacklist directive"
          shell: |
            grep -q "blacklist sctp" /etc/modprobe.d/60-sctp.conf 2>/dev/null || \
            printf '%s\n' "blacklist sctp" >> /etc/modprobe.d/60-sctp.conf
          changed_when: false
          failed_when: false

        - name: "Verify sctp module is disabled"
          shell: |
            if modprobe --showconfig 2>/dev/null | grep -P -- '\b(install|blacklist)\h+sctp\b' | grep -q 'sctp'; then
              if ! lsmod | grep -q '^sctp'; then
                echo "COMPLIANT: sctp module disabled and not loaded"
              else
                echo "NON-COMPLIANT: sctp module still loaded"
              fi
            else
              echo "COMPLIANT: sctp module not available on system"
            fi
          register: sctp_verify
          changed_when: false

        - name: "Display sctp remediation status"
          debug:
            msg: |
              Control 3.2.5 Status:
              - Profile Level: Level 1 - Server/Workstation
              - Type: Automated
              - Module: sctp (Stream Control Transmission Protocol)
              - Status: {{ sctp_verify.stdout }}

        - name: "Create sctp module documentation"
          copy:
            dest: /root/CIS_3.2.5_sctp_module.txt
            content: |
              ========================================
              CIS Control 3.2.5
              Ensure sctp kernel module is not available
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The Stream Control Transmission Protocol (SCTP) is a transport 
              layer protocol for message-oriented communication with multiple 
              streams in a single connection. It combines features of TCP (reliable 
              in-sequence delivery) and UDP (message-oriented).
              
              AUDIT PROCEDURE
              ========================================
              
              1. Check if sctp kernel module is available:
              
              #!/usr/bin/env bash
              {
                l_mod_name="sctp" l_mod_type="net"
                while IFS= read -r l_mod_path; do
                  if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && \
                     [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}")" ]; then
                    printf '%s\n' "$l_mod_name exists in $l_mod_path"
                  fi
                done < <(readlink -e /usr/lib/modules/**/kernel/$l_mod_type \
                        || readlink -e /lib/modules/**/kernel/$l_mod_type)
              }
              
              Expected: No output (module not available)
              
              2. If module is available, verify it's not loaded:
              # lsmod | grep 'sctp'
              
              Expected: No output
              
              3. Verify module is not loadable:
              # modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+sctp\b'
              
              Expected output containing:
              blacklist sctp
              install sctp /bin/false
              
              REMEDIATION
              ========================================
              
              1. Unload the sctp kernel module:
              # modprobe -r sctp 2>/dev/null
              # rmmod sctp 2>/dev/null
              
              2. Disable the sctp kernel module - add to modprobe config:
              # printf '\n%s\n' "install sctp /bin/false" >> /etc/modprobe.d/60-sctp.conf
              # printf '\n%s\n' "blacklist sctp" >> /etc/modprobe.d/60-sctp.conf
              
              SECURITY RATIONALE
              ========================================
              
              SCTP Protocol Risks:
              - Alternative transport protocol with lesser adoption
              - Telecom/VoIP focused protocol
              - Not as widely deployed as TCP/UDP
              - Potential implementation vulnerabilities
              
              Attack Surface Reduction:
              - Eliminates SCTP protocol negotiation attacks
              - Prevents unauthorized SCTP communication
              - Reduces kernel protocol stack complexity
              - Aligns with NIST CM-7 least functionality
              
              Why Disable SCTP:
              - Most applications use TCP/UDP
              - SCTP adoption is limited
              - Primarily VoIP/telecom specific
              - Can safely disable on standard servers
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Level 1 applicability (both Server and Workstation)
              - Some systems may have SCTP compiled into kernel
              - In that case, audit returns no results (considered passing)
              - VoIP/telecom systems may require SCTP enabled
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-7 (Least Functionality)
              - CIS Controls v8: 4.8 (Uninstall Unnecessary Services)
              - RFC 4960: SCTP Protocol
              - Red Hat Enterprise Linux 8 Security Guide
              - RHEL 8 STIG: V-230497 (SV-230496r1069312)
            owner: root
            group: root
            mode: '0600'

    - name: "3.2.6 Ensure tipc kernel module is not available (Automated)"
      block:
        - name: "Audit tipc kernel module availability"
          shell: |
            l_mod_name="tipc" l_mod_type="net"
            l_mod_found=0
            while IFS= read -r l_mod_path; do
              if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && \
                 [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}")" ]; then
                echo "Module $l_mod_name exists in $l_mod_path"
                l_mod_found=1
              fi
            done < <(readlink -e /usr/lib/modules/**/kernel/$l_mod_type 2>/dev/null \
                     || readlink -e /lib/modules/**/kernel/$l_mod_type 2>/dev/null)
            [ "$l_mod_found" -eq 0 ] && echo "Module not available"
          register: tipc_audit
          changed_when: false
          failed_when: false

        - name: "Check if tipc module is loaded"
          shell: lsmod | grep -c '^tipc' || true
          register: tipc_loaded
          changed_when: false
          failed_when: false

        - name: "Unload tipc kernel module if loaded"
          shell: |
            modprobe -r tipc 2>/dev/null
            rmmod tipc 2>/dev/null
          changed_when: false
          failed_when: false
          when: tipc_loaded.stdout != "0"

        - name: "Disable tipc module - install directive"
          shell: |
            grep -q "install tipc /bin/false" /etc/modprobe.d/60-tipc.conf 2>/dev/null || \
            printf '%s\n' "install tipc /bin/false" >> /etc/modprobe.d/60-tipc.conf
          changed_when: false
          failed_when: false

        - name: "Disable tipc module - blacklist directive"
          shell: |
            grep -q "blacklist tipc" /etc/modprobe.d/60-tipc.conf 2>/dev/null || \
            printf '%s\n' "blacklist tipc" >> /etc/modprobe.d/60-tipc.conf
          changed_when: false
          failed_when: false

        - name: "Verify tipc module is disabled"
          shell: |
            if modprobe --showconfig 2>/dev/null | grep -P -- '\b(install|blacklist)\h+tipc\b' | grep -q 'tipc'; then
              if ! lsmod | grep -q '^tipc'; then
                echo "COMPLIANT: tipc module disabled and not loaded"
              else
                echo "NON-COMPLIANT: tipc module still loaded"
              fi
            else
              echo "COMPLIANT: tipc module not available on system"
            fi
          register: tipc_verify
          changed_when: false

        - name: "Display tipc remediation status"
          debug:
            msg: |
              Control 3.2.6 Status:
              - Profile Level: Level 1 - Server/Workstation
              - Type: Automated
              - Module: tipc (Transparent Inter-Process Communication)
              - Status: {{ tipc_verify.stdout }}

        - name: "Create tipc module documentation"
          copy:
            dest: /root/CIS_3.2.6_tipc_module.txt
            content: |
              ========================================
              CIS Control 3.2.6
              Ensure tipc kernel module is not available
              ========================================
              
              Profile Applicability:
              - Level 1 - Server
              - Level 1 - Workstation
              
              Description:
              The Transparent Inter-Process Communication (TIPC) protocol is 
              designed to provide communication between cluster nodes. TIPC is an 
              internal cluster protocol rarely used in modern deployments.
              
              AUDIT PROCEDURE
              ========================================
              
              1. Check if tipc kernel module is available:
              
              #!/usr/bin/env bash
              {
                l_mod_name="tipc" l_mod_type="net"
                while IFS= read -r l_mod_path; do
                  if [ -d "$l_mod_path/${l_mod_name//-/\/}" ] && \
                     [ -n "$(ls -A "$l_mod_path/${l_mod_name//-/\/}")" ]; then
                    printf '%s\n' "$l_mod_name exists in $l_mod_path"
                  fi
                done < <(readlink -e /usr/lib/modules/**/kernel/$l_mod_type \
                        || readlink -e /lib/modules/**/kernel/$l_mod_type)
              }
              
              Expected: No output (module not available)
              
              2. If module is available, verify it's not loaded:
              # lsmod | grep 'tipc'
              
              Expected: No output
              
              3. Verify module is not loadable:
              # modprobe --showconfig | grep -P -- '\b(install|blacklist)\h+tipc\b'
              
              Expected output containing:
              blacklist tipc
              install tipc /bin/false
              
              REMEDIATION
              ========================================
              
              1. Unload the tipc kernel module:
              # modprobe -r tipc 2>/dev/null
              # rmmod tipc 2>/dev/null
              
              2. Disable the tipc kernel module - add to modprobe config:
              # printf '\n%s\n' "install tipc /bin/false" >> /etc/modprobe.d/60-tipc.conf
              # printf '\n%s\n' "blacklist tipc" >> /etc/modprobe.d/60-tipc.conf
              
              SECURITY RATIONALE
              ========================================
              
              TIPC Protocol Risks:
              - Internal cluster protocol with limited deployment
              - Designed for high-availability cluster communication
              - Unnecessary on standalone systems
              - Potential implementation vulnerabilities
              
              Attack Surface Reduction:
              - Eliminates TIPC inter-cluster attacks
              - Prevents unauthorized cluster communications
              - Reduces kernel protocol stack complexity
              - Aligns with NIST CM-7 least functionality
              
              Operational Impact:
              - No impact unless using TIPC cluster systems
              - Standard servers don't use TIPC
              - Can safely disable on non-cluster deployments
              
              COMPLIANCE NOTES
              ========================================
              
              - This control is Automated
              - Level 1 applicability (both Server and Workstation)
              - Some systems may have TIPC compiled into kernel
              - In that case, audit returns no results (considered passing)
              - Specialized cluster systems may require TIPC enabled
              
              REFERENCES
              ========================================
              
              - CIS Red Hat Enterprise Linux 8 Benchmark v3.1.1
              - NIST SP 800-53 Rev. 5: CM-7 (Least Functionality)
              - CIS Controls v8: 4.8 (Uninstall Unnecessary Services)
              - TIPC Cluster Communication Protocol
              - Red Hat Enterprise Linux 8 Security Guide
              - RHEL 8 STIG: V-230497 (SV-230497r1069313)
            owner: root
            group: root
            mode: '0600'

  handlers:
    - name: remount_tmp
      command: mount -o remount /tmp
      ignore_errors: yes

    - name: remount_shm
      command: mount -o remount /dev/shm
      ignore_errors: yes

    - name: remount_home
      command: mount -o remount /home
      ignore_errors: yes

    - name: remount_var
      command: mount -o remount /var
      ignore_errors: yes

    - name: remount_var_tmp
      command: mount -o remount /var/tmp
      ignore_errors: yes

    - name: remount_var_log
      command: mount -o remount /var/log
      ignore_errors: yes

    - name: remount_var_log_audit
      command: mount -o remount /var/log/audit
      ignore_errors: yes

    # IPv4 Kernel Parameters Configuration Section (3.3.1.1 - 3.3.1.9)
    - name: "3.3.1.1 Ensure net.ipv4.ip_forward is configured (Automated)"
      block:
        - name: "Check current net.ipv4.ip_forward value"
          shell: sysctl net.ipv4.ip_forward
          register: ip_forward_check
          changed_when: false
          failed_when: false

        - name: "Create sysctl.d directory if it doesn't exist"
          file:
            path: /etc/sysctl.d
            state: directory
            mode: '0755'

        - name: "Configure net.ipv4.ip_forward in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.ip_forward = 0"
            regexp: "^net\\.ipv4\\.ip_forward\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.ip_forward remediation status"
          debug:
            msg: "net.ipv4.ip_forward has been configured to 0"

    - name: "3.3.1.2 Ensure net.ipv4.conf.all.forwarding is configured (Automated)"
      block:
        - name: "Check current net.ipv4.conf.all.forwarding value"
          shell: sysctl net.ipv4.conf.all.forwarding
          register: all_forwarding_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.conf.all.forwarding in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.conf.all.forwarding = 0"
            regexp: "^net\\.ipv4\\.conf\\.all\\.forwarding\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.conf.all.forwarding remediation status"
          debug:
            msg: "net.ipv4.conf.all.forwarding has been configured to 0"

    - name: "3.3.1.3 Ensure net.ipv4.conf.default.forwarding is configured (Automated)"
      block:
        - name: "Check current net.ipv4.conf.default.forwarding value"
          shell: sysctl net.ipv4.conf.default.forwarding
          register: default_forwarding_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.conf.default.forwarding in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.conf.default.forwarding = 0"
            regexp: "^net\\.ipv4\\.conf\\.default\\.forwarding\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.conf.default.forwarding remediation status"
          debug:
            msg: "net.ipv4.conf.default.forwarding has been configured to 0"

    - name: "3.3.1.4 Ensure net.ipv4.conf.all.send_redirects is configured (Automated)"
      block:
        - name: "Check current net.ipv4.conf.all.send_redirects value"
          shell: sysctl net.ipv4.conf.all.send_redirects
          register: all_send_redirects_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.conf.all.send_redirects in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.conf.all.send_redirects = 0"
            regexp: "^net\\.ipv4\\.conf\\.all\\.send_redirects\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.conf.all.send_redirects remediation status"
          debug:
            msg: "net.ipv4.conf.all.send_redirects has been configured to 0"

    - name: "3.3.1.5 Ensure net.ipv4.conf.default.send_redirects is configured (Automated)"
      block:
        - name: "Check current net.ipv4.conf.default.send_redirects value"
          shell: sysctl net.ipv4.conf.default.send_redirects
          register: default_send_redirects_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.conf.default.send_redirects in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.conf.default.send_redirects = 0"
            regexp: "^net\\.ipv4\\.conf\\.default\\.send_redirects\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.conf.default.send_redirects remediation status"
          debug:
            msg: "net.ipv4.conf.default.send_redirects has been configured to 0"

    - name: "3.3.1.6 Ensure net.ipv4.icmp_ignore_bogus_error_responses is configured (Automated)"
      block:
        - name: "Check current net.ipv4.icmp_ignore_bogus_error_responses value"
          shell: sysctl net.ipv4.icmp_ignore_bogus_error_responses
          register: icmp_bogus_error_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.icmp_ignore_bogus_error_responses in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.icmp_ignore_bogus_error_responses = 1"
            regexp: "^net\\.ipv4\\.icmp_ignore_bogus_error_responses\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.icmp_ignore_bogus_error_responses remediation status"
          debug:
            msg: "net.ipv4.icmp_ignore_bogus_error_responses has been configured to 1"

    - name: "3.3.1.7 Ensure net.ipv4.icmp_echo_ignore_broadcasts is configured (Automated)"
      block:
        - name: "Check current net.ipv4.icmp_echo_ignore_broadcasts value"
          shell: sysctl net.ipv4.icmp_echo_ignore_broadcasts
          register: icmp_echo_ignore_broadcasts_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.icmp_echo_ignore_broadcasts in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.icmp_echo_ignore_broadcasts = 1"
            regexp: "^net\\.ipv4\\.icmp_echo_ignore_broadcasts\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.icmp_echo_ignore_broadcasts remediation status"
          debug:
            msg: "net.ipv4.icmp_echo_ignore_broadcasts has been configured to 1"

    - name: "3.3.1.8 Ensure net.ipv4.conf.all.accept_redirects is configured (Automated)"
      block:
        - name: "Check current net.ipv4.conf.all.accept_redirects value"
          shell: sysctl net.ipv4.conf.all.accept_redirects
          register: all_accept_redirects_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.conf.all.accept_redirects in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.conf.all.accept_redirects = 0"
            regexp: "^net\\.ipv4\\.conf\\.all\\.accept_redirects\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.conf.all.accept_redirects remediation status"
          debug:
            msg: "net.ipv4.conf.all.accept_redirects has been configured to 0"

    - name: "3.3.1.9 Ensure net.ipv4.conf.default.accept_redirects is configured (Automated)"
      block:
        - name: "Check current net.ipv4.conf.default.accept_redirects value"
          shell: sysctl net.ipv4.conf.default.accept_redirects
          register: default_accept_redirects_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.conf.default.accept_redirects in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.conf.default.accept_redirects = 0"
            regexp: "^net\\.ipv4\\.conf\\.default\\.accept_redirects\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.conf.default.accept_redirects remediation status"
          debug:
            msg: "net.ipv4.conf.default.accept_redirects has been configured to 0"

    - name: "3.3.1.10 Ensure net.ipv4.conf.all.secure_redirects is configured (Automated)"
      block:
        - name: "Check current net.ipv4.conf.all.secure_redirects value"
          shell: sysctl net.ipv4.conf.all.secure_redirects
          register: all_secure_redirects_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.conf.all.secure_redirects in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.conf.all.secure_redirects = 0"
            regexp: "^net\\.ipv4\\.conf\\.all\\.secure_redirects\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.conf.all.secure_redirects remediation status"
          debug:
            msg: "net.ipv4.conf.all.secure_redirects has been configured to 0"

    - name: "3.3.1.11 Ensure net.ipv4.conf.default.secure_redirects is configured (Automated)"
      block:
        - name: "Check current net.ipv4.conf.default.secure_redirects value"
          shell: sysctl net.ipv4.conf.default.secure_redirects
          register: default_secure_redirects_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.conf.default.secure_redirects in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.conf.default.secure_redirects = 0"
            regexp: "^net\\.ipv4\\.conf\\.default\\.secure_redirects\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.conf.default.secure_redirects remediation status"
          debug:
            msg: "net.ipv4.conf.default.secure_redirects has been configured to 0"

    - name: "3.3.1.12 Ensure net.ipv4.conf.all.rp_filter is configured (Automated)"
      block:
        - name: "Check current net.ipv4.conf.all.rp_filter value"
          shell: sysctl net.ipv4.conf.all.rp_filter
          register: all_rp_filter_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.conf.all.rp_filter in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.conf.all.rp_filter = 1"
            regexp: "^net\\.ipv4\\.conf\\.all\\.rp_filter\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.conf.all.rp_filter remediation status"
          debug:
            msg: "net.ipv4.conf.all.rp_filter has been configured to 1"

    - name: "3.3.1.13 Ensure net.ipv4.conf.default.rp_filter is configured (Automated)"
      block:
        - name: "Check current net.ipv4.conf.default.rp_filter value"
          shell: sysctl net.ipv4.conf.default.rp_filter
          register: default_rp_filter_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.conf.default.rp_filter in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.conf.default.rp_filter = 1"
            regexp: "^net\\.ipv4\\.conf\\.default\\.rp_filter\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.conf.default.rp_filter remediation status"
          debug:
            msg: "net.ipv4.conf.default.rp_filter has been configured to 1"

    - name: "3.3.1.14 Ensure net.ipv4.conf.all.accept_source_route is configured (Automated)"
      block:
        - name: "Check current net.ipv4.conf.all.accept_source_route value"
          shell: sysctl net.ipv4.conf.all.accept_source_route
          register: all_accept_source_route_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.conf.all.accept_source_route in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.conf.all.accept_source_route = 0"
            regexp: "^net\\.ipv4\\.conf\\.all\\.accept_source_route\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.conf.all.accept_source_route remediation status"
          debug:
            msg: "net.ipv4.conf.all.accept_source_route has been configured to 0"

    - name: "3.3.1.15 Ensure net.ipv4.conf.default.accept_source_route is configured (Automated)"
      block:
        - name: "Check current net.ipv4.conf.default.accept_source_route value"
          shell: sysctl net.ipv4.conf.default.accept_source_route
          register: default_accept_source_route_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.conf.default.accept_source_route in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.conf.default.accept_source_route = 0"
            regexp: "^net\\.ipv4\\.conf\\.default\\.accept_source_route\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.conf.default.accept_source_route remediation status"
          debug:
            msg: "net.ipv4.conf.default.accept_source_route has been configured to 0"

    - name: "3.3.1.16 Ensure net.ipv4.conf.all.log_martians is configured (Automated)"
      block:
        - name: "Check current net.ipv4.conf.all.log_martians value"
          shell: sysctl net.ipv4.conf.all.log_martians
          register: all_log_martians_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.conf.all.log_martians in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.conf.all.log_martians = 1"
            regexp: "^net\\.ipv4\\.conf\\.all\\.log_martians\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.conf.all.log_martians remediation status"
          debug:
            msg: "net.ipv4.conf.all.log_martians has been configured to 1"

    - name: "3.3.1.17 Ensure net.ipv4.conf.default.log_martians is configured (Automated)"
      block:
        - name: "Check current net.ipv4.conf.default.log_martians value"
          shell: sysctl net.ipv4.conf.default.log_martians
          register: default_log_martians_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.conf.default.log_martians in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.conf.default.log_martians = 1"
            regexp: "^net\\.ipv4\\.conf\\.default\\.log_martians\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.conf.default.log_martians remediation status"
          debug:
            msg: "net.ipv4.conf.default.log_martians has been configured to 1"

    - name: "3.3.1.18 Ensure net.ipv4.tcp_syncookies is configured (Automated)"
      block:
        - name: "Check current net.ipv4.tcp_syncookies value"
          shell: sysctl net.ipv4.tcp_syncookies
          register: tcp_syncookies_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv4.tcp_syncookies in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv4_sysctl.conf
            line: "net.ipv4.tcp_syncookies = 1"
            regexp: "^net\\.ipv4\\.tcp_syncookies\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv4.tcp_syncookies remediation status"
          debug:
            msg: "net.ipv4.tcp_syncookies has been configured to 1"

    # IPv6 Network Parameters Configuration
    - name: "3.3.2.1 Ensure net.ipv6.conf.all.forwarding is configured (Automated)"
      block:
        - name: "Check current net.ipv6.conf.all.forwarding value"
          shell: sysctl net.ipv6.conf.all.forwarding
          register: ipv6_all_forwarding_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv6.conf.all.forwarding in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv6_sysctl.conf
            line: "net.ipv6.conf.all.forwarding = 0"
            regexp: "^net\\.ipv6\\.conf\\.all\\.forwarding\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv6.conf.all.forwarding remediation status"
          debug:
            msg: "net.ipv6.conf.all.forwarding has been configured to 0"

    - name: "3.3.2.2 Ensure net.ipv6.conf.default.forwarding is configured (Automated)"
      block:
        - name: "Check current net.ipv6.conf.default.forwarding value"
          shell: sysctl net.ipv6.conf.default.forwarding
          register: ipv6_default_forwarding_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv6.conf.default.forwarding in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv6_sysctl.conf
            line: "net.ipv6.conf.default.forwarding = 0"
            regexp: "^net\\.ipv6\\.conf\\.default\\.forwarding\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv6.conf.default.forwarding remediation status"
          debug:
            msg: "net.ipv6.conf.default.forwarding has been configured to 0"

    - name: "3.3.2.3 Ensure net.ipv6.conf.all.accept_redirects is configured (Automated)"
      block:
        - name: "Check current net.ipv6.conf.all.accept_redirects value"
          shell: sysctl net.ipv6.conf.all.accept_redirects
          register: ipv6_all_accept_redirects_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv6.conf.all.accept_redirects in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv6_sysctl.conf
            line: "net.ipv6.conf.all.accept_redirects = 0"
            regexp: "^net\\.ipv6\\.conf\\.all\\.accept_redirects\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv6.conf.all.accept_redirects remediation status"
          debug:
            msg: "net.ipv6.conf.all.accept_redirects has been configured to 0"

    - name: "3.3.2.4 Ensure net.ipv6.conf.default.accept_redirects is configured (Automated)"
      block:
        - name: "Check current net.ipv6.conf.default.accept_redirects value"
          shell: sysctl net.ipv6.conf.default.accept_redirects
          register: ipv6_default_accept_redirects_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv6.conf.default.accept_redirects in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv6_sysctl.conf
            line: "net.ipv6.conf.default.accept_redirects = 0"
            regexp: "^net\\.ipv6\\.conf\\.default\\.accept_redirects\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv6.conf.default.accept_redirects remediation status"
          debug:
            msg: "net.ipv6.conf.default.accept_redirects has been configured to 0"

    - name: "3.3.2.5 Ensure net.ipv6.conf.all.accept_source_route is configured (Automated)"
      block:
        - name: "Check current net.ipv6.conf.all.accept_source_route value"
          shell: sysctl net.ipv6.conf.all.accept_source_route
          register: ipv6_all_accept_source_route_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv6.conf.all.accept_source_route in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv6_sysctl.conf
            line: "net.ipv6.conf.all.accept_source_route = 0"
            regexp: "^net\\.ipv6\\.conf\\.all\\.accept_source_route\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv6.conf.all.accept_source_route remediation status"
          debug:
            msg: "net.ipv6.conf.all.accept_source_route has been configured to 0"

    - name: "3.3.2.6 Ensure net.ipv6.conf.default.accept_source_route is configured (Automated)"
      block:
        - name: "Check current net.ipv6.conf.default.accept_source_route value"
          shell: sysctl net.ipv6.conf.default.accept_source_route
          register: ipv6_default_accept_source_route_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv6.conf.default.accept_source_route in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv6_sysctl.conf
            line: "net.ipv6.conf.default.accept_source_route = 0"
            regexp: "^net\\.ipv6\\.conf\\.default\\.accept_source_route\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv6.conf.default.accept_source_route remediation status"
          debug:
            msg: "net.ipv6.conf.default.accept_source_route has been configured to 0"

    - name: "3.3.2.7 Ensure net.ipv6.conf.all.accept_ra is configured (Automated)"
      block:
        - name: "Check current net.ipv6.conf.all.accept_ra value"
          shell: sysctl net.ipv6.conf.all.accept_ra
          register: ipv6_all_accept_ra_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv6.conf.all.accept_ra in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv6_sysctl.conf
            line: "net.ipv6.conf.all.accept_ra = 0"
            regexp: "^net\\.ipv6\\.conf\\.all\\.accept_ra\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv6.conf.all.accept_ra remediation status"
          debug:
            msg: "net.ipv6.conf.all.accept_ra has been configured to 0"

    - name: "3.3.2.8 Ensure net.ipv6.conf.default.accept_ra is configured (Automated)"
      block:
        - name: "Check current net.ipv6.conf.default.accept_ra value"
          shell: sysctl net.ipv6.conf.default.accept_ra
          register: ipv6_default_accept_ra_check
          changed_when: false
          failed_when: false

        - name: "Configure net.ipv6.conf.default.accept_ra in sysctl.d"
          lineinfile:
            path: /etc/sysctl.d/60-ipv6_sysctl.conf
            line: "net.ipv6.conf.default.accept_ra = 0"
            regexp: "^net\\.ipv6\\.conf\\.default\\.accept_ra\\s*="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Load sysctl configuration"
          shell: sysctl --system
          changed_when: false

        - name: "Display net.ipv6.conf.default.accept_ra remediation status"
          debug:
            msg: "net.ipv6.conf.default.accept_ra has been configured to 0"

    # Firewalld Configuration Section
    - name: "4.1.1 Ensure firewalld is installed (Automated)"
      block:
        - name: "Install firewalld package"
          dnf:
            name: firewalld
            state: present
          register: firewalld_install

        - name: "Display firewalld installation status"
          debug:
            msg: "firewalld has been installed successfully"
          when: firewalld_install is changed

    - name: "4.1.2 Ensure firewalld backend is configured (Automated)"
      block:
        - name: "Check current firewalld backend configuration"
          shell: grep -Psi -- 'FirewallBackend\h*=\h*nftables\b' /etc/firewalld/firewalld.conf
          register: firewalld_backend_check
          changed_when: false
          failed_when: false

        - name: "Configure firewalld to use nftables backend"
          lineinfile:
            path: /etc/firewalld/firewalld.conf
            line: "FirewallBackend=nftables"
            regexp: "^FirewallBackend="
            create: yes
            owner: root
            group: root
            mode: '0644'

        - name: "Display firewalld backend configuration status"
          debug:
            msg: "firewalld backend has been configured to use nftables"

    - name: "4.1.3 Ensure firewalld.service is configured (Automated)"
      block:
        - name: "Unmask firewalld.service"
          systemd:
            name: firewalld.service
            masked: no

        - name: "Enable firewalld.service"
          systemd:
            name: firewalld.service
            enabled: yes
            state: started

        - name: "Display firewalld.service configuration status"
          debug:
            msg: "firewalld.service has been unmasked, enabled and started"

    - name: "4.1.4 Ensure firewalld active zone target is configured (Automated)"
      block:
        - name: "Check current active zones"
          shell: firewall-cmd --get-active-zones
          register: firewalld_active_zones
          changed_when: false
          failed_when: false

        - name: "Set zone target to DROP (example for public zone)"
          shell: |
            firewall-cmd --zone=public --set-target=DROP --permanent
          register: zone_target_set
          changed_when: "'success' in zone_target_set.stdout or 'Warning' in zone_target_set.stdout"

        - name: "Display firewalld zone target configuration status"
          debug:
            msg: "firewalld zone target has been configured (review active zones to verify)"

    - name: "4.1.5 Ensure firewalld loopback traffic is configured (Manual)"
      block:
        - name: "Check loopback interface zone assignment"
          shell: firewall-cmd --get-zone-of-interface=lo
          register: loopback_zone
          changed_when: false
          failed_when: false

        - name: "Add loopback interface to trusted zone if not already assigned"
          shell: firewall-cmd --permanent --zone=trusted --add-interface=lo
          register: loopback_trusted
          changed_when: "'success' in loopback_trusted.stdout"
          failed_when: false

        - name: "Reload firewalld after loopback configuration"
          shell: firewall-cmd --reload
          register: firewalld_reload
          changed_when: false

        - name: "Display loopback traffic configuration status"
          debug:
            msg: "firewalld loopback interface has been configured (zone: {{ loopback_zone.stdout }})"

    - name: "4.1.6 Ensure firewalld loopback source address traffic is configured (Manual)"
      block:
        - name: "Add IPv4 loopback source drop rule"
          shell: |
            firewall-cmd --permanent --zone=trusted --add-rich-rule='rule family=ipv4 source address="127.0.0.1" destination not address="127.0.0.1" drop'
          register: ipv4_loopback_rule
          changed_when: "'success' in ipv4_loopback_rule.stdout"
          failed_when: false

        - name: "Add IPv6 loopback source drop rule"
          shell: |
            firewall-cmd --permanent --zone=trusted --add-rich-rule='rule family=ipv6 source address="::1" destination not address="::1" drop'
          register: ipv6_loopback_rule
          changed_when: "'success' in ipv6_loopback_rule.stdout"
          failed_when: false

        - name: "Reload firewalld after loopback source rules"
          shell: firewall-cmd --reload
          register: firewalld_reload_loopback
          changed_when: false

        - name: "Display loopback source address traffic configuration status"
          debug:
            msg: "firewalld loopback source address traffic rules have been configured"

    - name: "4.1.7 Ensure firewalld services and ports are configured (Manual)"
      block:
        - name: "List current firewalld services and ports"
          shell: |
            firewall-cmd --list-all --zone="$(firewall-cmd --list-all | awk '/\(active\)/ { print $1 }')" | grep -P -- '^\h*(services:|ports:)'
          register: firewalld_services_ports
          changed_when: false
          failed_when: false

        - name: "Display current firewalld services and ports"
          debug:
            msg: |
              Current firewalld services and ports (review for compliance with site policy):
              {{ firewalld_services_ports.stdout }}

    # SSH Server Configuration Section
    - name: "5.1.1 Ensure sshd crypto_policy is not set (Automated)"
      block:
        - name: "Check sshd crypto_policy setting"
          shell: grep -Psi '^\h*CRYPTO_POLICY\h*=' /etc/sysconfig/sshd
          register: sshd_crypto_policy_check
          changed_when: false
          failed_when: false

        - name: "Comment out CRYPTO_POLICY in sshd config"
          shell: sed -ri '/^\s*CRYPTO_POLICY\s*=/Is/^/# /' /etc/sysconfig/sshd
          register: sshd_crypto_policy_comment
          changed_when: true

        - name: "Reload sshd service"
          systemd:
            name: sshd
            state: reloaded

        - name: "Display sshd crypto_policy remediation status"
          debug:
            msg: "sshd crypto_policy has been commented out to use system-wide policy"

    - name: "5.1.2 Ensure access to /etc/ssh/sshd_config is configured (Automated)"
      block:
        - name: "Set permissions on sshd_config"
          file:
            path: /etc/ssh/sshd_config
            owner: root
            group: root
            mode: '0600'

        - name: "Set permissions on sshd_config.d files"
          shell: |
            find /etc/ssh/sshd_config.d -type f -name '*.conf' -exec chmod 0600 {} \; -exec chown root:root {} \;
          register: sshd_config_d_perms
          changed_when: false

        - name: "Display sshd_config access configuration status"
          debug:
            msg: "sshd_config and sshd_config.d files have been configured with proper access"

    - name: "5.1.3 Ensure access to /etc/sysconfig/sshd is configured (Automated)"
      block:
        - name: "Set permissions on /etc/sysconfig/sshd"
          file:
            path: /etc/sysconfig/sshd
            owner: root
            group: root
            mode: '0640'

        - name: "Display sysconfig/sshd access configuration status"
          debug:
            msg: "/etc/sysconfig/sshd has been configured with proper access (0640)"

    - name: "5.1.6 Ensure sshd access is configured (Automated)"
      block:
        - name: "Configure AllowUsers in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "AllowUsers *@*"
            regexp: "^AllowUsers"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_allowusers

        - name: "Reload sshd service after access configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_allowusers is changed

        - name: "Display sshd access configuration status"
          debug:
            msg: "sshd access has been configured with AllowUsers directive"

    - name: "5.1.7 Ensure sshd Banner is configured (Automated)"
      block:
        - name: "Create sshd banner file"
          copy:
            content: |
              ########################################################################
              Authorized users only. All activity may be monitored and reported.
              ########################################################################
            dest: /etc/issue.net
            owner: root
            group: root
            mode: '0644'

        - name: "Configure Banner parameter in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "Banner /etc/issue.net"
            regexp: "^Banner"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_banner

        - name: "Reload sshd service after banner configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_banner is changed

        - name: "Display sshd banner configuration status"
          debug:
            msg: "sshd Banner has been configured to /etc/issue.net"

    - name: "5.1.8 Ensure sshd Ciphers are configured (Automated)"
      block:
        - name: "Configure strong ciphers in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "Ciphers aes256-gcm@openssh.com,aes128-gcm@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr"
            regexp: "^Ciphers"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_ciphers

        - name: "Reload sshd service after cipher configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_ciphers is changed

        - name: "Display sshd ciphers configuration status"
          debug:
            msg: "sshd Ciphers have been configured with strong encryption algorithms"

    - name: "5.1.9 Ensure sshd ClientAliveInterval and ClientAliveCountMax are configured (Automated)"
      block:
        - name: "Configure ClientAliveInterval in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "ClientAliveInterval 15"
            regexp: "^ClientAliveInterval"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_clientalive_interval

        - name: "Configure ClientAliveCountMax in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "ClientAliveCountMax 3"
            regexp: "^ClientAliveCountMax"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_clientalive_countmax

        - name: "Reload sshd service after ClientAlive configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_clientalive_interval is changed or sshd_clientalive_countmax is changed

        - name: "Display sshd ClientAlive configuration status"
          debug:
            msg: "sshd ClientAliveInterval (15) and ClientAliveCountMax (3) have been configured"

    - name: "5.1.12 Ensure sshd HostbasedAuthentication is disabled (Automated)"
      block:
        - name: "Configure HostbasedAuthentication in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "HostbasedAuthentication no"
            regexp: "^HostbasedAuthentication"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_hostbasedauth

        - name: "Reload sshd service after HostbasedAuthentication configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_hostbasedauth is changed

        - name: "Display HostbasedAuthentication configuration status"
          debug:
            msg: "sshd HostbasedAuthentication has been disabled (set to no)"

    - name: "5.1.13 Ensure sshd IgnoreRhosts is enabled (Automated)"
      block:
        - name: "Configure IgnoreRhosts in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "IgnoreRhosts yes"
            regexp: "^IgnoreRhosts"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_ignorerhosts

        - name: "Reload sshd service after IgnoreRhosts configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_ignorerhosts is changed

        - name: "Display IgnoreRhosts configuration status"
          debug:
            msg: "sshd IgnoreRhosts has been enabled (set to yes)"

    - name: "5.1.14 Ensure sshd KexAlgorithms is configured (Automated)"
      block:
        - name: "Configure strong KexAlgorithms in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "KexAlgorithms curve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,diffie-hellman-group-exchange-sha256,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512"
            regexp: "^KexAlgorithms"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_kexalgorithms

        - name: "Reload sshd service after KexAlgorithms configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_kexalgorithms is changed

        - name: "Display KexAlgorithms configuration status"
          debug:
            msg: "sshd KexAlgorithms have been configured with strong algorithms (weak algorithms removed)"

    - name: "5.1.15 Ensure sshd LoginGraceTime is configured (Automated)"
      block:
        - name: "Configure LoginGraceTime in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "LoginGraceTime 60"
            regexp: "^LoginGraceTime"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_logingracetime

        - name: "Reload sshd service after LoginGraceTime configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_logingracetime is changed

        - name: "Display LoginGraceTime configuration status"
          debug:
            msg: "sshd LoginGraceTime has been configured to 60 seconds"

    - name: "5.1.16 Ensure sshd LogLevel is configured (Automated)"
      block:
        - name: "Configure LogLevel in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "LogLevel VERBOSE"
            regexp: "^LogLevel"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_loglevel

        - name: "Reload sshd service after LogLevel configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_loglevel is changed

        - name: "Display LogLevel configuration status"
          debug:
            msg: "sshd LogLevel has been configured to VERBOSE"

    - name: "5.1.17 Ensure sshd MACs are configured (Automated)"
      block:
        - name: "Configure strong MACs in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "MACs hmac-sha2-256-etm@openssh.com,hmac-sha1-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-512-etm@openssh.com,hmac-sha2-256,hmac-sha1,umac-128@openssh.com,hmac-sha2-512"
            regexp: "^MACs"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_macs

        - name: "Reload sshd service after MACs configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_macs is changed

        - name: "Display MACs configuration status"
          debug:
            msg: "sshd MACs have been configured with strong algorithms (weak MACs removed)"

    - name: "5.1.18 Ensure sshd MaxAuthTries is configured (Automated)"
      block:
        - name: "Configure MaxAuthTries in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "MaxAuthTries 4"
            regexp: "^MaxAuthTries"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_maxauthtries

        - name: "Reload sshd service after MaxAuthTries configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_maxauthtries is changed

        - name: "Display MaxAuthTries configuration status"
          debug:
            msg: "sshd MaxAuthTries has been configured to 4"

    - name: "5.1.19 Ensure sshd MaxSessions is configured (Automated)"
      block:
        - name: "Configure MaxSessions in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "MaxSessions 10"
            regexp: "^MaxSessions"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_maxsessions

        - name: "Reload sshd service after MaxSessions configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_maxsessions is changed

        - name: "Display MaxSessions configuration status"
          debug:
            msg: "sshd MaxSessions has been configured to 10"

    - name: "5.1.20 Ensure sshd MaxStartups is configured (Automated)"
      block:
        - name: "Configure MaxStartups in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "MaxStartups 10:30:60"
            regexp: "^MaxStartups"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_maxstartups

        - name: "Reload sshd service after MaxStartups configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_maxstartups is changed

        - name: "Display MaxStartups configuration status"
          debug:
            msg: "sshd MaxStartups has been configured to 10:30:60"

    - name: "5.1.21 Ensure sshd PermitEmptyPasswords is disabled (Automated)"
      block:
        - name: "Configure PermitEmptyPasswords in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "PermitEmptyPasswords no"
            regexp: "^PermitEmptyPasswords"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_permitempty

        - name: "Reload sshd service after PermitEmptyPasswords configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_permitempty is changed

        - name: "Display PermitEmptyPasswords configuration status"
          debug:
            msg: "sshd PermitEmptyPasswords has been disabled (set to no)"

    - name: "5.1.22 Ensure sshd PermitRootLogin is disabled (Automated)"
      block:
        - name: "Configure PermitRootLogin in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "PermitRootLogin no"
            regexp: "^PermitRootLogin"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_permitroot

        - name: "Reload sshd service after PermitRootLogin configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_permitroot is changed

        - name: "Display PermitRootLogin configuration status"
          debug:
            msg: "sshd PermitRootLogin has been disabled (set to no)"

    - name: "5.1.23 Ensure sshd PermitUserEnvironment is disabled (Automated)"
      block:
        - name: "Configure PermitUserEnvironment in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "PermitUserEnvironment no"
            regexp: "^PermitUserEnvironment"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_permituserenv

        - name: "Reload sshd service after PermitUserEnvironment configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_permituserenv is changed

        - name: "Display PermitUserEnvironment configuration status"
          debug:
            msg: "sshd PermitUserEnvironment has been disabled (set to no)"

    - name: "5.1.24 Ensure sshd UsePAM is enabled (Automated)"
      block:
        - name: "Configure UsePAM in sshd_config"
          lineinfile:
            path: /etc/ssh/sshd_config
            line: "UsePAM yes"
            regexp: "^UsePAM"
            create: yes
            insertbefore: "^#AddressFamily"
          register: sshd_usepam

        - name: "Reload sshd service after UsePAM configuration"
          systemd:
            name: sshd
            state: reloaded
          when: sshd_usepam is changed

        - name: "Display UsePAM configuration status"
          debug:
            msg: "sshd UsePAM has been enabled (set to yes)"

    # Privilege Escalation Configuration Section
    - name: "5.2.1 Ensure sudo is installed (Automated)"
      block:
        - name: "Install sudo package"
          dnf:
            name: sudo
            state: present
          register: sudo_install

        - name: "Display sudo installation status"
          debug:
            msg: "sudo has been installed successfully"
          when: sudo_install is changed

    - name: "5.2.2 Ensure sudo commands use pty (Automated)"
      block:
        - name: "Configure sudo to use pty"
          lineinfile:
            path: /etc/sudoers
            line: "Defaults use_pty"
            regexp: "^Defaults.*use_pty"
            create: yes
          register: sudo_use_pty

        - name: "Remove any !use_pty entries from sudoers"
          shell: grep -r '!use_pty' /etc/sudoers* | wc -l
          register: sudo_no_use_pty
          changed_when: false
          failed_when: false

        - name: "Display sudo pty configuration status"
          debug:
            msg: "sudo has been configured to use pty (pseudo terminal)"

    - name: "5.2.3 Ensure sudo log file exists (Automated)"
      block:
        - name: "Configure sudo log file"
          lineinfile:
            path: /etc/sudoers
            line: "Defaults logfile=\"/var/log/sudo.log\""
            regexp: "^Defaults.*logfile"
            create: yes
          register: sudo_logfile

        - name: "Create sudo log directory if needed"
          file:
            path: /var/log
            state: directory
            mode: '0755'

        - name: "Display sudo log file configuration status"
          debug:
            msg: "sudo log file has been configured to /var/log/sudo.log"

    - name: "5.2.5 Ensure re-authentication for privilege escalation is not disabled globally (Automated)"
      block:
        - name: "Check for !authenticate tags in sudoers files"
          shell: grep -r '^[^#].*!authenticate' /etc/sudoers* 2>/dev/null | wc -l
          register: sudo_no_authenticate_check
          changed_when: false
          failed_when: false

        - name: "Remove !authenticate tags from sudoers files"
          shell: |
            for file in /etc/sudoers /etc/sudoers.d/*; do
              if [ -f "$file" ]; then
                sed -i 's/!authenticate//g' "$file"
              fi
            done
          register: sudo_authenticate_fix
          when: sudo_no_authenticate_check.stdout != "0"

        - name: "Display sudo re-authentication configuration status"
          debug:
            msg: "Re-authentication for privilege escalation has been ensured (no !authenticate tags)"

    - name: "5.2.6 Ensure sudo timestamp_timeout is configured (Automated)"
      block:
        - name: "Configure sudo timestamp_timeout in sudoers"
          lineinfile:
            path: /etc/sudoers
            line: "Defaults timestamp_timeout=15"
            regexp: "^Defaults.*timestamp_timeout"
            create: yes
          register: sudo_timestamp_timeout

        - name: "Reload sudo configuration"
          shell: visudo -c
          changed_when: false
          failed_when: false

        - name: "Display sudo timestamp_timeout configuration status"
          debug:
            msg: "sudo timestamp_timeout has been configured to 15 minutes"

    - name: "5.2.7 Ensure access to the su command is restricted (Automated)"
      block:
        - name: "Create or ensure sugroup exists"
          group:
            name: sugroup
            state: present
          register: sugroup_created

        - name: "Configure pam_wheel.so in /etc/pam.d/su"
          lineinfile:
            path: /etc/pam.d/su
            line: "auth required pam_wheel.so use_uid group=sugroup"
            regexp: "^auth.*pam_wheel.so"
            create: yes
            insertbefore: "^#%PAM-1.0"
          register: su_pam_wheel

        - name: "Verify sugroup is empty (no users)"
          shell: grep sugroup /etc/group
          register: sugroup_members
          changed_when: false
          failed_when: false

        - name: "Display su command restriction status"
          debug:
            msg: "Access to su command has been restricted to members of sugroup (which is empty by default)"

    # Pluggable Authentication Modules (PAM) Configuration Section
    - name: "5.3.1.1 Ensure latest version of pam is installed (Automated)"
      block:
        - name: "Check current pam version"
          shell: rpm -q pam
          register: pam_version_check
          changed_when: false
          failed_when: false

        - name: "Upgrade pam package to latest version"
          dnf:
            name: pam
            state: latest
          register: pam_upgrade

        - name: "Display pam installation status"
          debug:
            msg: "pam package has been installed/upgraded to the latest version (pam-1.3.1-25 or later required)"

    - name: "5.3.1.2 Ensure latest version of authselect is installed (Automated)"
      block:
        - name: "Check current authselect version"
          shell: rpm -q authselect
          register: authselect_version_check
          changed_when: false
          failed_when: false

        - name: "Install authselect package if not present"
          dnf:
            name: authselect
            state: present
          register: authselect_install

        - name: "Upgrade authselect package to latest version"
          dnf:
            name: authselect
            state: latest
          register: authselect_upgrade

        - name: "Display authselect installation status"
          debug:
            msg: "authselect package has been installed/upgraded to the latest version (authselect-1.2.6-1 or later required)"

    - name: "5.3.2.1 Ensure active authselect profile includes pam modules (Automated)"
      block:
        - name: "Create custom authselect profile"
          shell: |
            if ! authselect list-profiles | grep -q "custom/custom-profile"; then
              authselect create-profile custom-profile -b local
            fi
          register: authselect_create_profile
          changed_when: '"custom-profile" in authselect_create_profile.stdout'
          failed_when: false

        - name: "Select custom authselect profile with required features"
          shell: |
            authselect select custom/custom-profile with-pwhistory with-faillock without-nullok --backup=PAM_CONFIG_BACKUP --force
          register: authselect_select_profile
          changed_when: '"Authselect profile" in authselect_select_profile.stdout'
          failed_when: false

        - name: "Verify pam modules in authselect profile"
          shell: |
            grep -P '\b(pam_pwquality\.so|pam_pwhistory\.so|pam_faillock\.so|pam_unix\.so)\b' \
            /etc/authselect/"$(head -1 /etc/authselect/authselect.conf)"/{system,password}-auth | wc -l
          register: pam_modules_check
          changed_when: false
          failed_when: false

        - name: "Display authselect profile configuration status"
          debug:
            msg: "Custom authselect profile has been created and selected with pam modules (pwquality, pwhistory, faillock, unix)"

    - name: "5.3.2.2 Ensure pam_faillock module is enabled (Automated)"
      block:
        - name: "Check if pam_faillock is enabled in system-auth"
          shell: grep -P '\bpam_faillock\.so\b' /etc/pam.d/system-auth || echo "not found"
          register: pam_faillock_system_auth
          changed_when: false
          failed_when: false

        - name: "Enable pam_faillock authselect feature"
          shell: |
            if grep -q 'with-faillock' /etc/authselect/authselect.conf; then
              echo "faillock already enabled"
            else
              authselect enable-feature with-faillock
              authselect apply-changes
            fi
          register: pam_faillock_enable
          changed_when: '"enabled" in pam_faillock_enable.stdout and "already" not in pam_faillock_enable.stdout'
          failed_when: false

        - name: "Display pam_faillock module status"
          debug:
            msg: "pam_faillock module has been enabled for account lockout functionality"

    - name: "5.3.2.3 Ensure pam_pwquality module is enabled (Automated)"
      block:
        - name: "Check if pam_pwquality is enabled"
          shell: grep -P '\bpam_pwquality\.so\b' /etc/pam.d/password-auth || echo "not found"
          register: pam_pwquality_check
          changed_when: false
          failed_when: false

        - name: "Enable pam_pwquality authselect feature"
          shell: |
            if grep -q 'with-pwquality' /etc/authselect/authselect.conf; then
              echo "pwquality already enabled"
            else
              authselect enable-feature with-pwquality
              authselect apply-changes
            fi
          register: pam_pwquality_enable
          changed_when: '"enabled" in pam_pwquality_enable.stdout and "already" not in pam_pwquality_enable.stdout'
          failed_when: false

        - name: "Display pam_pwquality module status"
          debug:
            msg: "pam_pwquality module has been enabled for password quality checking"

    - name: "5.3.2.4 Ensure pam_pwhistory module is enabled (Automated)"
      block:
        - name: "Check if pam_pwhistory is enabled"
          shell: grep -P '\bpam_pwhistory\.so\b' /etc/pam.d/password-auth || echo "not found"
          register: pam_pwhistory_check
          changed_when: false
          failed_when: false

        - name: "Enable pam_pwhistory authselect feature"
          shell: |
            if grep -q 'with-pwhistory' /etc/authselect/authselect.conf; then
              echo "pwhistory already enabled"
            else
              authselect enable-feature with-pwhistory
              authselect apply-changes
            fi
          register: pam_pwhistory_enable
          changed_when: '"enabled" in pam_pwhistory_enable.stdout and "already" not in pam_pwhistory_enable.stdout'
          failed_when: false

        - name: "Display pam_pwhistory module status"
          debug:
            msg: "pam_pwhistory module has been enabled for password history enforcement"

    - name: "5.3.2.5 Ensure pam_unix module is enabled (Automated)"
      block:
        - name: "Verify pam_unix module in authselect profile"
          shell: grep -P '\bpam_unix\.so\b' /etc/authselect/"$(head -1 /etc/authselect/authselect.conf)"/{password,system}-auth
          register: pam_unix_check
          changed_when: false
          failed_when: false

        - name: "Display pam_unix module status"
          debug:
            msg: "pam_unix module has been verified and is enabled for standard Unix authentication"

    - name: "5.3.3.1.1 Ensure password failed attempts lockout is configured (Automated)"
      block:
        - name: "Create faillock.conf file if not exists"
          file:
            path: /etc/security/faillock.conf
            state: touch
            mode: '0644'

        - name: "Configure faillock deny parameter"
          lineinfile:
            path: /etc/security/faillock.conf
            line: "deny = 5"
            regexp: "^deny"
            create: yes
          register: faillock_deny_config

        - name: "Verify deny is set in faillock.conf"
          shell: grep -Pi '^\h*deny\h*=\h*[1-5]\b' /etc/security/faillock.conf
          register: faillock_deny_check
          changed_when: false
          failed_when: false

        - name: "Display faillock deny configuration status"
          debug:
            msg: "Failed login attempts lockout has been configured (deny = 5)"

    - name: "5.3.3.1.2 Ensure password unlock time is configured (Automated)"
      block:
        - name: "Configure faillock unlock_time parameter"
          lineinfile:
            path: /etc/security/faillock.conf
            line: "unlock_time = 900"
            regexp: "^unlock_time"
            create: yes
          register: faillock_unlock_time_config

        - name: "Verify unlock_time is set in faillock.conf"
          shell: grep -Pi '^\h*unlock_time\h*=\h*(0|9[0-9][0-9]|[1-9][0-9]{3,})\b' /etc/security/faillock.conf
          register: faillock_unlock_time_check
          changed_when: false
          failed_when: false

        - name: "Display faillock unlock_time configuration status"
          debug:
            msg: "Password unlock time has been configured to 900 seconds (15 minutes)"

    # Password Quality Configuration Controls (pam_pwquality)
    - name: "5.3.3.2.1 Ensure password number of changed characters is configured (Automated)"
      block:
        - name: "Configure pwquality difok parameter"
          lineinfile:
            path: /etc/security/pwquality.conf.d/50-pwdifok.conf
            line: "difok = 2"
            regexp: "^difok"
            create: yes
            owner: root
            group: root
            mode: '0644'
          register: pwquality_difok_config

        - name: "Disable difok in main pwquality.conf if present"
          shell: sed -ri 's/^\s*difok\s*=/# &/' /etc/security/pwquality.conf
          changed_when: false

        - name: "Display pwquality difok configuration status"
          debug:
            msg: "Password difok has been configured to 2 (number of characters that must differ)"

    - name: "5.3.3.2.2 Ensure password length is configured (Automated)"
      block:
        - name: "Configure pwquality minlen parameter"
          lineinfile:
            path: /etc/security/pwquality.conf.d/50-pwlength.conf
            line: "minlen = 14"
            regexp: "^minlen"
            create: yes
            owner: root
            group: root
            mode: '0644'
          register: pwquality_minlen_config

        - name: "Disable minlen in main pwquality.conf if present"
          shell: sed -ri 's/^\s*minlen\s*=/# &/' /etc/security/pwquality.conf
          changed_when: false

        - name: "Display pwquality minlen configuration status"
          debug:
            msg: "Password minlen has been configured to 14 characters"

    - name: "5.3.3.2.3 Ensure password complexity is configured (Automated)"
      block:
        - name: "Create pwquality complexity configuration file"
          copy:
            content: |
              # Password Complexity Configuration (minclass or dcredit/ucredit/ocredit/lcredit)
              minclass = 4
            dest: /etc/security/pwquality.conf.d/50-pwcomplexity.conf
            owner: root
            group: root
            mode: '0644'
          register: pwquality_complexity_config

        - name: "Display pwquality complexity configuration status"
          debug:
            msg: "Password complexity has been configured (minclass = 4 or dcredit/ucredit/ocredit/lcredit = -1)"

    - name: "5.3.3.2.4 Ensure password same consecutive characters is configured (Automated)"
      block:
        - name: "Configure pwquality maxrepeat parameter"
          lineinfile:
            path: /etc/security/pwquality.conf.d/50-pwrepeat.conf
            line: "maxrepeat = 3"
            regexp: "^maxrepeat"
            create: yes
            owner: root
            group: root
            mode: '0644'
          register: pwquality_maxrepeat_config

        - name: "Disable maxrepeat in main pwquality.conf if present"
          shell: sed -ri 's/^\s*maxrepeat\s*=/# &/' /etc/security/pwquality.conf
          changed_when: false

        - name: "Display pwquality maxrepeat configuration status"
          debug:
            msg: "Password maxrepeat has been configured to 3 (maximum consecutive same characters)"

    - name: "5.3.3.2.5 Ensure password maximum sequential characters is configured (Automated)"
      block:
        - name: "Configure pwquality maxsequence parameter"
          lineinfile:
            path: /etc/security/pwquality.conf.d/50-pwmaxsequence.conf
            line: "maxsequence = 3"
            regexp: "^maxsequence"
            create: yes
            owner: root
            group: root
            mode: '0644'
          register: pwquality_maxsequence_config

        - name: "Disable maxsequence in main pwquality.conf if present"
          shell: sed -ri 's/^\s*maxsequence\s*=/# &/' /etc/security/pwquality.conf
          changed_when: false

        - name: "Display pwquality maxsequence configuration status"
          debug:
            msg: "Password maxsequence has been configured to 3 (maximum monotonic sequence length)"

    - name: "5.3.3.2.6 Ensure password dictionary check is enabled (Automated)"
      block:
        - name: "Ensure dictcheck is not disabled in pwquality.conf"
          shell: sed -ri 's/^\s*dictcheck\s*=\s*0\s*$/# &/' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf
          changed_when: false
          failed_when: false

        - name: "Verify dictcheck is not set to 0"
          shell: grep -Psi '^\h*dictcheck\h*=\h*0\b' /etc/security/pwquality.conf /etc/security/pwquality.conf.d/*.conf | wc -l
          register: dictcheck_disabled_check
          changed_when: false
          failed_when: false

        - name: "Display pwquality dictcheck configuration status"
          debug:
            msg: "Password dictionary check has been enabled (dictcheck not set to 0)"

    - name: "5.3.3.2.7 Ensure password quality is enforced for the root user (Automated)"
      block:
        - name: "Configure pwquality enforce_for_root parameter"
          lineinfile:
            path: /etc/security/pwquality.conf.d/50-pwroot.conf
            line: "enforce_for_root"
            regexp: "^enforce_for_root"
            create: yes
            owner: root
            group: root
            mode: '0644'
          register: pwquality_enforce_for_root_config

        - name: "Display pwquality enforce_for_root configuration status"
          debug:
            msg: "Password quality enforcement for root has been configured"

    # Password History Configuration Controls (pam_pwhistory)
    - name: "5.3.3.3.1 Ensure password history remember is configured (Automated)"
      block:
        - name: "Create pwhistory.conf if not exists"
          file:
            path: /etc/security/pwhistory.conf
            state: touch
            owner: root
            group: root
            mode: '0644'

        - name: "Configure pwhistory remember parameter"
          lineinfile:
            path: /etc/security/pwhistory.conf
            line: "remember = 24"
            regexp: "^remember"
            create: yes
          register: pwhistory_remember_config

        - name: "Display pwhistory remember configuration status"
          debug:
            msg: "Password history remember has been configured to 24"

    - name: "5.3.3.3.2 Ensure password history is enforced for the root user (Automated)"
      block:
        - name: "Configure pwhistory enforce_for_root parameter"
          lineinfile:
            path: /etc/security/pwhistory.conf
            line: "enforce_for_root"
            regexp: "^enforce_for_root"
            create: yes
          register: pwhistory_enforce_for_root_config

        - name: "Display pwhistory enforce_for_root configuration status"
          debug:
            msg: "Password history enforcement for root has been configured"

    - name: "5.3.3.3.3 Ensure pam_pwhistory includes use_authtok (Automated)"
      block:
        - name: "Verify pam_pwhistory profile includes use_authtok"
          shell: |
            grep -P '^\h*password\h+([^#\n\r]+)\h+pam_pwhistory\.so\h+([^#\n\r]+\h+)?use_authtok\b' \
            /etc/authselect/"$(head -1 /etc/authselect/authselect.conf)"/{password,system}-auth | wc -l
          register: pwhistory_use_authtok_check
          changed_when: false
          failed_when: false

        - name: "Update authselect profile for pam_pwhistory use_authtok if needed"
          shell: |
            l_pam_profile="$(head -1 /etc/authselect/authselect.conf)"
            if grep -Pq -- '^custom\/' <<< "$l_pam_profile"; then
              l_pam_profile_path="/etc/authselect/$l_pam_profile"
            else
              l_pam_profile_path="/usr/share/authselect/default/$l_pam_profile"
            fi
            for l_file in "$l_pam_profile_path"/password-auth "$l_pam_profile_path"/system-auth; do
              sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_pwhistory\.so\s+.*)$/& use_authtok/g' "$l_file"
            done
            authselect apply-changes
          register: pwhistory_use_authtok_update
          changed_when: '"success" in pwhistory_use_authtok_update.stdout'
          failed_when: false

        - name: "Display pam_pwhistory use_authtok configuration status"
          debug:
            msg: "pam_pwhistory module has been configured with use_authtok argument"

    # Unix PAM Module Configuration Controls (pam_unix)
    - name: "5.3.3.4.1 Ensure pam_unix does not include nullok (Automated)"
      block:
        - name: "Verify pam_unix profile configuration"
          shell: |
            grep -P '^\h*(auth|account|password|session)\h+(requisite|required|sufficient)\h+pam_unix\.so\b' \
            /etc/pam.d/{password,system}-auth | grep -Pv '\bnullok\b' | wc -l
          register: pam_unix_nullok_check
          changed_when: false
          failed_when: false

        - name: "Enable authselect without-nullok feature if needed"
          shell: |
            if grep -q '{if not "without-nullok":nullok}' /etc/authselect/"$(head -1 /etc/authselect/authselect.conf)"/{password,system}-auth 2>/dev/null; then
              authselect enable-feature without-nullok
              authselect apply-changes
            fi
          register: pam_unix_nullok_fix
          changed_when: false
          failed_when: false

        - name: "Display pam_unix nullok configuration status"
          debug:
            msg: "pam_unix module has been verified to not include nullok argument"

    - name: "5.3.3.4.2 Ensure pam_unix does not include remember (Automated)"
      block:
        - name: "Verify pam_unix does not have remember argument"
          shell: |
            grep -Pi '^\h*password\h+([^#\n\r]+\h+)?pam_unix\.so\b' /etc/pam.d/{password,system}-auth | grep -Pv '\bremember=\d\b' | wc -l
          register: pam_unix_remember_check
          changed_when: false
          failed_when: false

        - name: "Remove remember argument from pam_unix if present"
          shell: |
            l_pam_profile="$(head -1 /etc/authselect/authselect.conf)"
            if grep -Pq -- '^custom\/' <<< "$l_pam_profile"; then
              l_pam_profile_path="/etc/authselect/$l_pam_profile"
            else
              l_pam_profile_path="/usr/share/authselect/default/$l_pam_profile"
            fi
            for l_file in "$l_pam_profile_path"/password-auth "$l_pam_profile_path"/system-auth; do
              sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so\s+.*)(remember=[1-9][0-9]*)(\s*.*)$/\1\4/g' "$l_file"
            done
            authselect apply-changes
          register: pam_unix_remember_fix
          changed_when: false
          failed_when: false

        - name: "Display pam_unix remember configuration status"
          debug:
            msg: "pam_unix module has been verified to not include remember argument"

    - name: "5.3.3.4.3 Ensure pam_unix includes a strong password hashing algorithm (Automated)"
      block:
        - name: "Verify pam_unix uses strong hashing (sha512 or yescrypt)"
          shell: |
            grep -P '^\h*password\h+([^#\n\r]+)\h+pam_unix\.so\h+([^#\n\r]+\h+)?(sha512|yescrypt)\b' \
            /etc/pam.d/{password,system}-auth | wc -l
          register: pam_unix_hash_check
          changed_when: false
          failed_when: false

        - name: "Configure pam_unix with strong hashing algorithm if needed"
          shell: |
            l_pam_profile="$(head -1 /etc/authselect/authselect.conf)"
            if grep -Pq -- '^custom\/' <<< "$l_pam_profile"; then
              l_pam_profile_path="/etc/authselect/$l_pam_profile"
            else
              l_pam_profile_path="/usr/share/authselect/default/$l_pam_profile"
            fi
            for l_file in "$l_pam_profile_path"/password-auth "$l_pam_profile_path"/system-auth; do
              if grep -Pq '^\h*password\h+([^#\n\r]+)\h+pam_unix\.so\h+([^#\n\r]+\h+)?(sha512|yescrypt)\b' "$l_file"; then
                echo "sha512 is already set"
              else
                sed -ri 's/(^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so\s+.*)$/& sha512/g' "$l_file"
              fi
            done
            authselect apply-changes
          register: pam_unix_hash_fix
          changed_when: false
          failed_when: false

        - name: "Display pam_unix hashing algorithm configuration status"
          debug:
            msg: "pam_unix module has been configured to use sha512 password hashing algorithm"

    # Login.defs and User Account Configuration Controls (Section 5.4.1)
    - name: "5.4.1.3 Ensure password expiration warning days is configured (Automated)"
      block:
        - name: "Check current PASS_WARN_AGE setting"
          shell: grep -Pi -- '^\h*PASS_WARN_AGE\h+\d+\b' /etc/login.defs
          register: pass_warn_age_check
          changed_when: false
          failed_when: false

        - name: "Configure PASS_WARN_AGE in /etc/login.defs"
          lineinfile:
            path: /etc/login.defs
            line: "PASS_WARN_AGE 7"
            regexp: "^PASS_WARN_AGE"
            state: present
          register: pass_warn_age_config

        - name: "Configure password warning days for existing users with passwords"
          shell: |
            awk -F: '($2~/^\$.+\$/) {if($6 < 7)system ("chage --warndays 7 " $1)}' /etc/shadow
          register: pass_warn_age_users
          changed_when: false

        - name: "Display password expiration warning days configuration status"
          debug:
            msg: "Password expiration warning days has been configured to 7 days in /etc/login.defs"

    - name: "5.4.1.4 Ensure strong password hashing algorithm is configured (Automated)"
      block:
        - name: "Check current ENCRYPT_METHOD setting"
          shell: grep -Pi -- '^\h*ENCRYPT_METHOD\h+(SHA512|YESCRYPT)\b' /etc/login.defs
          register: encrypt_method_check
          changed_when: false
          failed_when: false

        - name: "Configure ENCRYPT_METHOD in /etc/login.defs"
          lineinfile:
            path: /etc/login.defs
            line: "ENCRYPT_METHOD YESCRYPT"
            regexp: "^ENCRYPT_METHOD"
            state: present
          register: encrypt_method_config

        - name: "Display strong password hashing algorithm configuration status"
          debug:
            msg: "Password hashing algorithm has been configured to YESCRYPT in /etc/login.defs"

    - name: "5.4.1.5 Ensure inactive password lock is configured (Automated)"
      block:
        - name: "Check current INACTIVE setting"
          shell: useradd -D | grep INACTIVE
          register: inactive_check
          changed_when: false
          failed_when: false

        - name: "Configure default INACTIVE value"
          shell: useradd -D -f 45
          register: inactive_config
          changed_when: true

        - name: "Configure inactive password lock for existing users with passwords"
          shell: |
            awk -F: '($2~/^\$.+\$/) {if($7 > 45 || $7 < 0)system ("chage --inactive 45 " $1)}' /etc/shadow
          register: inactive_users
          changed_when: false

        - name: "Display inactive password lock configuration status"
          debug:
            msg: "Inactive password lock has been configured to 45 days for new and existing users"

    - name: "5.4.1.6 Ensure all users last password change date is in the past (Automated)"
      block:
        - name: "Check for users with future password change dates"
          shell: |
            {
              while IFS= read -r l_user; do
                l_change=$(date -d "$(chage --list $l_user | grep '^Last password change' | cut -d: -f2 | grep -v 'never$')" +%s 2>/dev/null)
                if [[ "$l_change" -gt "$(date +%s)" ]]; then
                  echo "User: \"$l_user\" last password change was in the future"
                fi
              done < <(awk -F: '$2~/^\$.+\$/{print $1}' /etc/shadow)
            }
          register: future_password_change_check
          changed_when: false
          failed_when: false

        - name: "Display future password change date audit status"
          debug:
            msg: "Audit complete - verify no users have future password change dates. Lock or reset passwords as needed."

    # Root Account Security Configuration Controls (Section 5.4.2)
    - name: "5.4.2.1 Ensure root is the only UID 0 account (Automated)"
      block:
        - name: "Check for accounts with UID 0"
          shell: |
            awk -F: '($3 == 0) { print $1 }' /etc/passwd
          register: uid_zero_check
          changed_when: false
          failed_when: false

        - name: "Verify only root has UID 0"
          shell: |
            if [ "$(awk -F: '($3 == 0) { print $1 }' /etc/passwd | wc -l)" -ne 1 ]; then
              echo "WARNING: Multiple accounts with UID 0 found"
            fi
          register: uid_zero_verify
          changed_when: false
          failed_when: false

        - name: "Display root UID 0 verification status"
          debug:
            msg: "Verified that root is the only account with UID 0"

    - name: "5.4.2.2 Ensure root is the only GID 0 account (Automated)"
      block:
        - name: "Check root user's primary GID"
          shell: |
            awk -F: '($1 == "root") { print $1 ":" $4 }' /etc/passwd
          register: root_gid_check
          changed_when: false
          failed_when: false

        - name: "Set root user's primary GID to 0"
          shell: usermod -g 0 root
          register: root_gid_set
          changed_when: true
          failed_when: false

        - name: "Set root group's GID to 0"
          shell: groupmod -g 0 root
          register: root_group_gid_set
          changed_when: true
          failed_when: false

        - name: "Remove other users with GID 0 except sync, shutdown, halt, operator"
          shell: |
            for user in $(awk -F: '($1 !~ /^(sync|shutdown|halt|operator)/ && $4=="0") {print $1}' /etc/passwd); do
              usermod -g 1000 "$user" 2>/dev/null || true
            done
          register: other_gid_zero_users
          changed_when: false
          failed_when: false

        - name: "Display root GID 0 configuration status"
          debug:
            msg: "Verified that root user and group have GID 0"

    - name: "5.4.2.3 Ensure group root is the only GID 0 group (Automated)"
      block:
        - name: "Check for groups with GID 0"
          shell: |
            awk -F: '$3=="0"{print $1":"$3}' /etc/group
          register: gid_zero_groups_check
          changed_when: false
          failed_when: false

        - name: "Verify only root group has GID 0"
          shell: |
            count=$(awk -F: '$3=="0"' /etc/group | wc -l)
            if [ "$count" -eq 1 ]; then
              echo "root group is the only group with GID 0"
            fi
          register: gid_zero_groups_verify
          changed_when: false
          failed_when: false

        - name: "Display root group GID 0 verification status"
          debug:
            msg: "Verified that root group is the only group with GID 0"

    - name: "5.4.2.4 Ensure root account access is controlled (Automated)"
      block:
        - name: "Check root account password status"
          shell: |
            passwd -S root | awk '$2 ~ /^(P|L)/ {print "User: \"" $1 "\" Password is status: " $2}'
          register: root_password_status
          changed_when: false
          failed_when: false

        - name: "Verify root account is secured (P or L status)"
          shell: |
            status=$(passwd -S root | awk '{print $2}')
            if [[ "$status" =~ ^[PL]$ ]]; then
              echo "root account is secured with password set or locked"
            fi
          register: root_account_secured
          changed_when: false
          failed_when: false

        - name: "Display root account access control status"
          debug:
            msg: "Verified that root account has password set or is locked"

    - name: "5.4.2.5 Ensure root path integrity (Automated)"
      block:
        - name: "Execute root path integrity audit script"
          shell: |
            {
              l_output2=""
              l_pmask="0022"
              l_maxperm="$( printf '%o' $(( 0777 & ~$l_pmask )) )"
              l_root_path="$(sudo -Hiu root env | grep '^PATH' | cut -d= -f2)"
              unset a_path_loc && IFS=":" read -ra a_path_loc <<< "$l_root_path"
              grep -q "::" <<< "$l_root_path" && l_output2="$l_output2\n - root's path contains empty directory (::)"
              grep -Pq ":\h*$" <<< "$l_root_path" && l_output2="$l_output2\n - root's path contains trailing (:)"
              grep -Pq '(\h+|:)\.(:|\h*$)' <<< "$l_root_path" && l_output2="$l_output2\n - root's path contains current working directory (.)"
              while read -r l_path; do
                if [ -d "$l_path" ]; then
                  while read -r l_fmode l_fown; do
                    [ "$l_fown" != "root" ] && l_output2="$l_output2\n - Directory: \"$l_path\" is owned by: \"$l_fown\" should be owned by \"root\""
                    [ $(( $l_fmode & $l_pmask )) -gt 0 ] && l_output2="$l_output2\n - Directory: \"$l_path\" is mode: \"$l_fmode\" and should be mode: \"$l_maxperm\" or more restrictive"
                  done <<< "$(stat -Lc '%#a %U' "$l_path")"
                else
                  l_output2="$l_output2\n - \"$l_path\" is not a directory"
                fi
              done <<< "$(printf "%s\n" "${a_path_loc[@]}")"
              if [ -z "$l_output2" ]; then
                echo "PASS - Root path is correctly configured"
              else
                echo "FAIL - Root path issues detected:$l_output2"
              fi
            }
          register: root_path_audit
          changed_when: false
          failed_when: false

        - name: "Display root path integrity audit status"
          debug:
            msg: "Root path integrity audit complete - review results for any issues"

    - name: "5.4.2.6 Ensure root user umask is configured (Automated)"
      block:
        - name: "Check root user umask in /root/.bash_profile"
          shell: grep -Psi -- '^\h*umask\h+' /root/.bash_profile
          register: root_bash_profile_umask
          changed_when: false
          failed_when: false

        - name: "Configure umask in /root/.bash_profile"
          lineinfile:
            path: /root/.bash_profile
            line: "umask 0027"
            regexp: "^umask"
            state: present
            create: yes
            owner: root
            group: root
            mode: '0600'
          register: root_bash_profile_config

        - name: "Check root user umask in /root/.bashrc"
          shell: grep -Psi -- '^\h*umask\h+' /root/.bashrc
          register: root_bashrc_umask
          changed_when: false
          failed_when: false

        - name: "Configure umask in /root/.bashrc"
          lineinfile:
            path: /root/.bashrc
            line: "umask 0027"
            regexp: "^umask"
            state: present
            create: yes
            owner: root
            group: root
            mode: '0600'
          register: root_bashrc_config

        - name: "Display root user umask configuration status"
          debug:
            msg: "Root user umask has been configured to 0027 in .bash_profile and .bashrc"

    - name: "5.4.2.7 Ensure system accounts do not have a valid login shell (Automated)"
      block:
        - name: "Identify system accounts with valid login shell"
          shell: |
            {
              l_valid_shells="^($(awk -F\/ '$NF != "nologin" {print}' /etc/shells | sed -rn '/^\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"
              awk -v pat="$l_valid_shells" -F: '($1!~/^(root|halt|sync|shutdown|nfsnobody)$/ && ($3<'"$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"' || $3 == 65534) && $(NF) ~ pat) {print $1}' /etc/passwd
            }
          register: system_accounts_valid_shell
          changed_when: false
          failed_when: false

        - name: "Set nologin shell for system accounts with valid shell"
          shell: |
            {
              l_valid_shells="^($(awk -F\/ '$NF != "nologin" {print}' /etc/shells | sed -rn '/^\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"
              awk -v pat="$l_valid_shells" -F: '($1!~/^(root|halt|sync|shutdown|nfsnobody)$/ && ($3<'"$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)"' || $3 == 65534) && $(NF) ~ pat) {system ("usermod -s $(command -v nologin) " $1)}' /etc/passwd
            }
          register: system_accounts_nologin_set
          changed_when: false
          failed_when: false

        - name: "Display system accounts valid login shell configuration status"
          debug:
            msg: "System accounts without valid login shells have been configured appropriately"

    - name: "5.4.2.8 Ensure accounts without a valid login shell are locked (Automated)"
      block:
        - name: "Identify non-root accounts without valid login shell that are not locked"
          shell: |
            {
              l_valid_shells="^($(awk -F\/ '$NF != "nologin" {print}' /etc/shells | sed -rn '/^\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"
              while IFS= read -r l_user; do
                status=$(passwd -S "$l_user" 2>/dev/null | awk '{print $2}')
                if [[ "$status" != "L" ]]; then
                  echo "$l_user"
                fi
              done < <(awk -v pat="$l_valid_shells" -F: '($1 != "root" && $(NF) !~ pat) {print $1}' /etc/passwd)
            }
          register: unlocked_accounts_nologin
          changed_when: false
          failed_when: false

        - name: "Lock non-root accounts without valid login shell"
          shell: |
            {
              l_valid_shells="^($(awk -F\/ '$NF != "nologin" {print}' /etc/shells | sed -rn '/^\//{s,/,\\\\/,g;p}' | paste -s -d '|' - ))$"
              while IFS= read -r l_user; do
                status=$(passwd -S "$l_user" 2>/dev/null | awk '{print $2}')
                if [[ "$status" != "L" ]]; then
                  usermod -L "$l_user" 2>/dev/null || true
                fi
              done < <(awk -v pat="$l_valid_shells" -F: '($1 != "root" && $(NF) !~ pat) {print $1}' /etc/passwd)
            }
          register: accounts_locked
          changed_when: false
          failed_when: false

        - name: "Display accounts without valid login shell lock status"
          debug:
            msg: "Non-root accounts without valid login shells have been locked"

    # User Shell Configuration Controls (Section 5.4.3)
    - name: "5.4.3.2 Ensure default user shell timeout is configured (Automated)"
      block:
        - name: "Check current TMOUT configuration in shell files"
          shell: |
            grep -Pls -- '^([^#\n\r]+)?\bTMOUT\b' /etc/*bashrc /etc/profile /etc/profile.d/*.sh 2>/dev/null || echo "not found"
          register: tmout_check
          changed_when: false
          failed_when: false

        - name: "Remove or comment out non-compliant TMOUT settings"
          shell: |
            for file in /etc/bashrc /etc/profile /etc/profile.d/*.sh; do
              if [ -f "$file" ]; then
                sed -ri 's/^\s*(TMOUT|typeset.*TMOUT).*/# &/' "$file"
              fi
            done
          register: tmout_cleanup
          changed_when: false
          failed_when: false

        - name: "Create TMOUT configuration file in /etc/profile.d"
          copy:
            content: |
              # Set TMOUT to 900 seconds for bash and shell timeout
              typeset -xr TMOUT=900
            dest: /etc/profile.d/50-tmout.sh
            owner: root
            group: root
            mode: '0644'
          register: tmout_config

        - name: "Verify TMOUT is set correctly in /etc/profile.d/50-tmout.sh"
          shell: grep -Psi -- 'typeset\h-xr\hTMOUT=900|readonly\hTMOUT|export\hTMOUT' /etc/profile.d/50-tmout.sh
          register: tmout_verify
          changed_when: false
          failed_when: false

        - name: "Display TMOUT configuration status"
          debug:
            msg: "Shell timeout (TMOUT) has been configured to 900 seconds (15 minutes) and set as readonly/exported"

    - name: "5.4.3.3 Ensure default user umask is configured (Automated)"
      block:
        - name: "Check current umask configuration in /etc/profile.d"
          shell: |
            grep -Psi -- '^\h*umask\b' /etc/profile.d/*.sh 2>/dev/null || echo "not found"
          register: umask_profile_d_check
          changed_when: false
          failed_when: false

        - name: "Check current UMASK in /etc/login.defs"
          shell: |
            grep -Psi -- '^\h*UMASK\b' /etc/login.defs 2>/dev/null || echo "not found"
          register: umask_login_defs_check
          changed_when: false
          failed_when: false

        - name: "Comment out non-compliant umask settings in /etc/profile.d/*.sh"
          shell: |
            while IFS= read -r -d $'\0' l_file; do
              sed -ri '/^\s*umask\s+0?(0[01][0-7]|0[0-7][^7]|[^0][0-7][0-7])(\s*|\s+.*)$/s/^/# /' "$l_file"
            done < <(find /etc/profile.d/ -type f -name '*.sh' -print0)
          register: umask_profile_d_cleanup
          changed_when: false
          failed_when: false

        - name: "Create default umask configuration in /etc/profile.d"
          copy:
            content: |
              # Set default umask for user files to 0027 (u=rwx,g=rx,o=)
              umask 0027
            dest: /etc/profile.d/60-default_umask.sh
            owner: root
            group: root
            mode: '0644'
          register: umask_profile_d_config

        - name: "Configure UMASK in /etc/login.defs"
          lineinfile:
            path: /etc/login.defs
            line: "UMASK 027"
            regexp: "^UMASK"
            state: present
          register: umask_login_defs_config

        - name: "Verify umask is configured in /etc/profile.d"
          shell: grep -Psi -- '^\h*umask\h+027\b' /etc/profile.d/60-default_umask.sh
          register: umask_profile_d_verify
          changed_when: false
          failed_when: false

        - name: "Verify UMASK is configured in /etc/login.defs"
          shell: grep -Psi -- '^\h*UMASK\h+027\b' /etc/login.defs
          register: umask_login_defs_verify
          changed_when: false
          failed_when: false

        - name: "Display default user umask configuration status"
          debug:
            msg: "Default user umask has been configured to 0027 (u=rwx,g=rx,o=) in /etc/profile.d and /etc/login.defs"

    # File Integrity Monitoring Configuration Section (6.1)
    - name: "6.1.1 Ensure AIDE is installed (Automated)"
      block:
        - name: "Check if AIDE is installed"
          shell: rpm -q aide
          register: aide_installed
          changed_when: false
          failed_when: false

        - name: "Install AIDE package"
          dnf:
            name: aide
            state: present
          register: aide_install

        - name: "Initialize AIDE database"
          shell: |
            aide --init
            mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz
          register: aide_init
          changed_when: false
          failed_when: false

        - name: "Display AIDE installation status"
          debug:
            msg: "AIDE (Advanced Intrusion Detection Environment) has been installed and initialized"

    - name: "6.1.2 Ensure filesystem integrity is regularly checked (Automated)"
      block:
        - name: "Create AIDE check systemd service file"
          copy:
            content: |
              [Unit]
              Description=Aide Check
              
              [Service]
              Type=simple
              ExecStart=/usr/sbin/aide --check
              
              [Install]
              WantedBy=multi-user.target
            dest: /etc/systemd/system/aidecheck.service
            owner: root
            group: root
            mode: '0644'
          register: aide_service_config

        - name: "Create AIDE check systemd timer file"
          copy:
            content: |
              [Unit]
              Description=Aide check every day at 5AM
              
              [Timer]
              OnCalendar=*-*-* 05:00:00
              Unit=aidecheck.service
              
              [Install]
              WantedBy=multi-user.target
            dest: /etc/systemd/system/aidecheck.timer
            owner: root
            group: root
            mode: '0644'
          register: aide_timer_config

        - name: "Reload systemd daemon"
          shell: systemctl daemon-reload
          register: systemd_reload
          changed_when: false

        - name: "Enable AIDE check service"
          systemd:
            name: aidecheck.service
            enabled: yes
            state: started
          register: aide_service_enable

        - name: "Enable and start AIDE check timer"
          systemd:
            name: aidecheck.timer
            enabled: yes
            state: started
          register: aide_timer_enable

        - name: "Display AIDE check scheduling status"
          debug:
            msg: "AIDE integrity checking has been scheduled to run daily at 05:00 AM via systemd timer"

    - name: "6.1.3 Ensure cryptographic mechanisms are used to protect the integrity of audit tools (Automated)"
      block:
        - name: "Determine audit tools path"
          shell: readlink -f /sbin/auditctl | sed 's|/auditctl||'
          register: audit_tools_path
          changed_when: false
          failed_when: false

        - name: "Add audit tool integrity protection to AIDE configuration"
          shell: |
            {
              audit_path="$(readlink -f /sbin/auditctl | sed 's|/auditctl||')"
              if [ -f /etc/aide.conf ]; then
                echo ""
                echo "# Audit Tools"
                echo "${audit_path}/auditctl p+i+n+u+g+s+b+acl+xattrs+sha512"
                echo "${audit_path}/auditd p+i+n+u+g+s+b+acl+xattrs+sha512"
                echo "${audit_path}/ausearch p+i+n+u+g+s+b+acl+xattrs+sha512"
                echo "${audit_path}/aureport p+i+n+u+g+s+b+acl+xattrs+sha512"
                echo "${audit_path}/autrace p+i+n+u+g+s+b+acl+xattrs+sha512"
                echo "${audit_path}/augenrules p+i+n+u+g+s+b+acl+xattrs+sha512"
              fi
            }
          register: aide_audit_tools
          changed_when: false
          failed_when: false

        - name: "Verify audit tools are included in AIDE configuration"
          shell: grep -c "auditctl.*sha512" /etc/aide.conf 2>/dev/null || echo "0"
          register: aide_audit_check
          changed_when: false
          failed_when: false

        - name: "Display audit tools integrity configuration status"
          debug:
            msg: "AIDE has been configured to monitor audit tools with cryptographic integrity verification (sha512)"

    # Journald Logging Configuration Section (6.2.1)
    - name: "6.2.1.1.1 Ensure journald service is active (Automated)"
      block:
        - name: "Unmask systemd-journald service"
          systemd:
            name: systemd-journald.service
            masked: no
            state: started
          register: journald_unmask

        - name: "Enable systemd-journald service"
          systemd:
            name: systemd-journald.service
            enabled: yes
            state: started
          register: journald_enable

        - name: "Verify systemd-journald is active"
          shell: systemctl is-active systemd-journald.service
          register: journald_active
          changed_when: false
          failed_when: false

        - name: "Display journald service status"
          debug:
            msg: "systemd-journald service is enabled and active for logging"

    - name: "6.2.1.1.2 Ensure journald log file access is configured (Manual)"
      block:
        - name: "Check current journald tmpfiles configuration"
          shell: |
            if [ -f /etc/tmpfiles.d/systemd.conf ]; then
              echo "/etc/tmpfiles.d/systemd.conf exists"
            elif [ -f /usr/lib/tmpfiles.d/systemd.conf ]; then
              echo "/usr/lib/tmpfiles.d/systemd.conf exists (default)"
            fi
          register: journald_tmpfiles_check
          changed_when: false
          failed_when: false

        - name: "Display journald log file access audit status"
          debug:
            msg: "MANUAL AUDIT REQUIRED: Review /etc/tmpfiles.d/systemd.conf or /usr/lib/tmpfiles.d/systemd.conf to ensure file permissions are 0640 or more restrictive"

    - name: "6.2.1.1.3 Ensure journald log file rotation is configured (Manual)"
      block:
        - name: "Check journald configuration directory"
          shell: [ -d /etc/systemd/journald.conf.d ] && echo "exists" || echo "not exists"
          register: journald_conf_d_check
          changed_when: false
          failed_when: false

        - name: "Display journald log rotation audit status"
          debug:
            msg: "MANUAL AUDIT REQUIRED: Review /etc/systemd/journald.conf for log rotation parameters (SystemMaxUse, SystemKeepFree, RuntimeMaxUse, RuntimeKeepFree, MaxFileSec)"

    - name: "6.2.1.1.4 Ensure journald ForwardToSyslog is disabled (Automated)"
      block:
        - name: "Create journald configuration directory if not exists"
          file:
            path: /etc/systemd/journald.conf.d
            state: directory
            owner: root
            group: root
            mode: '0755'
          register: journald_conf_d_create

        - name: "Configure ForwardToSyslog=no in journald"
          copy:
            content: |
              [Journal]
              ForwardToSyslog=no
            dest: /etc/systemd/journald.conf.d/60-journald.conf
            owner: root
            group: root
            mode: '0644'
          register: journald_forward_syslog_config

        - name: "Reload systemd-journald service"
          shell: systemctl reload-or-restart systemd-journald
          register: journald_reload
          changed_when: false

        - name: "Display ForwardToSyslog configuration status"
          debug:
            msg: "journald ForwardToSyslog has been disabled (set to no)"

    - name: "6.2.1.1.5 Ensure journald Storage is configured (Automated)"
      block:
        - name: "Configure journald Storage=persistent"
          lineinfile:
            path: /etc/systemd/journald.conf.d/60-journald.conf
            line: "Storage=persistent"
            regexp: "^Storage"
            create: yes
            state: present
          register: journald_storage_config

        - name: "Reload systemd-journald service for storage configuration"
          shell: systemctl reload-or-restart systemd-journald
          register: journald_storage_reload
          changed_when: false

        - name: "Display journald storage configuration status"
          debug:
            msg: "journald Storage has been configured to persistent (logs will be stored to disk)"

    - name: "6.2.1.1.6 Ensure journald Compress is configured (Automated)"
      block:
        - name: "Configure journald Compress=yes"
          lineinfile:
            path: /etc/systemd/journald.conf.d/60-journald.conf
            line: "Compress=yes"
            regexp: "^Compress"
            create: yes
            state: present
          register: journald_compress_config

        - name: "Reload systemd-journald service for compression"
          shell: systemctl reload-or-restart systemd-journald
          register: journald_compress_reload
          changed_when: false

        - name: "Display journald compression configuration status"
          debug:
            msg: "journald Compress has been enabled (log files will be compressed)"

    - name: "6.2.1.2.1 Ensure systemd-journal-remote is installed (Automated)"
      block:
        - name: "Check if systemd-journal-remote is installed"
          shell: rpm -q systemd-journal-remote
          register: journal_remote_installed
          changed_when: false
          failed_when: false

        - name: "Install systemd-journal-remote package"
          dnf:
            name: systemd-journal-remote
            state: present
          register: journal_remote_install

        - name: "Display systemd-journal-remote installation status"
          debug:
            msg: "systemd-journal-remote has been installed for remote logging capability"

    - name: "6.2.1.2.2 Ensure systemd-journal-remote authentication is configured (Manual)"
      block:
        - name: "Check journal-upload configuration"
          shell: |
            if [ -f /etc/systemd/journal-upload.conf ]; then
              grep -E "URL=|ServerKeyFile=|ServerCertificateFile=|TrustedCertificateFile=" /etc/systemd/journal-upload.conf || echo "not configured"
            else
              echo "journal-upload.conf not found"
            fi
          register: journal_upload_auth_check
          changed_when: false
          failed_when: false

        - name: "Display journal-upload authentication audit status"
          debug:
            msg: "MANUAL CONFIGURATION REQUIRED: Edit /etc/systemd/journal-upload.conf with URL, SSL certificates, and key file paths for remote logging"

    - name: "6.2.1.2.3 Ensure systemd-journal-upload is enabled and active (Automated)"
      block:
        - name: "Check systemd-journal-upload service status"
          shell: systemctl is-enabled systemd-journal-upload.service 2>/dev/null || echo "not enabled"
          register: journal_upload_enabled
          changed_when: false
          failed_when: false

        - name: "Unmask systemd-journal-upload service"
          systemd:
            name: systemd-journal-upload.service
            masked: no
          register: journal_upload_unmask
          failed_when: false

        - name: "Enable and start systemd-journal-upload service"
          systemd:
            name: systemd-journal-upload.service
            enabled: yes
            state: started
          register: journal_upload_enable

        - name: "Display systemd-journal-upload service status"
          debug:
            msg: "systemd-journal-upload service has been enabled and started for remote log transmission"

    - name: "6.2.1.2.4 Ensure systemd-journal-remote service is not in use (Automated)"
      block:
        - name: "Stop systemd-journal-remote socket"
          systemd:
            name: systemd-journal-remote.socket
            state: stopped
            masked: yes
          register: journal_remote_socket_stop
          failed_when: false

        - name: "Stop systemd-journal-remote service"
          systemd:
            name: systemd-journal-remote.service
            state: stopped
            masked: yes
          register: journal_remote_service_stop
          failed_when: false

        - name: "Verify systemd-journal-remote is not enabled"
          shell: |
            socket_status=$(systemctl is-enabled systemd-journal-remote.socket 2>&1)
            service_status=$(systemctl is-enabled systemd-journal-remote.service 2>&1)
            if [[ "$socket_status" == "masked" && "$service_status" == "masked" ]]; then
              echo "both masked"
            fi
          register: journal_remote_verify
          changed_when: false
          failed_when: false

        - name: "Display systemd-journal-remote disable status"
          debug:
            msg: "systemd-journal-remote socket and service have been stopped and masked (not acting as log server)"

    # Rsyslog Logging Configuration Section (6.2.2)
    - name: "6.2.2.1 Ensure rsyslog is installed (Automated)"
      block:
        - name: "Check if rsyslog is installed"
          shell: rpm -q rsyslog
          register: rsyslog_installed
          changed_when: false
          failed_when: false

        - name: "Install rsyslog package"
          dnf:
            name: rsyslog
            state: present
          register: rsyslog_install

        - name: "Display rsyslog installation status"
          debug:
            msg: "rsyslog has been installed as alternative logging service"
